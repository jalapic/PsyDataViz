# Heatmaps

Heatmaps are generated by filling in the cells of a grid with a color gradient or palette. In `ggplot2` the function to use is `geom_tile()` to achieve this effect.

<br>

**Example 1 -Categorical axes**

Here, we have a dataset where we have three columns. The first column represents categorical variables (A to E) that will go on the bottom x-axis. The second column represents categorical variables (A to E) that will go on the y-axis. We have one row for every possible combination, so in this case we have 25 rows. The third column contains the value that we wish to represent by the fill color in the tile of the heatmap. I am using random values between 1 and 100 for this. The higher the value, the deeper the color we will use.

```{r}
set.seed(101)
n <- 5
df <- data.frame(Var1=rep(LETTERS[1:n],n),
                 Var2=rep(LETTERS[1:n],each=n),
                 Value=sample(1:100, replace=T, n*n)
)
head(df)
```

Below, we will plot the heatmap without adding any stylistic elements.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)

```

```{r}
library(tidyverse)

ggplot(df, aes(Var1, Var2, fill = Value)) + 
  geom_tile() 
```

As can be seen, each cell (or tile) has a different degree of color fill based on it's cell value in the `Value` column of the dataframe `df`. Brighter and lighter colors represent higher values of the `Value` column.

A first step to make this prettier may be to add boundaries between the cells. This can be done by adding a `linewidth` and a `color` of this line as follows:

```{r}
ggplot(df, aes(Var1, Var2, fill = Value)) + 
  geom_tile(color="white", linewidth=1.75)
```

This looks nicer. Another thing that bugs me is that the default is to produce rectangular cells rather than square cells. This can be fixed by adding `coord_equal()`.

```{r}
ggplot(df, aes(Var1, Var2, fill = Value)) + 
  geom_tile(color="white", linewidth=1.75) +
  coord_equal()
```

A next step that I often to is to add the following code to ensure that my cells are centered above each label. In this case, this doesn't seem to change very much, but I have found it to be useful occasionally:

```{r}
ggplot(df, aes(Var1, Var2, fill = Value)) + 
  geom_tile(color="white", linewidth=1.75) +
  coord_equal() +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) 
```

The next thing that bugs me about this heatmap is that the default color gradient isn't particularly intuitive to me. I'd rather my values go from a light color (low values) to a darker color (high values). To do this, we can state a low and high color value within `scale_fill_continuous()`. Here, we go from a very light to a darker purple color.

```{r}
ggplot(df, aes(Var1, Var2, fill = Value)) + 
  geom_tile(color="white", linewidth=1.75) +
  coord_equal() +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) + 
  scale_fill_continuous(low="#edf4f7", high="#123abc")
```

Next, I find the axes labels and tick marks annoying, so I can remove these using `xlab("")`, `ylab("")`, and `axis.ticks()` inside `theme()`. I also increase the size of the labels on the axes.

```{r}
ggplot(df, aes(Var1, Var2, fill = Value)) + 
  geom_tile(color="white", linewidth=1.75) +
  coord_equal() +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) + 
  scale_fill_continuous(low="#edf4f7", high="#123abc") +
  xlab("") + 
  ylab("") +
  theme(
    axis.ticks = element_blank(), 
    axis.text = element_text(color="black", size=rel(1.2))
  )

```

Finally, I'd rather my legend be on the bottom of the heatmap, and we don't need the label on the legend. This can also be fixed within the `theme()` argument:

```{r}
ggplot(df, aes(Var1, Var2, fill = Value)) + 
  geom_tile(color="white", linewidth=1.75) +
  coord_equal() +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) + 
  scale_fill_continuous(low="#edf4f7", high="#123abc") +
  xlab("") + 
  ylab("") +
  theme(
    axis.ticks = element_blank(), 
    axis.text = element_text(color="black", size=rel(1.2)),
    legend.text = element_text(color="black", size=rel(1.1)),
    legend.background = element_rect(fill="white"),
    legend.position = "bottom",
    legend.title=element_blank()
  ) 
```

As a quick aside - what happens if we have missing values in our `Value` column? Let's introduce five random `NA` values into that column:

```{r}
df$Value[sample(1:25,5)]<-NA
head(df)

```

Now we can plot with the same code as above:

```{r}
ggplot(df, aes(Var1, Var2, fill = Value)) + 
  geom_tile(color="white", linewidth=1.75) +
  coord_equal() +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) + 
  scale_fill_continuous(low="#edf4f7", high="#123abc") +
  xlab("") + 
  ylab("") +
  theme(
    axis.ticks = element_blank(), 
    axis.text = element_text(color="black", size=rel(1.2)),
    legend.text = element_text(color="black", size=rel(1.1)),
    legend.background = element_rect(fill="white"),
    legend.position = "bottom",
    legend.title=element_blank()
  ) 
```

What happens is that these default to a dark-greyish beige color, as seen above. In some circumstances, this color fill will be fine. However, in other situations we might want to dictate the color. Here, we make those `NA` cells white by adding `na.value = "white"` inside our `scale_fill_continuous()` .

```{r}

ggplot(df, aes(Var1, Var2, fill = Value)) + 
  geom_tile(color="white", linewidth=1.75) +
  coord_equal() +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) + 
  scale_fill_continuous(low="#edf4f7", high="#123abc", na.value = "white") +
  xlab("") + 
  ylab("") +
  theme(
    axis.ticks = element_blank(), 
    axis.text = element_text(color="black", size=rel(1.2)),
    legend.text = element_text(color="black", size=rel(1.1)),
    legend.background = element_rect(fill="white"),
    legend.position = "bottom",
    legend.title=element_blank()
  )
```

<br>

**Example 2 - Discrete numerical axes.**

Axes don't have to be categorical. You can use discrete numbers also. They will be plotted in numerical order. Here we produce an example of a matrix which is 56 columns wide and 4 rows tall.

```{r}
set.seed(101)
df1 <- data.frame(Var1=rep(1:6,4),
                 Var2=rep(1:4,each=6),
                 Value=sample(1:100, replace=T, 24)
)
head(df1)
```

Using the same code as above - just changing the colors to a green palette:

```{r}
ggplot(df1, aes(Var1, Var2, fill = Value)) + 
  geom_tile(color="white", linewidth=1.75) +
  coord_equal() +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) + 
  scale_fill_continuous(low="#ddead1", high="#378805", na.value = "white") +
  xlab("") + 
  ylab("") +
  theme(
    axis.ticks = element_blank(), 
    axis.text = element_text(color="black", size=rel(1.2)),
    legend.text = element_text(color="black", size=rel(1.1)),
    legend.background = element_rect(fill="white"),
    legend.position = "bottom",
    legend.title=element_blank()
  )
```

Note that numeric values don't show automatically here. This is because of the `scale_x_discrete()` and `scale_y_discrete()` lines. We can add the numeric labels by using the continuous scales instead and dictating what the breaks should be if required:

```{r}
ggplot(df1, aes(Var1, Var2, fill = Value)) + 
  geom_tile(color="white", linewidth=1.75) +
  coord_equal() +
  scale_x_continuous(expand = c(0, 0), breaks=1:6) +
  scale_y_continuous(expand = c(0, 0)) + 
  scale_fill_continuous(low="#ddead1", high="#378805", na.value = "white") +
  xlab("") + 
  ylab("") +
  theme(
    axis.ticks = element_blank(), 
    axis.text = element_text(color="black", size=rel(1.2)),
    legend.text = element_text(color="black", size=rel(1.1)),
    legend.background = element_rect(fill="white"),
    legend.position = "bottom",
    legend.title=element_blank()
  )
```

<br>

**Example 3: Correlation Matrices**

A common usage of heatmaps is to illustrate the correlations between a set of continuous variables.

First, we should look at some data. Let's import the dataset `cordata.csv` from our folder `data_raw`. This dataset contains eight continuous variables, boringly named V1, V2,...... V8.

```{r, warning=FALSE, message=FALSE}
cd <- read.csv("data_raw/cordata.csv")
head(cd)
```

A quick way to get all the correlations between continuous variables in a data.frame is to use `cor()`. I'm surrounding this function with `round()` to make the output more easy to read:

```{r}
cdmat <- round(cor(cd),2)
cdmat
```

This matrix is essentially what we want to plot, however, to do that, we first need to turn it into a dataframe with three columns. The first two being the row and column of the eventual plot and the third being the fill value (the correlation coeffecient). We can `melt()` the matrix into that dataframe:

```{r}
cdmat.df <- reshape2::melt(cdmat)
head(cdmat.df)
```

Let's plot this long data using similar code to above. However, here I'm using `scale_fill_gradient2()` to set low, mid and high colors at Pearson correlations of -1, 0 and +1 respectively:

```{r, warning=FALSE}
ggplot(cdmat.df, aes(Var1, Var2, fill = value)) + 
  geom_tile(color="white", linewidth=1.75) +
  coord_equal() +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) + 
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1,1), space = "Lab", 
                       name="Pearson's r")  +
  xlab("") + 
  ylab("") +
  theme(
    axis.ticks = element_blank(), 
    axis.text = element_text(color="black", size=rel(1.2)),
    legend.text = element_text(color="black", size=rel(1.0)),
    legend.background = element_rect(fill="white"),
    legend.position = "bottom"
  )
```

There are three problems with this matrix. First, who cares that the diagonals are all r=1. We don't need that information. Second, correlation matrices have symmetry along the axis, and so we could just plot either the upper or lower triangle of the matrix. Third, these variables could be reordered to make the relationships between variables be more intuitive.

Let's get rid of the diagonal and only keep the lower triangle. We can use the functions `diag()` and `upper.tri()` to make the diagonal and top triangle of the matrix `NA`. Then we melt the matrix again:

```{r}
diag(cdmat)<-NA
cdmat[upper.tri(cdmat)]<-NA
cdmat
```

```{r}
cdlt.df <- reshape2::melt(cdmat)
head(cdlt.df)
```

We can plot this in the same way as before but adding `na.value="white"` inside the `scale_fill_gradient2()` to white out the `NA` values, leaving the bottom of the matrix.

```{r, warning=FALSE}
ggplot(cdlt.df, aes(Var1, Var2, fill = value)) + 
  geom_tile(color="white", linewidth=1.75) +
  coord_equal() +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) + 
  scale_fill_gradient2(low = "blue", high = "red", mid = "white",
                       na.value="white",
                       midpoint = 0, limit = c(-1,1), space = "Lab", 
                       name="Pearson's r")  +
  xlab("") + 
  ylab("") +
  theme(
    axis.ticks = element_blank(), 
    axis.text = element_text(color="black", size=rel(1.2)),
    legend.text = element_text(color="black", size=rel(1.0)),
    legend.background = element_rect(fill="white"),
    legend.position = "bottom"
  )
```

To reorder the matrix, we first need to recreate our original correlation matrix.

```{r, warning=FALSE, message=FALSE}
cdmat1 <- round(cor(cd),2)
cdmat1
```

Next, we can use a clustering method such as hierarchical clustering to identify the relationships between each variable:

```{r, warning=FALSE}
dd <- as.dist((1-cdmat1)/2)
hc <- hclust(dd)
cdmat1 <-cdmat1[hc$order, hc$order]
cdmat1
```

We then do the same process of adding `NA` to the diagonal and upper triangle of the matrix, and we can plot:

```{r, warning=FALSE}
diag(cdmat1)<-NA
cdmat1[upper.tri(cdmat1)]<-NA
cdlt1.df <- reshape2::melt(cdmat1)

ggplot(cdlt1.df, aes(Var1, Var2, fill = value)) + 
  geom_tile(color="white", linewidth=1.75) +
  coord_equal() +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) + 
  scale_fill_gradient2(low = "blue", high = "red", mid = "white",
                       na.value="white",
                       midpoint = 0, limit = c(-1,1), space = "Lab", 
                       name="Pearson's r")  +
  xlab("") + 
  ylab("") +
  theme(
    axis.ticks = element_blank(), 
    axis.text = element_text(color="black", size=rel(1.2)),
    legend.text = element_text(color="black", size=rel(1.0)),
    legend.background = element_rect(fill="white"),
    legend.position = "bottom"
  )
```

One final step that we might want to do is to add the actual correlations over the top of the colored cells. We can add this with `geom_text()`.

```{r, warning=FALSE}
ggplot(cdlt1.df, aes(Var1, Var2, fill = value)) + 
  geom_tile(color="white", linewidth=1.75) +
  coord_equal() +
  geom_text(aes(Var1, Var2, label = value), color = "black", size = 3.5) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) + 
  scale_fill_gradient2(low = "blue", high = "red", mid = "white",
                       na.value="white",
                       midpoint = 0, limit = c(-1,1), space = "Lab", 
                       name="Pearson's r")  +
  xlab("") + 
  ylab("") +
  theme(
    axis.ticks = element_blank(), 
    axis.text = element_text(color="black", size=rel(1.2)),
    legend.text = element_text(color="black", size=rel(1.0)),
    legend.background = element_rect(fill="white"),
    legend.position = "bottom"
  ) 
```

<br>

<br>
