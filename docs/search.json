[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PsyDataViz",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code. Adding something to check.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "heatmaps.html",
    "href": "heatmaps.html",
    "title": "2  Heatmaps",
    "section": "",
    "text": "Heatmaps are generated by filling in the cells of a grid with a color gradient or palette. In ggplot2 the function to use is geom_tile() to achieve this effect.\n\n\n2.0.1 Example 1 -Categorical axes\nHere, we have a dataset where we have three columns. The first column represents categorical variables (A to E) that will go on the bottom x-axis. The second column represents categorical variables (A to E) that will go on the y-axis. We have one row for every possible combination, so in this case we have 25 rows. The third column contains the value that we wish to represent by the fill color in the tile of the heatmap. I am using random values between 1 and 100 for this. The higher the value, the deeper the color we will use.\n\nset.seed(101)\nn <- 5\ndf <- data.frame(Var1=rep(LETTERS[1:n],n),\n                 Var2=rep(LETTERS[1:n],each=n),\n                 Value=sample(1:100, replace=T, n*n)\n)\nhead(df)\n\n  Var1 Var2 Value\n1    A    A    73\n2    B    A    57\n3    C    A    46\n4    D    A    95\n5    E    A    81\n6    A    B    58\n\n\nBelow, we will plot the heatmap without adding any stylistic elements.\n\n\n\n\nlibrary(tidyverse)\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile() \n\n\n\n\nAs can be seen, each cell (or tile) has a different degree of color fill based on it’s cell value in the Value column of the dataframe df. Brighter and lighter colors represent higher values of the Value column.\nA first step to make this prettier may be to add boundaries between the cells. This can be done by adding a linewidth and a color of this line as follows:\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75)\n\n\n\n\nThis looks nicer. Another thing that bugs me is that the default is to produce rectangular cells rather than square cells. This can be fixed by adding coord_equal().\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal()\n\n\n\n\nA next step that I often to is to add the following code to ensure that my cells are centered above each label. In this case, this doesn’t seem to change very much, but I have found it to be useful occasionally:\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) \n\n\n\n\nThe next thing that bugs me about this heatmap is that the default color gradient isn’t particularly intuitive to me. I’d rather my values go from a light color (low values) to a darker color (high values). To do this, we can state a low and high color value within scale_fill_continuous(). Here, we go from a very light to a darker purple color.\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\")\n\n\n\n\nNext, I find the axes labels and tick marks annoying, so I can remove these using xlab(\"\"), ylab(\"\"), and axis.ticks() inside theme(). I also increase the size of the labels on the axes.\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2))\n  )\n\n\n\n\nFinally, I’d rather my legend be on the bottom of the heatmap, and we don’t need the label on the legend. This can also be fixed within the theme() argument:\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  ) \n\n\n\n\nAs a quick aside - what happens if we have missing values in our Value column? Let’s introduce five random NA values into that column:\n\ndf$Value[sample(1:25,5)]<-NA\nhead(df)\n\n  Var1 Var2 Value\n1    A    A    NA\n2    B    A    57\n3    C    A    46\n4    D    A    95\n5    E    A    81\n6    A    B    NA\n\n\nNow we can plot with the same code as above:\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  ) \n\n\n\n\nWhat happens is that these default to a dark-greyish beige color, as seen above. In some circumstances, this color fill will be fine. However, in other situations we might want to dictate the color. Here, we make those NA cells white by adding na.value = \"white\" inside our scale_fill_continuous() .\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\", na.value = \"white\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  )\n\n\n\n\n\n\n\n2.0.2 Example 2 - Discrete numerical axes.\nAxes don’t have to be categorical. You can use discrete numbers also. They will be plotted in numerical order. Here we produce an example of a matrix which is 56 columns wide and 4 rows tall.\n\nset.seed(101)\ndf1 <- data.frame(Var1=rep(1:6,4),\n                 Var2=rep(1:4,each=6),\n                 Value=sample(1:100, replace=T, 24)\n)\nhead(df1)\n\n  Var1 Var2 Value\n1    1    1    73\n2    2    1    57\n3    3    1    46\n4    4    1    95\n5    5    1    81\n6    6    1    58\n\n\nUsing the same code as above - just changing the colors to a green palette:\n\nggplot(df1, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#ddead1\", high=\"#378805\", na.value = \"white\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  )\n\n\n\n\nNote that numeric values don’t show automatically here. This is because of the scale_x_discrete() and scale_y_discrete() lines. We can add the numeric labels by using the continuous scales instead and dictating what the breaks should be if required:\n\nggplot(df1, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_continuous(expand = c(0, 0), breaks=1:6) +\n  scale_y_continuous(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#ddead1\", high=\"#378805\", na.value = \"white\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  )\n\n\n\n\n\n\n\n2.0.3 Example 3: Correlation Matrices\nA common usage of heatmaps is to illustrate the correlations between a set of continuous variables.\nFirst, we should look at some data. Let’s import the dataset cordata.csv from our folder data_raw. This dataset contains eight continuous variables, boringly named V1, V2,…… V8.\n\ncd <- read.csv(\"data_raw/cordata.csv\")\nhead(cd)\n\n    V1    V2     V3     V4    V5     V6    V7   V8\n1 7.07 34.18 179.62 141.72 14.24 113.47 15.83 1.59\n2 7.43 43.51 107.77 111.40 10.86 139.11 16.76 0.00\n3 1.75  4.74 224.06 113.71 10.65 102.81 22.50 7.29\n4 0.68 16.75  20.00 101.66 16.48 127.23 22.12 5.36\n5 3.15 19.81 251.27 144.41 10.08 125.46 22.34 7.73\n6 3.60 27.98 233.61 137.11 10.02 156.36 24.18 2.18\n\n\nA quick way to get all the correlations between continuous variables in a data.frame is to use cor(). I’m surrounding this function with round() to make the output more easy to read:\n\ncdmat <- round(cor(cd),2)\ncdmat\n\n      V1    V2    V3    V4    V5    V6    V7    V8\nV1  1.00  0.87 -0.26 -0.02  0.15  0.19 -0.75 -0.79\nV2  0.87  1.00 -0.33 -0.15  0.15  0.17 -0.74 -0.92\nV3 -0.26 -0.33  1.00  0.34 -0.81 -0.25  0.44  0.38\nV4 -0.02 -0.15  0.34  1.00 -0.03  0.40  0.03  0.26\nV5  0.15  0.15 -0.81 -0.03  1.00  0.33 -0.30 -0.23\nV6  0.19  0.17 -0.25  0.40  0.33  1.00 -0.39 -0.08\nV7 -0.75 -0.74  0.44  0.03 -0.30 -0.39  1.00  0.64\nV8 -0.79 -0.92  0.38  0.26 -0.23 -0.08  0.64  1.00\n\n\nThis matrix is essentially what we want to plot, however, to do that, we first need to turn it into a dataframe with three columns. The first two being the row and column of the eventual plot and the third being the fill value (the correlation coeffecient). We can melt() the matrix into that dataframe:\n\ncdmat.df <- reshape2::melt(cdmat)\nhead(cdmat.df)\n\n  Var1 Var2 value\n1   V1   V1  1.00\n2   V2   V1  0.87\n3   V3   V1 -0.26\n4   V4   V1 -0.02\n5   V5   V1  0.15\n6   V6   V1  0.19\n\n\nLet’s plot this long data using similar code to above. However, here I’m using scale_fill_gradient2() to set low, mid and high colors at Pearson correlations of -1, 0 and +1 respectively:\n\nggplot(cdmat.df, aes(Var1, Var2, fill = value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_gradient2(low = \"blue\", high = \"red\", mid = \"white\", \n                       midpoint = 0, limit = c(-1,1), space = \"Lab\", \n                       name=\"Pearson's r\")  +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.0)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\"\n  )\n\n\n\n\nThere are three problems with this matrix. First, who cares that the diagonals are all r=1. We don’t need that information. Second, correlation matrices have symmetry along the axis, and so we could just plot either the upper or lower triangle of the matrix. Third, these variables could be reordered to make the relationships between variables be more intuitive.\nLet’s get rid of the diagonal and only keep the lower triangle. We can use the functions diag() and upper.tri() to make the diagonal and top triangle of the matrix NA. Then we melt the matrix again:\n\ndiag(cdmat)<-NA\ncdmat[upper.tri(cdmat)]<-NA\ncdmat\n\n      V1    V2    V3    V4    V5    V6   V7 V8\nV1    NA    NA    NA    NA    NA    NA   NA NA\nV2  0.87    NA    NA    NA    NA    NA   NA NA\nV3 -0.26 -0.33    NA    NA    NA    NA   NA NA\nV4 -0.02 -0.15  0.34    NA    NA    NA   NA NA\nV5  0.15  0.15 -0.81 -0.03    NA    NA   NA NA\nV6  0.19  0.17 -0.25  0.40  0.33    NA   NA NA\nV7 -0.75 -0.74  0.44  0.03 -0.30 -0.39   NA NA\nV8 -0.79 -0.92  0.38  0.26 -0.23 -0.08 0.64 NA\n\n\n\ncdlt.df <- reshape2::melt(cdmat)\nhead(cdlt.df)\n\n  Var1 Var2 value\n1   V1   V1    NA\n2   V2   V1  0.87\n3   V3   V1 -0.26\n4   V4   V1 -0.02\n5   V5   V1  0.15\n6   V6   V1  0.19\n\n\nWe can plot this in the same way as before but adding na.value=\"white\" inside the scale_fill_gradient2() to white out the NA values, leaving the bottom of the matrix.\n\nggplot(cdlt.df, aes(Var1, Var2, fill = value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_gradient2(low = \"blue\", high = \"red\", mid = \"white\",\n                       na.value=\"white\",\n                       midpoint = 0, limit = c(-1,1), space = \"Lab\", \n                       name=\"Pearson's r\")  +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.0)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\"\n  )\n\n\n\n\nTo reorder the matrix, we first need to recreate our original correlation matrix.\n\ncdmat1 <- round(cor(cd),2)\ncdmat1\n\n      V1    V2    V3    V4    V5    V6    V7    V8\nV1  1.00  0.87 -0.26 -0.02  0.15  0.19 -0.75 -0.79\nV2  0.87  1.00 -0.33 -0.15  0.15  0.17 -0.74 -0.92\nV3 -0.26 -0.33  1.00  0.34 -0.81 -0.25  0.44  0.38\nV4 -0.02 -0.15  0.34  1.00 -0.03  0.40  0.03  0.26\nV5  0.15  0.15 -0.81 -0.03  1.00  0.33 -0.30 -0.23\nV6  0.19  0.17 -0.25  0.40  0.33  1.00 -0.39 -0.08\nV7 -0.75 -0.74  0.44  0.03 -0.30 -0.39  1.00  0.64\nV8 -0.79 -0.92  0.38  0.26 -0.23 -0.08  0.64  1.00\n\n\nNext, we can use a clustering method such as hierarchical clustering to identify the relationships between each variable:\n\ndd <- as.dist((1-cdmat1)/2)\nhc <- hclust(dd)\ncdmat1 <-cdmat1[hc$order, hc$order]\ncdmat1\n\n      V3    V7    V8    V4    V6    V5    V1    V2\nV3  1.00  0.44  0.38  0.34 -0.25 -0.81 -0.26 -0.33\nV7  0.44  1.00  0.64  0.03 -0.39 -0.30 -0.75 -0.74\nV8  0.38  0.64  1.00  0.26 -0.08 -0.23 -0.79 -0.92\nV4  0.34  0.03  0.26  1.00  0.40 -0.03 -0.02 -0.15\nV6 -0.25 -0.39 -0.08  0.40  1.00  0.33  0.19  0.17\nV5 -0.81 -0.30 -0.23 -0.03  0.33  1.00  0.15  0.15\nV1 -0.26 -0.75 -0.79 -0.02  0.19  0.15  1.00  0.87\nV2 -0.33 -0.74 -0.92 -0.15  0.17  0.15  0.87  1.00\n\n\nWe then do the same process of adding NA to the diagonal and upper triangle of the matrix, and we can plot:\n\ndiag(cdmat1)<-NA\ncdmat1[upper.tri(cdmat1)]<-NA\ncdlt1.df <- reshape2::melt(cdmat1)\n\nggplot(cdlt1.df, aes(Var1, Var2, fill = value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_gradient2(low = \"blue\", high = \"red\", mid = \"white\",\n                       na.value=\"white\",\n                       midpoint = 0, limit = c(-1,1), space = \"Lab\", \n                       name=\"Pearson's r\")  +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.0)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\"\n  )\n\n\n\n\nOne final step that we might want to do is to add the actual correlations over the top of the colored cells. We can add this with geom_text().\n\nggplot(cdlt1.df, aes(Var1, Var2, fill = value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  geom_text(aes(Var1, Var2, label = value), color = \"black\", size = 3.5) +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_gradient2(low = \"blue\", high = \"red\", mid = \"white\",\n                       na.value=\"white\",\n                       midpoint = 0, limit = c(-1,1), space = \"Lab\", \n                       name=\"Pearson's r\")  +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.0)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\"\n  ) \n\n\n\n\n\n\n\n\n2.0.4 Some practical examples\nBelow are some well known examples of using geom_tile() to create heatmaps examining trends in the prevalence of diseseas over time. First, we’ll look at the effect of birth month on risk of developing schizophrenia in an Australian cohort. This is using the schz dataset from the season R package:\n\nschz <- read.csv(\"data_raw/schz.csv\")\nhead(schz)\n\n  year month    yrmon NBirths SczBroad  SOI\n1 1930     1 1930.000    1578        8 12.7\n2 1930     2 1930.083    1519       11  7.7\n3 1930     3 1930.167    1630       15  1.8\n4 1930     4 1930.250    1607       12 -3.8\n5 1930     5 1930.333    1566       10  2.1\n6 1930     6 1930.417    1491        8 -5.5\n\nrange(schz$year)\n\n[1] 1930 1971\n\n\nEach row of this dataset contains information on the incidence of schizophrenia for individuals born for each month of the year between 1930-1971. We use the column SczBroad as a measure of schizophrenia risk at each timepoint.\nWe plot the data below using similar code to above. In addition, we are using scale_fill_viridis() from the viridis R package to fill our tiles from a gradient of dark purple (low risk) to bright yellow (high risk). We are using option D, one of four colorblind friendly palettes available in this package. Within theme() most of the lines are making the background panel and borders a dark gray color (gray10), and adjusting the placement of text labels.\n\nlibrary(viridis)\n\nLoading required package: viridisLite\n\nggplot(schz, aes(year, month, fill = SczBroad)) + \n  geom_tile(colour=\"gray10\", linewidth=1.1) + \n  coord_equal() +\n  scale_fill_viridis(option=\"D\",na.value = \"gray10\") +\n  scale_y_continuous(breaks=1:12, labels=month.abb[1:12])+\n  xlab(\"\") + \n  ylab(\"\") +\n  ggtitle(\"Schizophrenia Risk By Birth Month and Year in Australia\") +\n  theme(\n    plot.title = element_text(color=\"white\",hjust=0,vjust=1, size=rel(1.3)),\n    plot.background = element_rect(fill=\"gray10\"),\n    panel.background = element_rect(fill=\"gray10\"),\n    panel.border = element_rect(fill=NA,color=\"gray10\", linewidth = 0.5, linetype=\"solid\"),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    axis.line = element_blank(),\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"white\", size=rel(0.8)),\n    axis.text.y  = element_text(hjust=1, margin = margin(r = -20)),\n    legend.text = element_text(color=\"white\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"gray10\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  )\n\n\n\n\n\nIn the next example, we are looking at the effect of the introduction of vaccinations on the prevalence of measles in the USA. The data are in the diseases.csv dataset. I’ve based this on code from this blog post.\n\ndis <- read.csv(\"data_raw/diseases.csv\")\nhead(dis)\n\n      disease   state year weeks_reporting count population\n1 Hepatitis A Alabama 1966              50   321    3345787\n2 Hepatitis A Alabama 1967              49   291    3364130\n3 Hepatitis A Alabama 1968              52   314    3386068\n4 Hepatitis A Alabama 1969              49   380    3412450\n5 Hepatitis A Alabama 1970              51   413    3444165\n6 Hepatitis A Alabama 1971              51   378    3481798\n\n\nThe dataset contains the total number of cases reported by each state for each disease for each year between 1928-2011. It should be noted that not all states start at the same time point. As can be seen above, Alabama’s Hepatitis reporting starts in 1966. In total, there are data on 7 different diseases, but we’ll just look at measles.\n\ntable(dis$disease)\n\n\nHepatitis A     Measles       Mumps   Pertussis       Polio     Rubella \n       2346        3876        1836        3774        3774        1938 \n   Smallpox \n       1326 \n\n\nTo compare across years and states, we need to make our data more uniform. One way is to look at the number of cases per e.g. 100,000 people. However, this is complicated by the issue that the data don’t come from full years but from different number of weeks within a year. So first, we should get a “per week” count for each disease in each state and then multiply by 52 to get a “per year” count. Then we can divide this by the population of the state in that year and multiply that by 100,000 to get an incidence per 100k people:\n\ndis.sum <- dis %>%\n  group_by(state,disease,year) %>%\n  summarise(peryear = 52*(count/weeks_reporting),\n            per100k = 100000*(peryear/population))\n\nhead(dis.sum)\n\n# A tibble: 6 x 5\n# Groups:   state, disease [1]\n  state   disease      year peryear per100k\n  <chr>   <chr>       <int>   <dbl>   <dbl>\n1 Alabama Hepatitis A  1966    334.    9.98\n2 Alabama Hepatitis A  1967    309.    9.18\n3 Alabama Hepatitis A  1968    314     9.27\n4 Alabama Hepatitis A  1969    403.   11.8 \n5 Alabama Hepatitis A  1970    421.   12.2 \n6 Alabama Hepatitis A  1971    385.   11.1 \n\n\nLet’s focus on Hepatitis A. Before plotting we will do two additional data carpentry steps. We will first reverse the order of the levels of the factor state. The default way to plot these states will be in alphabetical order along the y-axis starting with Alabama closest to the x-axis and Wyoming the furthest away. However, this is annoying to read as we are used to seeing A’s at the top and W’s near the bottom of a list of states. Second, rather than filling the tiles in a continuous gradient, we will create 7 discrete bins of color. These bins are not equivalent in terms of size which does somewhat break the rules of data visualization - i.e. an equal step in color gradient should map to an equal step in value. However, I think it can be justified in this context as we are interested in picking out “very low”, “low”, “medium”, “high”, “very high” number of cases etc. This new variable will be called countfactor.\n\nmeas <- dis.sum %>% filter(disease==\"Measles\") %>%\n        mutate(countfactor=cut(per100k, breaks=c(-1, 0, 1, 10, 100, 500, 1000, max(per100k, na.rm=T)),labels=c(\"0\", \"0-1\", \"1-10\", \"10-100\", \"100-500\", \"500-1000\", \">1000\"))) %>%\n  mutate(countfactor=factor(as.character(countfactor), levels=rev(levels(countfactor))))\n\nmeas$state <- factor(meas$state, levels = rev(unique(meas$state)))\n\nhead(meas)\n\n# A tibble: 6 x 6\n# Groups:   state, disease [1]\n  state   disease  year peryear per100k countfactor\n  <fct>   <chr>   <int>   <dbl>   <dbl> <fct>      \n1 Alabama Measles  1928   8843    341.  100-500    \n2 Alabama Measles  1929   3140.   120.  100-500    \n3 Alabama Measles  1930   4156    157.  100-500    \n4 Alabama Measles  1931   9481.   355.  100-500    \n5 Alabama Measles  1932    342.    12.7 10-100     \n6 Alabama Measles  1933   1769.    65.2 10-100     \n\n\nBelow we plot the data using geom_tile(). We use scale_fill_manual() with 7 colors that we pick ourselves to represent the 7 categories. Inside theme() we control the sizes and colors of text and the background colors. We also use coord_cartesian(), geom_vline() and annotate() to add the black line at 1963 and associate text to indicate when the vaccine was introduced.\n\n# assign text color\ntextcol <- \"grey40\"\n\np <- ggplot(meas, aes(x=year, y=state, fill=countfactor))+\n  geom_tile(color=\"white\", linewidth=0.2)+\n  guides(fill=guide_legend(title=\"Cases per\\n100,000 people\"))+\n  labs(x=\"\", y=\"\", title=\"Incidence of Measles in the US\")+\n  scale_y_discrete(expand=c(0, 0))+\n  scale_x_continuous(expand=c(0, 0), breaks=seq(1930,2000,10))+\n  scale_fill_manual(values=c(\"#d53e4f\", \"#f46d43\", \"#fdae61\", \"#fee08b\", \"#e6f598\", \"#abdda4\", \"#ddf1da\"), na.value = \"grey90\")+\n  coord_cartesian(clip = 'off')+\n  geom_vline(xintercept = 1963, col = \"black\") +\n  theme_grey(base_size=10)+\n  theme(legend.position=\"right\", legend.direction=\"vertical\",\n        legend.title=element_text(colour=textcol),\n        legend.margin=margin(grid::unit(0, \"cm\")),\n        legend.text=element_text(colour=textcol, size=7, face=\"bold\"),\n        legend.key.height=grid::unit(0.8, \"cm\"),\n        legend.key.width=grid::unit(0.2, \"cm\"),\n        axis.text.x=element_text(size=10, color=textcol),\n        axis.text.y=element_text(vjust=0.2, size=rel(0.7), color=textcol),\n        axis.ticks=element_line(size=0.4),\n        plot.background=element_blank(),\n        panel.border=element_blank(),\n        plot.margin=margin(0.7, 0.4, 0.1, 0.2, \"cm\"),\n        plot.title=element_text(colour=textcol, hjust=0, size=14, face=\"bold\")\n      )+ \n  annotate(geom = \"text\", x = 1963.5, y = 52, label = \"Vaccine introduced\", size = 3, hjust = 0)\n\nWarning: The `size` argument of `element_line()` is deprecated as of ggplot2 3.4.0.\ni Please use the `linewidth` argument instead.\n\np\n\n\n\n\n\nRather than manually writing in the colors we want to represent each discrete group, we could also use a palette of 7 colors by using the RColorBrewer package.\n\nlibrary(RColorBrewer)\np + scale_fill_manual(values=rev(brewer.pal(7, \"YlGnBu\")), na.value=\"grey90\")"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "4  Summary",
    "section": "",
    "text": "There is no summary. I was just scared to delete this file."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "heatmaps.html#example-1--categorical-axes",
    "href": "heatmaps.html#example-1--categorical-axes",
    "title": "2  Heatmaps",
    "section": "2.1 Example 1 -Categorical axes",
    "text": "2.1 Example 1 -Categorical axes\nHere, we have a dataset where we have three columns. The first column represents categorical variables (A to E) that will go on the bottom x-axis. The second column represents categorical variables (A to E) that will go on the y-axis. We have one row for every possible combination, so in this case we have 25 rows. The third column contains the value that we wish to represent by the fill color in the tile of the heatmap. I am using random values between 1 and 100 for this. The higher the value, the deeper the color we will use.\n\nset.seed(101)\nn <- 5\ndf <- data.frame(Var1=rep(LETTERS[1:n],n),\n                 Var2=rep(LETTERS[1:n],each=n),\n                 Value=sample(1:100, replace=T, n*n)\n)\nhead(df)\n\n  Var1 Var2 Value\n1    A    A    73\n2    B    A    57\n3    C    A    46\n4    D    A    95\n5    E    A    81\n6    A    B    58\n\n\nBelow, we will plot the heatmap without adding any stylistic elements.\n\n\n\n\nlibrary(tidyverse)\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile() \n\n\n\n\nAs can be seen, each cell (or tile) has a different degree of color fill based on it’s cell value in the Value column of the dataframe df. Brighter and lighter colors represent higher values of the Value column.\nA first step to make this prettier may be to add boundaries between the cells. This can be done by adding a linewidth and a color of this line as follows:\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75)\n\n\n\n\nThis looks nicer. Another thing that bugs me is that the default is to produce rectangular cells rather than square cells. This can be fixed by adding coord_equal().\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal()\n\n\n\n\nA next step that I often to is to add the following code to ensure that my cells are centered above each label. In this case, this doesn’t seem to change very much, but I have found it to be useful occasionally:\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) \n\n\n\n\nThe next thing that bugs me about this heatmap is that the default color gradient isn’t particularly intuitive to me. I’d rather my values go from a light color (low values) to a darker color (high values). To do this, we can state a low and high color value within scale_fill_continuous(). Here, we go from a very light to a darker purple color.\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\")\n\n\n\n\nNext, I find the axes labels and tick marks annoying, so I can remove these using xlab(\"\"), ylab(\"\"), and axis.ticks() inside theme(). I also increase the size of the labels on the axes.\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2))\n  )\n\n\n\n\nFinally, I’d rather my legend be on the bottom of the heatmap, and we don’t need the label on the legend. This can also be fixed within the theme() argument:\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  ) \n\n\n\n\nAs a quick aside - what happens if we have missing values in our Value column? Let’s introduce five random NA values into that column:\n\ndf$Value[sample(1:25,5)]<-NA\nhead(df)\n\n  Var1 Var2 Value\n1    A    A    NA\n2    B    A    57\n3    C    A    46\n4    D    A    95\n5    E    A    81\n6    A    B    NA\n\n\nNow we can plot with the same code as above:\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  ) \n\n\n\n\nWhat happens is that these default to a dark-greyish beige color, as seen above. In some circumstances, this color fill will be fine. However, in other situations we might want to dictate the color. Here, we make those NA cells white by adding na.value = \"white\" inside our scale_fill_continuous() .\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\", na.value = \"white\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  )"
  },
  {
    "objectID": "heatmaps.html#example-2---discrete-numerical-axes.",
    "href": "heatmaps.html#example-2---discrete-numerical-axes.",
    "title": "2  Heatmaps",
    "section": "2.2 Example 2 - Discrete numerical axes.",
    "text": "2.2 Example 2 - Discrete numerical axes.\nAxes don’t have to be categorical. You can use discrete numbers also. They will be plotted in numerical order. Here we produce an example of a matrix which is 56 columns wide and 4 rows tall.\n\nset.seed(101)\ndf1 <- data.frame(Var1=rep(1:6,4),\n                 Var2=rep(1:4,each=6),\n                 Value=sample(1:100, replace=T, 24)\n)\nhead(df1)\n\n  Var1 Var2 Value\n1    1    1    73\n2    2    1    57\n3    3    1    46\n4    4    1    95\n5    5    1    81\n6    6    1    58\n\n\nUsing the same code as above - just changing the colors to a green palette:\n\nggplot(df1, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#ddead1\", high=\"#378805\", na.value = \"white\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  )\n\n\n\n\nNote that numeric values don’t show automatically here. This is because of the scale_x_discrete() and scale_y_discrete() lines. We can add the numeric labels by using the continuous scales instead and dictating what the breaks should be if required:\n\nggplot(df1, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_continuous(expand = c(0, 0), breaks=1:6) +\n  scale_y_continuous(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#ddead1\", high=\"#378805\", na.value = \"white\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  )"
  },
  {
    "objectID": "heatmaps.html#example-3-correlation-matrices",
    "href": "heatmaps.html#example-3-correlation-matrices",
    "title": "2  Heatmaps",
    "section": "2.3 Example 3: Correlation Matrices",
    "text": "2.3 Example 3: Correlation Matrices\nA common usage of heatmaps is to illustrate the correlations between a set of continuous variables.\nFirst, we should look at some data. Let’s import the dataset cordata.csv from our folder data_raw. This dataset contains eight continuous variables, boringly named V1, V2,…… V8.\n\ncd <- read.csv(\"data_raw/cordata.csv\")\nhead(cd)\n\n    V1    V2     V3     V4    V5     V6    V7   V8\n1 7.07 34.18 179.62 141.72 14.24 113.47 15.83 1.59\n2 7.43 43.51 107.77 111.40 10.86 139.11 16.76 0.00\n3 1.75  4.74 224.06 113.71 10.65 102.81 22.50 7.29\n4 0.68 16.75  20.00 101.66 16.48 127.23 22.12 5.36\n5 3.15 19.81 251.27 144.41 10.08 125.46 22.34 7.73\n6 3.60 27.98 233.61 137.11 10.02 156.36 24.18 2.18\n\n\nA quick way to get all the correlations between continuous variables in a data.frame is to use cor(). I’m surrounding this function with round() to make the output more easy to read:\n\ncdmat <- round(cor(cd),2)\ncdmat\n\n      V1    V2    V3    V4    V5    V6    V7    V8\nV1  1.00  0.87 -0.26 -0.02  0.15  0.19 -0.75 -0.79\nV2  0.87  1.00 -0.33 -0.15  0.15  0.17 -0.74 -0.92\nV3 -0.26 -0.33  1.00  0.34 -0.81 -0.25  0.44  0.38\nV4 -0.02 -0.15  0.34  1.00 -0.03  0.40  0.03  0.26\nV5  0.15  0.15 -0.81 -0.03  1.00  0.33 -0.30 -0.23\nV6  0.19  0.17 -0.25  0.40  0.33  1.00 -0.39 -0.08\nV7 -0.75 -0.74  0.44  0.03 -0.30 -0.39  1.00  0.64\nV8 -0.79 -0.92  0.38  0.26 -0.23 -0.08  0.64  1.00\n\n\nThis matrix is essentially what we want to plot, however, to do that, we first need to turn it into a dataframe with three columns. The first two being the row and column of the eventual plot and the third being the fill value (the correlation coeffecient). We can melt() the matrix into that dataframe:\n\ncdmat.df <- reshape2::melt(cdmat)\nhead(cdmat.df)\n\n  Var1 Var2 value\n1   V1   V1  1.00\n2   V2   V1  0.87\n3   V3   V1 -0.26\n4   V4   V1 -0.02\n5   V5   V1  0.15\n6   V6   V1  0.19\n\n\nLet’s plot this long data using similar code to above. However, here I’m using scale_fill_gradient2() to set low, mid and high colors at Pearson correlations of -1, 0 and +1 respectively:\n\nggplot(cdmat.df, aes(Var1, Var2, fill = value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_gradient2(low = \"blue\", high = \"red\", mid = \"white\", \n                       midpoint = 0, limit = c(-1,1), space = \"Lab\", \n                       name=\"Pearson's r\")  +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.0)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\"\n  )\n\n\n\n\nThere are three problems with this matrix. First, who cares that the diagonals are all r=1. We don’t need that information. Second, correlation matrices have symmetry along the axis, and so we could just plot either the upper or lower triangle of the matrix. Third, these variables could be reordered to make the relationships between variables be more intuitive.\nLet’s get rid of the diagonal and only keep the lower triangle. We can use the functions diag() and upper.tri() to make the diagonal and top triangle of the matrix NA. Then we melt the matrix again:\n\ndiag(cdmat)<-NA\ncdmat[upper.tri(cdmat)]<-NA\ncdmat\n\n      V1    V2    V3    V4    V5    V6   V7 V8\nV1    NA    NA    NA    NA    NA    NA   NA NA\nV2  0.87    NA    NA    NA    NA    NA   NA NA\nV3 -0.26 -0.33    NA    NA    NA    NA   NA NA\nV4 -0.02 -0.15  0.34    NA    NA    NA   NA NA\nV5  0.15  0.15 -0.81 -0.03    NA    NA   NA NA\nV6  0.19  0.17 -0.25  0.40  0.33    NA   NA NA\nV7 -0.75 -0.74  0.44  0.03 -0.30 -0.39   NA NA\nV8 -0.79 -0.92  0.38  0.26 -0.23 -0.08 0.64 NA\n\n\n\ncdlt.df <- reshape2::melt(cdmat)\nhead(cdlt.df)\n\n  Var1 Var2 value\n1   V1   V1    NA\n2   V2   V1  0.87\n3   V3   V1 -0.26\n4   V4   V1 -0.02\n5   V5   V1  0.15\n6   V6   V1  0.19\n\n\nWe can plot this in the same way as before but adding na.value=\"white\" inside the scale_fill_gradient2() to white out the NA values, leaving the bottom of the matrix.\n\nggplot(cdlt.df, aes(Var1, Var2, fill = value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_gradient2(low = \"blue\", high = \"red\", mid = \"white\",\n                       na.value=\"white\",\n                       midpoint = 0, limit = c(-1,1), space = \"Lab\", \n                       name=\"Pearson's r\")  +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.0)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\"\n  )\n\n\n\n\nTo reorder the matrix, we first need to recreate our original correlation matrix.\n\ncdmat1 <- round(cor(cd),2)\ncdmat1\n\n      V1    V2    V3    V4    V5    V6    V7    V8\nV1  1.00  0.87 -0.26 -0.02  0.15  0.19 -0.75 -0.79\nV2  0.87  1.00 -0.33 -0.15  0.15  0.17 -0.74 -0.92\nV3 -0.26 -0.33  1.00  0.34 -0.81 -0.25  0.44  0.38\nV4 -0.02 -0.15  0.34  1.00 -0.03  0.40  0.03  0.26\nV5  0.15  0.15 -0.81 -0.03  1.00  0.33 -0.30 -0.23\nV6  0.19  0.17 -0.25  0.40  0.33  1.00 -0.39 -0.08\nV7 -0.75 -0.74  0.44  0.03 -0.30 -0.39  1.00  0.64\nV8 -0.79 -0.92  0.38  0.26 -0.23 -0.08  0.64  1.00\n\n\nNext, we can use a clustering method such as hierarchical clustering to identify the relationships between each variable:\n\ndd <- as.dist((1-cdmat1)/2)\nhc <- hclust(dd)\ncdmat1 <-cdmat1[hc$order, hc$order]\ncdmat1\n\n      V3    V7    V8    V4    V6    V5    V1    V2\nV3  1.00  0.44  0.38  0.34 -0.25 -0.81 -0.26 -0.33\nV7  0.44  1.00  0.64  0.03 -0.39 -0.30 -0.75 -0.74\nV8  0.38  0.64  1.00  0.26 -0.08 -0.23 -0.79 -0.92\nV4  0.34  0.03  0.26  1.00  0.40 -0.03 -0.02 -0.15\nV6 -0.25 -0.39 -0.08  0.40  1.00  0.33  0.19  0.17\nV5 -0.81 -0.30 -0.23 -0.03  0.33  1.00  0.15  0.15\nV1 -0.26 -0.75 -0.79 -0.02  0.19  0.15  1.00  0.87\nV2 -0.33 -0.74 -0.92 -0.15  0.17  0.15  0.87  1.00\n\n\nWe then do the same process of adding NA to the diagonal and upper triangle of the matrix, and we can plot:\n\ndiag(cdmat1)<-NA\ncdmat1[upper.tri(cdmat1)]<-NA\ncdlt1.df <- reshape2::melt(cdmat1)\n\nggplot(cdlt1.df, aes(Var1, Var2, fill = value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_gradient2(low = \"blue\", high = \"red\", mid = \"white\",\n                       na.value=\"white\",\n                       midpoint = 0, limit = c(-1,1), space = \"Lab\", \n                       name=\"Pearson's r\")  +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.0)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\"\n  )\n\n\n\n\nOne final step that we might want to do is to add the actual correlations over the top of the colored cells. We can add this with geom_text().\n\nggplot(cdlt1.df, aes(Var1, Var2, fill = value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  geom_text(aes(Var1, Var2, label = value), color = \"black\", size = 3.5) +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_gradient2(low = \"blue\", high = \"red\", mid = \"white\",\n                       na.value=\"white\",\n                       midpoint = 0, limit = c(-1,1), space = \"Lab\", \n                       name=\"Pearson's r\")  +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.0)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\"\n  )"
  },
  {
    "objectID": "heatmaps.html#some-practical-examples",
    "href": "heatmaps.html#some-practical-examples",
    "title": "2  Heatmaps",
    "section": "2.4 Some practical examples",
    "text": "2.4 Some practical examples\nBelow are some well known examples of using geom_tile() to create heatmaps examining trends in the prevalence of diseseas over time. First, we’ll look at the effect of birth month on risk of developing schizophrenia in an Australian cohort. This is using the schz dataset from the season R package:\n\nschz <- read.csv(\"data_raw/schz.csv\")\nhead(schz)\n\n  year month    yrmon NBirths SczBroad  SOI\n1 1930     1 1930.000    1578        8 12.7\n2 1930     2 1930.083    1519       11  7.7\n3 1930     3 1930.167    1630       15  1.8\n4 1930     4 1930.250    1607       12 -3.8\n5 1930     5 1930.333    1566       10  2.1\n6 1930     6 1930.417    1491        8 -5.5\n\nrange(schz$year)\n\n[1] 1930 1971\n\n\nEach row of this dataset contains information on the incidence of schizophrenia for individuals born for each month of the year between 1930-1971. We use the column SczBroad as a measure of schizophrenia risk at each timepoint.\nWe plot the data below using similar code to above. In addition, we are using scale_fill_viridis() from the viridis R package to fill our tiles from a gradient of dark purple (low risk) to bright yellow (high risk). We are using option D, one of four colorblind friendly palettes available in this package. Within theme() most of the lines are making the background panel and borders a dark gray color (gray10), and adjusting the placement of text labels.\n\nlibrary(viridis)\n\nLoading required package: viridisLite\n\nggplot(schz, aes(year, month, fill = SczBroad)) + \n  geom_tile(colour=\"gray10\", linewidth=1.1) + \n  coord_equal() +\n  scale_fill_viridis(option=\"D\",na.value = \"gray10\") +\n  scale_y_continuous(breaks=1:12, labels=month.abb[1:12])+\n  xlab(\"\") + \n  ylab(\"\") +\n  ggtitle(\"Schizophrenia Risk By Birth Month and Year in Australia\") +\n  theme(\n    plot.title = element_text(color=\"white\",hjust=0,vjust=1, size=rel(1.3)),\n    plot.background = element_rect(fill=\"gray10\"),\n    panel.background = element_rect(fill=\"gray10\"),\n    panel.border = element_rect(fill=NA,color=\"gray10\", linewidth = 0.5, linetype=\"solid\"),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    axis.line = element_blank(),\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"white\", size=rel(0.8)),\n    axis.text.y  = element_text(hjust=1, margin = margin(r = -20)),\n    legend.text = element_text(color=\"white\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"gray10\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  )\n\n\n\n\n\nIn the next example, we are looking at the effect of the introduction of vaccinations on the prevalence of measles in the USA. The data are in the diseases.csv dataset. I’ve based this on code from this blog post.\n\ndis <- read.csv(\"data_raw/diseases.csv\")\nhead(dis)\n\n      disease   state year weeks_reporting count population\n1 Hepatitis A Alabama 1966              50   321    3345787\n2 Hepatitis A Alabama 1967              49   291    3364130\n3 Hepatitis A Alabama 1968              52   314    3386068\n4 Hepatitis A Alabama 1969              49   380    3412450\n5 Hepatitis A Alabama 1970              51   413    3444165\n6 Hepatitis A Alabama 1971              51   378    3481798\n\n\nThe dataset contains the total number of cases reported by each state for each disease for each year between 1928-2011. It should be noted that not all states start at the same time point. As can be seen above, Alabama’s Hepatitis reporting starts in 1966. In total, there are data on 7 different diseases, but we’ll just look at measles.\n\ntable(dis$disease)\n\n\nHepatitis A     Measles       Mumps   Pertussis       Polio     Rubella \n       2346        3876        1836        3774        3774        1938 \n   Smallpox \n       1326 \n\n\nTo compare across years and states, we need to make our data more uniform. One way is to look at the number of cases per e.g. 100,000 people. However, this is complicated by the issue that the data don’t come from full years but from different number of weeks within a year. So first, we should get a “per week” count for each disease in each state and then multiply by 52 to get a “per year” count. Then we can divide this by the population of the state in that year and multiply that by 100,000 to get an incidence per 100k people:\n\ndis.sum <- dis %>%\n  group_by(state,disease,year) %>%\n  summarise(peryear = 52*(count/weeks_reporting),\n            per100k = 100000*(peryear/population))\n\nhead(dis.sum)\n\n# A tibble: 6 x 5\n# Groups:   state, disease [1]\n  state   disease      year peryear per100k\n  <chr>   <chr>       <int>   <dbl>   <dbl>\n1 Alabama Hepatitis A  1966    334.    9.98\n2 Alabama Hepatitis A  1967    309.    9.18\n3 Alabama Hepatitis A  1968    314     9.27\n4 Alabama Hepatitis A  1969    403.   11.8 \n5 Alabama Hepatitis A  1970    421.   12.2 \n6 Alabama Hepatitis A  1971    385.   11.1 \n\n\nLet’s focus on Hepatitis A. Before plotting we will do two additional data carpentry steps. We will first reverse the order of the levels of the factor state. The default way to plot these states will be in alphabetical order along the y-axis starting with Alabama closest to the x-axis and Wyoming the furthest away. However, this is annoying to read as we are used to seeing A’s at the top and W’s near the bottom of a list of states. Second, rather than filling the tiles in a continuous gradient, we will create 7 discrete bins of color. These bins are not equivalent in terms of size which does somewhat break the rules of data visualization - i.e. an equal step in color gradient should map to an equal step in value. However, I think it can be justified in this context as we are interested in picking out “very low”, “low”, “medium”, “high”, “very high” number of cases etc. This new variable will be called countfactor.\n\nmeas <- dis.sum %>% filter(disease==\"Measles\") %>%\n        mutate(countfactor=cut(per100k, breaks=c(-1, 0, 1, 10, 100, 500, 1000, max(per100k, na.rm=T)),labels=c(\"0\", \"0-1\", \"1-10\", \"10-100\", \"100-500\", \"500-1000\", \">1000\"))) %>%\n  mutate(countfactor=factor(as.character(countfactor), levels=rev(levels(countfactor))))\n\nmeas$state <- factor(meas$state, levels = rev(unique(meas$state)))\n\nhead(meas)\n\n# A tibble: 6 x 6\n# Groups:   state, disease [1]\n  state   disease  year peryear per100k countfactor\n  <fct>   <chr>   <int>   <dbl>   <dbl> <fct>      \n1 Alabama Measles  1928   8843    341.  100-500    \n2 Alabama Measles  1929   3140.   120.  100-500    \n3 Alabama Measles  1930   4156    157.  100-500    \n4 Alabama Measles  1931   9481.   355.  100-500    \n5 Alabama Measles  1932    342.    12.7 10-100     \n6 Alabama Measles  1933   1769.    65.2 10-100     \n\n\nBelow we plot the data using geom_tile(). We use scale_fill_manual() with 7 colors that we pick ourselves to represent the 7 categories. Inside theme() we control the sizes and colors of text and the background colors. We also use coord_cartesian(), geom_vline() and annotate() to add the black line at 1963 and associate text to indicate when the vaccine was introduced.\n\n# assign text color\ntextcol <- \"grey40\"\n\np <- ggplot(meas, aes(x=year, y=state, fill=countfactor))+\n  geom_tile(color=\"white\", linewidth=0.2)+\n  guides(fill=guide_legend(title=\"Cases per\\n100,000 people\"))+\n  labs(x=\"\", y=\"\", title=\"Incidence of Measles in the US\")+\n  scale_y_discrete(expand=c(0, 0))+\n  scale_x_continuous(expand=c(0, 0), breaks=seq(1930,2000,10))+\n  scale_fill_manual(values=c(\"#d53e4f\", \"#f46d43\", \"#fdae61\", \"#fee08b\", \"#e6f598\", \"#abdda4\", \"#ddf1da\"), na.value = \"grey90\")+\n  coord_cartesian(clip = 'off')+\n  geom_vline(xintercept = 1963, col = \"black\") +\n  theme_grey(base_size=10)+\n  theme(legend.position=\"right\", legend.direction=\"vertical\",\n        legend.title=element_text(colour=textcol),\n        legend.margin=margin(grid::unit(0, \"cm\")),\n        legend.text=element_text(colour=textcol, size=7, face=\"bold\"),\n        legend.key.height=grid::unit(0.8, \"cm\"),\n        legend.key.width=grid::unit(0.2, \"cm\"),\n        axis.text.x=element_text(size=10, color=textcol),\n        axis.text.y=element_text(vjust=0.2, size=rel(0.7), color=textcol),\n        axis.ticks=element_line(size=0.4),\n        plot.background=element_blank(),\n        panel.border=element_blank(),\n        plot.margin=margin(0.7, 0.4, 0.1, 0.2, \"cm\"),\n        plot.title=element_text(colour=textcol, hjust=0, size=14, face=\"bold\")\n      )+ \n  annotate(geom = \"text\", x = 1963.5, y = 52, label = \"Vaccine introduced\", size = 3, hjust = 0)\n\nWarning: The `size` argument of `element_line()` is deprecated as of ggplot2 3.4.0.\ni Please use the `linewidth` argument instead.\n\np\n\n\n\n\n\nRather than manually writing in the colors we want to represent each discrete group, we could also use a palette of 7 colors by using the RColorBrewer package.\n\nlibrary(RColorBrewer)\np + scale_fill_manual(values=rev(brewer.pal(7, \"YlGnBu\")), na.value=\"grey90\")"
  },
  {
    "objectID": "intro.html#introduction-to-ggplot2",
    "href": "intro.html#introduction-to-ggplot2",
    "title": "1  Introduction",
    "section": "1.1 Introduction to ggplot2",
    "text": "1.1 Introduction to ggplot2\nThe first thing to do when we want to make a visualization with ggplot2 is to load the tidyverse:\n\nlibrary(tidyverse)\n\nNext, let’s load in some data. We’ll pick the BlueJays.csv data:\n\ndf <- read_csv(\"data_raw/BlueJays.csv\")\nhead(df)\n\n# A tibble: 6 x 9\n  BirdID     KnownSex BillDepth BillWidth BillLength  Head  Mass Skull   Sex\n  <chr>      <chr>        <dbl>     <dbl>      <dbl> <dbl> <dbl> <dbl> <dbl>\n1 0000-00000 M             8.26      9.21       25.9  56.6  73.3  30.7     1\n2 1142-05901 M             8.54      8.76       25.0  56.4  75.1  31.4     1\n3 1142-05905 M             8.39      8.78       26.1  57.3  70.2  31.2     1\n4 1142-05907 F             7.78      9.3        23.5  53.8  65.5  30.3     0\n5 1142-05909 M             8.71      9.84       25.5  57.3  74.9  31.8     1\n6 1142-05911 F             7.28      9.3        22.2  52.2  63.9  30       0\n\n\nIn the next few steps, we’ll slowly build up a plot using ggplot2. This is not how you would typically write the code. However, it is worth going step by step, just to show you the logic behind the code.\nIf we just run the function ggplot() notice that all we get is a blank gray canvas. R knows that we want to make a plot, but it has no idea what type of plot or with what data - so it just throws up the canvas:\n\nggplot()  \n\n\n\n\nNow, if we add the dataset to ggplot(), it still only gives us the blank canvas. It now knows we want to make a graph from the dataset called df but doesn’t plot anything yet as we didn’t tell it what to plot:\n\nggplot(df)   \n\n\n\n\nFor R to ‘know’ what you are trying to plot, you need to use aes(). You put that most of the time inside ggplot() after your dataframe name. (There are exceptions to this, but let’s not worry about that yet). Inside the aes() we’ll put what columns contain our data for the x and y axes. We may also refer to other columns inside aes() if we wish to modify the color or shape or something else about our data based on the values in some column.\nFor our first example, let’s make a scatterplot of body mass against head size of these Blue Jays. If you look at the original dataset, you’ll notice that both the Mass and Head columns contain continuous numeric data (i.e. they are numbers).\nIn the code below, we are telling aes() to plot the Mass data on the x-axis and to plot the Head data on the y-axis.\n\nggplot(df, aes(x=Mass, y=Head) )   \n\n\n\n\nSomething did change this time. We get a plot with labels on the x- and y-axes. It recognizes that we wish to plot Mass and Head data. It even knows the range of our data on each axis. For instance, it knows that the Mass data lies somewhere between 55 and 85. However, we haven’t yet told it precisely what type of plot we want to make (it doesn’t just assume that we wanted to make a scatterplot - it can’t read our minds).\nSo our next step is to tell it to make a scatterplot by adding points to the graph. We tell ggplot() what we are adding to the chart by using different geoms. For a scatterplot, the geom we require is geom_point() - that means add datapoints. It is hard to remember all the different geoms, but you can just look them up.\nHere is how we add datapoints to our graph with + geom_point().\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point()\n\n\n\n\nThat is our first ggplot graph! It looks pretty good. The amazing thing about ggplot is almost everything you are looking at on that graph can be customized to your preferred design choice. We’ll discuss several of these customizations throughout this chapter. First, let’s talk about changing the color of the datapoints. Inside of geom_point() we can change the color of all the points like this:\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point(color=\"red\")\n\n\n\n\nThis made the points red. Just make sure you put a recognized color name (you can look them up here) or a recognized hex code. Notice though that color name must be put inside of quotes.\nWhat if we want to color the points based on another variable? For example, instead of having all of our data points be red, say we want them to be colored based on whether the birds or male or female? The column that has the information about whether the birds are male or female is KnownSex. Because we are basing the color on a column, we put that information inside of aes() with color = KnownSex. We don’t put that inside geom_point(). This code looks like this:\n\nggplot(df, aes(x=Mass, y=Head, color = KnownSex) ) + geom_point() \n\n\n\n\n\n\n1.1.1 Assigning plots\nWhen we make plots, our code can start to get quite long as we make more and more additions or changes to the plot. One very useful thing to know is that we can assign our plot to be an object, just as we would with a vector or a dataframe. For instance, let’s remake the plot above, but this time we’ll assign it the name p. We do that using p <-.\n\np <- ggplot(df, aes(x=Mass, y=Head, color = KnownSex) ) + geom_point() \n\nNow, whenever we type and run p we will get our plot. e.g.\n\np\n\n\n\n\n\n\n\n1.1.2 Titles and Axes Titles\nThe advantage of assigning our plots to a short name, is that we can add things with less code. In R, if we wish to add a title to a plot, we do this with + ggtitle(). So, here is how we add a title to our above plot:\n\np + ggtitle(\"Our first scatterplot\")\n\n\n\n\nThe above plot is basically the same as writing:\n\nggplot(df, aes(x=Mass, y=Head, color = KnownSex) ) + \n  geom_point() +\n  ggtitle(\"Our First Scatterplot\")\n\n\n\n\nYou’ll notice that we are chaining together commands with the +. This is similar to how we chain together commands with the %>% when doing data carpentry. ggplot() instead chains with the +. Again, be careful not to start a row with a +, and you must end a row with a + unless it’s the very last row.\nTo change the title of the x-axis or the y-axis, we use xlab and ylab respectively. We can do it like this:\n\np + xlab(\"Body Mass (g)\") + ylab(\"Head Size (mm)\")\n\n\n\n\n\n\n\n1.1.3 Colors, Shapes and Sizes\nR recognizes many default color names. These can be found at either of these places:\n Color names 1  Color names 2  Or, you can use a hex code \nHere we use the color dodgerblue to change all the points to that color:\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point(color=\"dodgerblue\")\n\n\n\n\nHere we change the points to the color #ababcc using a hexcode - note that hexcodes need to have # in front of them:\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point(color=\"#ababcc\")\n\n\n\n\nYou can also change the shape of the points you plot with geom_point(pch = ). You need to insert the appropriate number according to this guide:\n\nFor example, to have dodgerblue asterisks, we add pch = 8, separating the color and shape commands by a comma:\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point(color=\"dodgerblue\", pch = 8)\n\n\n\n\nFinally, we can change the size of our datapoints (or other shape we choose), using size =:\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point(color=\"purple\", size=2)\n\n\n\n\n\n\n\n1.1.4 Themes\nDefault Themes\nYou may have noticed that every plot we have made so far has the same gray background with faint white gridlines. This is the default setting for the look of ggplot() graphs. There are several other themes that are available to us that change the overall appearance of our plots. Some of these are listed below:\ntheme_bw() a variation on theme_grey() that uses a white background and thin grey grid lines.\ntheme_linedraw() A theme with only black lines of various widths on white backgrounds, reminiscent of a line drawing.\ntheme_light() similar to theme_linedraw() but with light grey lines and axes, to direct more attention towards the data.\ntheme_dark() the dark cousin of theme_light(), with similar line sizes but a dark background. Useful to make thin colored lines pop out.\ntheme_minimal() A minimalistic theme with no background annotations.\ntheme_classic() A classic-looking theme, with x and y axis lines and no gridlines.\ntheme_void() A completely empty theme\nLet’s shows a couple of these different themes. The theme that we use the most in this course is theme_classic(). This is how you would apply this theme to your plot:\n\nggplot(df, aes(x=Mass, y=Head) ) + \n  geom_point() +\n  theme_classic()\n\n\n\n\nIt creates a very sleek simple graph. The downside to this type of graph is that it does get rid of the gridlines which can be helpful sometimes.\nAnother theme that we use often is theme_minimal(). Here is how we would add this:\n\nggplot(df, aes(x=Mass, y=Head) ) + \n  geom_point() +\n  theme_minimal()\n\n\n\n\nThis theme is also simplistic, but has gridlines too.\n\nCustom themes\nRather than changing many different aspects of the graph at once, we can change individual things one by one with theme(). We don’t propose to cover this in more detail in this book - for more information about themes look here - however, here is one quick example.\nLet’s say we wanted to make the panel background light blue instead of gray. We could do it like this:\n\nggplot(df, aes(x=Mass, y=Head) ) + \n  geom_point() +\n  theme(panel.background = element_rect(fill = \"lightblue\"))\n\n\n\n\nAgain, this can get quite complicated - so stick with the default themes if you want to change your plots up a bit, or go to other help guides or later chapters in this book for more fine detail on customization."
  },
  {
    "objectID": "scatterplots.html",
    "href": "scatterplots.html",
    "title": "3  Scatterplots",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  }
]