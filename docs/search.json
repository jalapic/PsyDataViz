[
  {
    "objectID": "labelsig.html#adding-stars-to-plots",
    "href": "labelsig.html#adding-stars-to-plots",
    "title": "9  Labeling Significance",
    "section": "9.1 Adding stars to plots",
    "text": "9.1 Adding stars to plots\n\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "labelsig.html#adding-p-values-to-plots",
    "href": "labelsig.html#adding-p-values-to-plots",
    "title": "9  Labeling Significance",
    "section": "9.2 Adding p-values to plots",
    "text": "9.2 Adding p-values to plots"
  },
  {
    "objectID": "labelsig.html#adding-tukeys-significance-letters",
    "href": "labelsig.html#adding-tukeys-significance-letters",
    "title": "10  Labeling Significance",
    "section": "10.2 Adding Tukey’s Significance Letters",
    "text": "10.2 Adding Tukey’s Significance Letters\nRather than denoting pairwise comparisons with stars or p-values, I prefer to use letter notation. Letters that are the same between two groups indicate no significant differences between those groups. Letters that differ between two groups indicate that those groups have significant differencess.\n\nOne-Way ANOVA example\nLet’s create some random data. We’ll make a dataframe of six groups.\n\nset.seed(10)\ndf <- data.frame(\n  value = c(rnorm(n = 10, mean = 10, sd = 1.8),\n            rnorm(n = 12, mean = 11, sd = 1.0),\n            rnorm(n = 14, mean = 13, sd = 1.1),\n            rnorm(n = 16, mean = 15, sd = 1.2),\n            rnorm(n = 12, mean = 14, sd = 2.2),\n            rnorm(n = 10, mean = 10, sd = 1.0)),\n  categ = c(rep(\"A\",10), rep(\"B\",12), rep(\"C\",14), \n          rep(\"D\",16), rep(\"E\",12), rep(\"F\",10)\n          )\n)\n\nhead(df)\n\n      value categ\n1 10.033743     A\n2  9.668345     A\n3  7.531605     A\n4  8.921498     A\n5 10.530181     A\n6 10.701630     A\n\n\nWe can plot the basic boxplot of these data like this:\n\nggplot(df, aes(x=categ, y=value)) +\n  geom_boxplot() +\n  theme_classic()\n\n\n\n\nTo compare significance differences between groups, we could run Tukey post-hoc tests using Honestly Signficant Differences. This is done using the TukeyHSD() function in base R, but using the HSD.test() function from the agricolae R package, we can get the letter notation we need directly.\nThis code runs the post hoc test and the groups part of it gives us the letter notations we need:\n\nlibrary(agricolae)\n\nhsd <- HSD.test(aov(value ~ categ, data=df), \"categ\", group=T)\nhsd\n\n$statistics\n   MSerror Df     Mean       CV\n  1.624327 68 12.19191 10.45357\n\n$parameters\n   test name.t ntr StudentizedRange alpha\n  Tukey  categ   6         4.147238  0.05\n\n$means\n      value       std  r       Min      Max       Q25       Q50       Q75\nA  9.116818 1.2598083 10  7.071989 10.70163  8.099472  9.441861  9.942394\nB 11.076193 0.9758832 12  8.814713 12.10178 10.672247 11.286163 11.798216\nC 12.218867 0.9310972 14 10.669033 14.06542 11.513617 12.250668 12.846258\nD 14.710048 0.8877416 16 12.889096 16.30386 14.161383 14.604540 15.317899\nE 14.346442 2.2162032 12 11.277292 18.70309 12.477597 14.694213 15.311768\nF  9.953696 0.9761422 10  8.569573 11.21613  9.093364 10.081209 10.692454\n\n$comparison\nNULL\n\n$groups\n      value groups\nD 14.710048      a\nE 14.346442      a\nC 12.218867      b\nB 11.076193     bc\nF  9.953696     cd\nA  9.116818      d\n\nattr(,\"class\")\n[1] \"group\"\n\n\nTo add these letters on to the plot, we need to decide where to put them. The x coordinate will be the mid point of each category (which can just be the name of the group), and the y coordinate will be above the maximum value of that group. But note that the groups in the summary output are reorganized from highest median value to lowest. I find it easiest to add these to our summary output in the appropriate order.\n\ndf.sum <- df %>% \n  group_by(categ) %>% \n  summarize(maxval = max(value), \n            med = median(value),\n            uq = quantile(value, .75)) %>% \n  arrange(-med)\n\ndf.sum$letters <- hsd$groups$groups\n\ndf.sum\n\n# A tibble: 6 x 5\n  categ maxval   med    uq letters\n  <chr>  <dbl> <dbl> <dbl> <chr>  \n1 E       18.7 14.7  15.3  a      \n2 D       16.3 14.6  15.3  a      \n3 C       14.1 12.3  12.8  b      \n4 B       12.1 11.3  11.8  bc     \n5 F       11.2 10.1  10.7  cd     \n6 A       10.7  9.44  9.94 d      \n\n\nThis code plots the letters above the boxplots at a y coordinate 0.2 higher than the max value.\n\nggplot(df,aes(x=categ,y=value))+\n  geom_boxplot()+\n  geom_text(data=df.sum,\n            aes(x=categ,y=0.2+maxval,\n                label=letters)) +\n  theme_classic() +\n  xlab(\"Category\")\n\n\n\n\nIn the above plot, we can see that Group B is not significantly different from Group C or Group F (because both share the b and c letter, but is significantly different from the other groups. Groups D and E are not significantly different from each other (they both have an a) but are significantly different from all other groups.\nWe should reorder the plot though to make it more readable:\n\nggplot(df,aes(x=reorder(categ,-value,median),y=value))+\n  geom_boxplot()+\n  geom_text(data=df.sum,\n            aes(x=categ,y=0.2+maxval,\n                label=letters)) +\n  theme_classic() +\n  xlab(\"Category\")\n\n\n\n\nWe can nudge the letters up a bit using vjust=0:\n\nggplot(df,aes(x=reorder(categ,-value,median),y=value))+\n  geom_boxplot()+\n  geom_text(data=df.sum,\n            aes(x=categ,y=0.2+maxval,\n                label=letters), vjust=0) +\n  theme_classic() +\n  xlab(\"Category\")\n\n\n\n\nAlternatively, you may wish to plot the letters to the side of the upper quartile. I don’t like this very much, but it’s an option. I also make the letters bold in this example using fontface=\"bold\".\n\nggplot(df,aes(x=reorder(categ,-value,median),y=value))+\n  geom_boxplot()+\n  geom_text(data=df.sum,\n            aes(x=categ,y=uq,\n                label=letters,\n                hjust = -1, \n                vjust = -0.8, \n                fontface = \"bold\")) +\n  theme_classic() +\n  xlab(\"Category\")\n\n\n\n\nJust for fun, here I’m including aes(fill = factor(..middle..))) and scale_fill_brewer(palette = \"Reds\") to make the colors of the boxplots a shade of red that is equivalent to their categorical position.\n\nggplot(df,aes(x=reorder(categ,-value,median),y=value))+\n  geom_boxplot(aes(fill = factor(..middle..)))+\n  geom_text(data=df.sum,\n            aes(x=categ,y=0.2+maxval,\n                label=letters), vjust=0) +\n  theme_classic() +\n  xlab(\"Category\") +\n  scale_fill_brewer(palette = \"Reds\") +\n  theme(legend.position = 'none')\n\n\n\n\nThis approach using geom_text() to add letters to a plot can be modified for any statistical test."
  },
  {
    "objectID": "labelsig.html#adding-stars-and-p-values-to-plots",
    "href": "labelsig.html#adding-stars-and-p-values-to-plots",
    "title": "10  Labeling Significance",
    "section": "10.1 Adding stars and p-values to plots",
    "text": "10.1 Adding stars and p-values to plots\nProbably the simplest way to add stars and p-values to plots is by using the ggsignif package. This adds an extra layer to each ggplot chart containing the stars.\nHere is some example data with two groups:\n\nset.seed(100)\n\ndf <- data.frame(\n  values = c(rnorm(n=10,mean=4, sd = 0.5), \n             rnorm(n=12,mean=3.4, sd = 0.4)),\n  subject = c(rep(\"Control\",10), rep(\"Treatment\",12))\n)\nhead(df)\n\n    values subject\n1 3.748904 Control\n2 4.065766 Control\n3 3.960541 Control\n4 4.443392 Control\n5 4.058486 Control\n6 4.159315 Control\n\n\nIf we run a simple t-test on these data, we can see that the p-value for this test is 0.0009517.\n\nt.test(data=df, values ~ subject)\n\n\n    Welch Two Sample t-test\n\ndata:  values by subject\nt = 3.8715, df = 19.975, p-value = 0.0009517\nalternative hypothesis: true difference in means between group Control and group Treatment is not equal to 0\n95 percent confidence interval:\n 0.2316228 0.7728943\nsample estimates:\n  mean in group Control mean in group Treatment \n               3.991021                3.488763 \n\n\nTo make a boxplot with stars, we just add geom_signif() to our plot, but we need to add comparisons = list(c(\"Control\",\"Treatment\")) to tell it which groups we wish to compare.\n\nlibrary(tidyverse)\nlibrary(ggsignif)\n\nggplot(df, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(comparisons = list(c(\"Control\",\"Treatment\")))\n\n\n\n\nHowever, what you may notice is that this p-value is not the same as the one we got from the t-test above. This is because the default test it runs to compare groups is the wilcoxon rank sum test (a non-parametric equivalent to the independent’ t-test that compares medians between independent groups).\n\nggplot(df, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(test = \"wilcox.test\", \n              comparisons = list(c(\"Control\",\"Treatment\")))\n\n\n\n\nTo get the p-value for the t-test we need to assign the test to be the t.test:\n\nggplot(df, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(test = \"t.test\", \n              comparisons = list(c(\"Control\",\"Treatment\")))\n\n\n\n\nIt’s also possible to round numbers to desired decimal places by adding a function within the parameter map_signif_level. Here, I round the p-value to 3 decimal places with round().\n\nggplot(df, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(test = \"t.test\", \n              comparisons = list(c(\"Control\",\"Treatment\")),\n              map_signif_level = function(p) paste(\"p =\",round(p,3)))\n\n\n\n\nWithin this same function, we can actually also annotate text. Here I add “p =” to the beginning of the p-value output on the plot.\n\nggplot(df, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(test = \"t.test\", \n              comparisons = list(c(\"Control\",\"Treatment\")),\n              map_signif_level = function(p) paste(\"p =\",round(p,3)))\n\n\n\n\nThere are several other parameters within geom_signif() that can be tweaked to adjust the font type and position. This is using textsize to adjust the text size.\n\nggplot(df, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(test = \"t.test\", \n              comparisons = list(c(\"Control\",\"Treatment\")),\n              textsize = 5)\n\n\n\n\n\nAdding stars to plots\nTo switch from adding p-values to stars we just need to add map_signif_level = T\n\nggplot(df, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(test = \"t.test\", \n              comparisons = list(c(\"Control\",\"Treatment\")),\n              map_signif_level = T,\n              textsize = 5) +\n  theme_classic()\n\n\n\n\n\nWhat if not significant ?\nIn the data below, we can see that there is no significant difference between our two groups in means.\n\nset.seed(100)\n\nddf <- data.frame(\n  values = c(rnorm(n=10,mean=7.1, sd = 0.5), \n             rnorm(n=12,mean=7.2, sd = 0.4)),\n  subject = c(rep(\"Control\",10), rep(\"Treatment\",12))\n)\n\nt.test(data=ddf, values ~ subject)\n\n\n    Welch Two Sample t-test\n\ndata:  values by subject\nt = -1.5242, df = 19.975, p-value = 0.1431\nalternative hypothesis: true difference in means between group Control and group Treatment is not equal to 0\n95 percent confidence interval:\n -0.46837715  0.07289431\nsample estimates:\n  mean in group Control mean in group Treatment \n               7.091021                7.288763 \n\n\nWhat does this look like if we use geom_signif() to plot ?\n\nggplot(ddf, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(test = \"t.test\", \n              comparisons = list(c(\"Control\",\"Treatment\")),\n              textsize = 5)\n\n\n\n\nThe default plot will add the p-value. If we add map_signif_level = T to plot ‘stars’, we get the following:\n\nggplot(ddf, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(test = \"t.test\", \n              comparisons = list(c(\"Control\",\"Treatment\")),\n              map_signif_level = T,\n              textsize = 5)\n\n\n\n\nFor some reason to me, the dot after NS I find quite irritating. However, this can be all overridden by applying direct annotations (see below).\n\nPaired Data\nThe above examples are all two-tailed independent tests. However, it is possible to apply geom_signif() to one-tailed or paired tests. Let’s create some paired data:\n\nset.seed(103)\n\npdf <- data.frame(\n  subj = letters[1:12],\n  before = runif(12),\n  after = runif(12)\n)\n\npdf\n\n   subj     before     after\n1     a 0.21594161 0.7955919\n2     b 0.06316809 0.8247906\n3     c 0.52182676 0.8830082\n4     d 0.50361726 0.1303339\n5     e 0.12048608 0.1375370\n6     f 0.08727517 0.2851473\n7     g 0.43356197 0.3537884\n8     h 0.19308082 0.3349347\n9     i 0.03108849 0.1756115\n10    j 0.31385192 0.5507040\n11    k 0.45206720 0.5132493\n12    l 0.28632367 0.5776094\n\n\nIf we run a paired t-test on these data we can see a significant difference in means of p=0.04:\n\nt.test(pdf$before, pdf$after, paired=T)\n\n\n    Paired t-test\n\ndata:  pdf$before and pdf$after\nt = -2.2853, df = 11, p-value = 0.04313\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -0.382805290 -0.007197583\nsample estimates:\nmean of the differences \n             -0.1950014 \n\n\nTo make the basic boxplot, we need to turn the data into long form. We also factor the new time column as annoyingly the word ‘after’ is alphabetically earlier than ‘before’ and we want them plotted the opposite way around on the x-axis:\n\npdf.long <- pdf %>% pivot_longer(cols=2:3, names_to = \"time\")\npdf.long$time <- factor(pdf.long$time, levels=c(\"before\",\"after\"))\npdf.long\n\n# A tibble: 24 x 3\n   subj  time    value\n   <chr> <fct>   <dbl>\n 1 a     before 0.216 \n 2 a     after  0.796 \n 3 b     before 0.0632\n 4 b     after  0.825 \n 5 c     before 0.522 \n 6 c     after  0.883 \n 7 d     before 0.504 \n 8 d     after  0.130 \n 9 e     before 0.120 \n10 e     after  0.138 \n# ... with 14 more rows\n\n\nHere is the basic boxplot. I’m using the theme_pubclean() from the ggpubr package:\n\nlibrary(ggpubr)\n\np0 <- ggplot(pdf.long, aes(x=time, y=value)) +\n  geom_boxplot(fill='dodgerblue', alpha=.3) +\n  theme_pubclean() +\n  xlab(\"Time\") +\n  ylab(\"Value\")\n\np0\n\n\n\n\nTo add the p-values for paired data we need to add in extra information related to the test in the test.args() argument. Make sure that the parameters are in a list.\n\np0  +\n    stat_signif(comparisons=list(c(\"before\", \"after\")),\n                test=\"t.test\", \n                test.args=list(alternative = \"two.sided\", \n                               var.equal = FALSE, \n                               paired=T))\n\n\n\n\n… in the above example, we perform a two-tailed paired t-test not assuming equal variances. If we wished to perform a one-tailed t-test, testing if the ‘before’ mean is significantly lower than the ‘after’ group, we can change that in the test.args parameter. Recall, that for a one-sided t-test, the p-value will be half the value of a two-tailed t-test:\n\nt.test(pdf$before, pdf$after, paired=T, alternative = \"less\")\n\n\n    Paired t-test\n\ndata:  pdf$before and pdf$after\nt = -2.2853, df = 11, p-value = 0.02156\nalternative hypothesis: true difference in means is less than 0\n95 percent confidence interval:\n        -Inf -0.04176365\nsample estimates:\nmean of the differences \n             -0.1950014 \n\n\n… and the plot would look as follows:\n\np0  +\n    stat_signif(comparisons=list(c(\"before\", \"after\")),\n                test=\"t.test\", \n                test.args=list(alternative = \"less\", \n                               var.equal = FALSE, \n                               paired=T))\n\n\n\n\nAs before, we can add stars using the map_signif_level = T argument. I also increase the font size using textsize = 7 and reduce the sides of the horizontal bar with tip_length=0. vjust=0.5 pushes the asterisk closer to the horizontal line.\n\n p0  +\n    stat_signif(comparisons=list(c(\"before\", \"after\")),\n                test=\"t.test\", \n                map_signif_level = T,\n                textsize = 7,\n                tip_length = 0,\n                vjust=0.5,\n                test.args=list(alternative = \"less\", \n                               var.equal = FALSE, \n                               paired=T))\n\n\n\n\n\n\n10.1.1 Adding Significance to Multiple Groups\nAdding stars or p-values to plots can also be done when there are more than two groups. Obviously, the more groups that exist, the more potential pairwise comparisons there are. It should be noted that by default, geom_signif() will run pairwise wilcoxon ranked sum tests or independent t-tests on each of hte pairwise comparisons. This may be what you wish to report, but more often we are likely to want to report posthoc comparisons or such like. I personally would still advocate for using the Tukey Significance Letters as shown below. It’s also possible to directly annotate plots ourselves with geom_signif() - see below. But first, let’s look at how it does add these pairwise t-tests p-values to plots.\nHere is some example data with three groups:\n\nset.seed(10)\n\nmdf <- data.frame(\n  values = c(rnorm(n=10,mean=3.8, sd = 0.5), \n             rnorm(n=12,mean=3.1, sd = 0.4),\n             rnorm(n=15, mean=3.5, sd=0.3)),\n  grp = c(rep(\"A\",10), rep(\"B\",12), rep(\"C\",15))\n)\nhead(mdf)\n\n    values grp\n1 3.809373   A\n2 3.707874   A\n3 3.114335   A\n4 3.500416   A\n5 3.947273   A\n6 3.994897   A\n\n\nIf we run a one way ANOVA, with posthoc tests, we can see how the groups differ:\n\nfit <- aov(data = mdf, values ~ grp)\n\nsummary(fit)\n\n            Df Sum Sq Mean Sq F value Pr(>F)  \ngrp          2  0.983  0.4917   4.503 0.0184 *\nResiduals   34  3.713  0.1092                 \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nTukeyHSD(fit)\n\n  Tukey multiple comparisons of means\n    95% family-wise confidence level\n\nFit: aov(formula = values ~ grp, data = mdf)\n\n$grp\n          diff        lwr         upr     p adj\nB-A -0.4241943 -0.7709278 -0.07746088 0.0136482\nC-A -0.2462637 -0.5768611  0.08433364 0.1766410\nC-B  0.1779306 -0.1357016  0.49156280 0.3571951\n\n\nThis might be how we would plot the data in a basic boxplot:\n\npb <- ggplot(mdf, aes(x=grp, y=values, fill=grp)) +\n  geom_boxplot() +\n  scale_fill_manual(values=c(\"#cceeee\", \"#bbebbe\", \"#dddeee\")) +\n  theme_pubclean() +\n  theme(legend.position = 'none') +\n  xlab(\"\") +\n  ylab(\"Values\")\n\npb\n\n\n\n\nWe can add our stars and NS in the same way as before. We just need to put all the relevant comparisons we wish to make in the list, and add step_increase= to make sure that the lines do not overlap each other. Note that the order in which the horizontal lines are added onto the plot are dictated by the order in which they occur in the list.\n\npb +\n  geom_signif(comparisons = list(c(\"A\", \"B\"),\n                                 c(\"A\", \"C\"),\n                                 c(\"B\", \"C\")),\n              test = \"t.test\", \n              step_increase = 0.075,\n              map_signif_level = TRUE, \n              tip_length = 0)\n\n\n\n\nThis way of plotting stars and significance levels is completely functional, however, another options would be to manually add them (see section below). One major advantage of this is that we can plot posthoc tests rather than running t-tests on each comparison.\n\n\n\n10.1.2 Adding stars or p-values manually\nWe can compute the individual p-values separately and then use the annotations parameter to draw them. The code below grabs the p-values for Tukey HSD posthoc comparions between each of the groups from the previous example.\n\npvals <- round(TukeyHSD(fit)$grp[,4],2)\npvals\n\n B-A  C-A  C-B \n0.01 0.18 0.36 \n\n\nWe can add these manually to our plot. The y_position dictates how high up the y-axis each lines goes. The xmin and xmax dictate the start and end point of each horizontal line. Group A starts at 1 on the x-axis, Group B at 2 and Group C at 3.\n\npb + \n  geom_signif(y_position = c(4.1,4.25,4.4), \n              xmin = c(1,1,2), \n              xmax = c(2,3,3), \n              annotation = pvals,\n              tip_length = 0) \n\n\n\n\nInstead of passing a vector of annotations that is an object, you can write your own vector like this:\n\npb + \n  geom_signif(y_position = c(4.1,4.25,4.4), \n              xmin = c(1,1,2), \n              xmax = c(2,3,3), \n              annotation = c(\"p < .05\", \"NS\", \"NS\"),\n              tip_length = 0) \n\n\n\n\nIf you didn’t want to mess around with xmin and xmax, you can pass a list of comparisons. You just need to then supply the annotations and the y_position. Here, I switched up the order in which the lines were drawn:\n\npb +\n  geom_signif(comparisons = list(c(\"A\",\"B\"),\n                                 c(\"B\",\"C\"),\n                                 c(\"A\",\"C\")), \n              y_position = c(4.1,4.25,4.4),\n             annotation = c(\"p < .05\", \"NS\", \"NS\"),\n              tip_length = 0.01)\n\n\n\n\n\n\n\n10.1.3 Adding Significance to Bar graphs\nAdding stars or p-values to bar graphs is the same as with boxplots. We add layers to the plot using geom_signif(). If we produce the bar graph with geom_col() then we are plotting summary information without the underlying raw data, we will need to add information to the graph using annotations.\n\ndat <- data.frame(Group = c(\"G1\",\"G1\",\"G2\",\"G2\"),\n                   Subject = c(\"A\",\"B\",\"A\",\"B\"),\n                   Value = c(3,2,12,17))\n\ndat\n\n  Group Subject Value\n1    G1       A     3\n2    G1       B     2\n3    G2       A    12\n4    G2       B    17\n\n\nThis dataframe just has four rows, with the Value column showing the height of the bar to be plotted. We can plot a bar graph using geom_col() and we include position='dodge' to make a side-by-side bar chart as opposed to a stacked bar chart. I’ve also used the theme_pubclean() from the ggpubr package and set some custom fills. I assign this plot to the object p so we can modify other layers without rewriting the code:\n\np <- ggplot(dat, aes(Group,Value,fill=Subject))+\n  geom_col(position = 'dodge') +\n  theme_pubclean() +\n  scale_fill_manual(values=c(\"#ababde\",\"#123abc\"))\n\np\n\n\n\n\nTo add either stars or p-values we just use geom_signif(). First, we’ll annotate the A vs B comparisons. We dictate the position of the horizontal line we add with xmin and xmax and y_position. The mid-point between the light and dark blue bars are at x=1 for G1 and x=2 for G2. This helps us determine what values to use for xmin and xmax. The values of y_position are picked based on the values of A & B in each group. Using tip_length=0 sets there to be no lines coming down from the edges of the horizontal black lines we add. If we wish to have some of those downward lines, then a really small value like 0.03 would probably be best.\n\np + \n  geom_signif(y_position = c(4,18), \n              xmin = c(0.8,1.8), \n              xmax = c(1.2,2.2), \n              annotation = c(\"NS\",\"**\"),\n              tip_length = 0)\n\n\n\n\nTo add the horizontal black line between our two groups (G1 and G2), we add another geom_signif() layer. Because this is a comparison between the levels of our groups in our original dataframe, we use the comparisons= parameter. That will add the x positions - although it is still possible to do these manually should we wish. We can also set the y_position() ourselves.\n\np + \n  geom_signif(y_position = c(4,18), \n              xmin = c(0.8,1.8), \n              xmax = c(1.2,2.2), \n              annotation = c(\"NS\",\"**\"),\n              tip_length = 0) +\n  geom_signif(comparisons = list(c(\"G1\",\"G2\")), \n              y_position = 21,\n              annotation = \"p < 0.001\",\n              tip_length = 0) \n\n\n\n\nClearly, you wouldn’t mix numerical p-values with stars like this on an actual figure, but for the purpose of illustration, you can write anything you like inside annotation = and it will appear on the plot.\n\n\n\n10.1.4 Adding significance to dynamite plots\nI don’t like dynamite plots. However, it is possible to add these significance annotations to them. It is done in the identical way to the bar charts above. Note how when we add extra annotations, the plot margins automatically adjust, so we don’t need to worry about rescaling the axes.\nLet’s use some example data:\n\ndat1 <- data.frame(Group = c(\"G1\",\"G1\",\"G2\",\"G2\"),\n                   Subject = c(\"A\",\"B\",\"A\",\"B\"),\n                   Mean = c(1.1, 1.4, 2.5, 2.0),\n                   Serr = c(0.1, 0.2, 0.35, 0.3))\n\ndat1\n\n  Group Subject Mean Serr\n1    G1       A  1.1 0.10\n2    G1       B  1.4 0.20\n3    G2       A  2.5 0.35\n4    G2       B  2.0 0.30\n\n\nHere we plot these data in the same manner as with the bar charts above, but we add error bars manually using geom_errorbar() based on the summary data in the dataframe. Note that with these stacked bar charts, we also need to add position=position_dodge(.9) to ensure the error bars stay in the middle of the respective bars.\n\np1 <- ggplot(dat1, aes(x=Group, y=Mean, fill=Subject)) + \n  geom_col(color=\"black\", position=position_dodge()) +\n  scale_fill_manual(values=c('#999999','#E69F00')) +\n  theme_pubclean() +\n  geom_errorbar(aes(ymin = Mean-Serr, \n                    ymax = Mean+Serr), \n                  width=.2,\n                  position=position_dodge(.9)) \n\np1\n\n\n\n\nUsing geom_signif() we manually add the stars and other annotations:\n\np1 + \n  geom_signif(y_position = c(1.75,3.0), \n              xmin = c(0.8,1.8), \n              xmax = c(1.2,2.2), \n              annotation = c(\"*\",\"NS\"),\n              tip_length = 0) \n\n\n\n\n\n\n\n10.1.5 Adding significance to other plots\nWe can add significance labels to other plots that show raw or summary data. Here are two examples - dot plots and strip plots. We’ll use a data set looking at viral load values in subjects under different exposures risks (condition) who are in different treatment groups group.\nLoad in the data:\n\ndf <- read.csv(\"data_raw/viralload.csv\")\nhead(df)\n\n     values subjs group condition\n1  7.824307    s1     B       low\n2  3.921456    s2     B       low\n3 10.001437    s3     C       low\n4  4.035973    s4     A       low\n5  8.886767    s5     B       low\n6  3.003866    s6     B       low\n\n\nDot plots\nTo plot dot plots we need to calculate the summary statistics we wish to plot. Here, I determine the mean and standard deviation of each condition by group. I also refactor the condition variable so that in the plot it will appear in the order high, medium,low.\n\ndf.sum <- df %>%\n  group_by(group, condition) %>%\n  summarise(\n    sd = sd(values),\n    mean = mean(values)\n  )\ndf.sum$condition <- factor(df.sum$condition, levels=c(\"low\",\"medium\",\"high\"))\n\ndf.sum\n\n# A tibble: 12 x 4\n# Groups:   group [4]\n   group condition    sd  mean\n   <chr> <fct>     <dbl> <dbl>\n 1 A     high       6.12 24.4 \n 2 A     low        3.46  6.83\n 3 A     medium     5.00  9.72\n 4 B     high       5.11 16.3 \n 5 B     low        4.48  9.17\n 6 B     medium     6.53  9.65\n 7 C     high       4.92 10.2 \n 8 C     low        3.36  6.46\n 9 C     medium     4.73 13.1 \n10 D     high       9.82 13.2 \n11 D     low        3.90  9.74\n12 D     medium     4.87 11.1 \n\n\nThis is the plot with annotated error bars. Essentially, in geom_signif() we just determine the x and y locations of each thing we wish to plot. Here, I am plotting significance stars to indicate where each condition is significantly different from each other condition in posthoc tests.\n\nggplot(df.sum, aes(x = group, y = mean, color=condition)) +\n  geom_errorbar(\n    aes(ymin = mean-sd, \n        ymax = mean+sd),\n    position = position_dodge(0.3), \n    width = 0.2,\n    linewidth = 1\n  ) +\n  geom_point(size=2,\n             position = position_dodge(0.3)) +\n  scale_color_manual(values = c(\"#bacddd\", \"#E7B800\",\"#bb3300\")) +\n  theme_classic() +\n  coord_flip() +\n  ylab(\"Group\") +\n  xlab(\"Viral Load\") +\n  geom_signif(xmin = c(1,1.1,2,2.1,3),\n              xmax = c(1.1,0.9,2.1,1.9,2.9),\n              y_position = c(32,33.5,23,24.5,19.5),\n              annotation = c(\"***\", \"***\",\"*\", \"**\",\"**\"),\n              tip_length = 0.01,\n              color='black',\n              vjust=0.6)\n\n\n\n\n\nStrip plots\nHere’s another example. This time, we’ll plot the raw data only from group A above in the form of a strip plot. Then we add the stars with geom_signif. We can use comparisons= to do the hard work of determining the x-axis.\n\ndfa <- df %>% filter(group==\"A\")\ndfa$condition <- factor(dfa$condition, levels = c(\"low\",\"medium\",\"high\"))\n\nggplot(dfa, \n       aes(x = condition, y = values, color=condition)) +\ngeom_jitter(width=.085, alpha=.8, size=2) +\n  scale_color_manual(values = c(\"#bacddd\", \"#E7B800\",\"#bb3300\")) +\n  theme_classic() +\n  ylab(\"Viral Load\") +\n  xlab(\"Condition\") +\n  geom_signif(comparisons = list(c(\"low\",\"medium\"),\n                                 c(\"medium\",\"high\"),\n                                 c(\"low\",\"high\")),\n              y_position = c(32,33.5,35),\n              annotation = c(\"NS\",\"***\", \"***\"),\n              tip_length = 0,\n              color='black',\n              step_increase = 0.075,\n              vjust=.3) +\n  theme(legend.position = 'none')\n\n\n\n\n\n\n\n\n10.1.6 Other R packages for adding significance levels\nNot to sidetrack too much, but other R packages also offer the possibility of interfacing with ggplots and adding significance levels. One such example that could be looked at is the ggpubr package, which actually uses geom_signif() in the background but has some nice additional features. I won’t give a full overview of how this package achieves much of what we have shown above - please refer to some of the help guides. However, here are a couple of quick examples.\nLet’s use the dataset mdf which has two columns: values and group. There are three groups in this dataset.\n\nhead(mdf)\n\n    values grp\n1 3.809373   A\n2 3.707874   A\n3 3.114335   A\n4 3.500416   A\n5 3.947273   A\n6 3.994897   A\n\n\nThis is the plot we previously made:\n\npb\n\n\n\n\nThe syntax to add p-values is with stat_compare_means() in a very similar way to geom_signif(). Note we can also add the p-value from the One-Way ANVOA directly onto the plot here also, if we wish:\n\nlibrary(ggpubr)\n\npb +  \n  stat_compare_means(method = \"anova\", label.y = 5)+\n  stat_compare_means(comparisons = list(c(\"A\",\"B\"),\n                                        c(\"B\",\"C\"),\n                                        c(\"A\",\"C\")), \n                     method = \"t.test\", \n                     label.y = c(4.15,4.3,4.45)\n  )\n\n\n\n\nA nice feature of this package is the ability to compare individual groups to a reference group or control. Let’s create some data to do this:\n\nset.seed(15)\nxdf <- data.frame(\n  values = c(\nrnorm(n = 20, mean = 0, sd = .4),\nrnorm(n = 20, mean = 0.3, sd = .7),\nrnorm(n = 20, mean = 0.6, sd = .15),\nrnorm(n = 20, mean = 0.2, sd = .4),\nrnorm(n = 20, mean = 0.4, sd = .4),\nrnorm(n = 20, mean = 0.7, sd = .5)\n),\ngroups = rep(LETTERS[1:6],each=20)\n)\n\nhead(xdf)\n\n      values groups\n1  0.1035291      A\n2  0.7324483      A\n3 -0.1358474      A\n4  0.3588793      A\n5  0.1952065      A\n6 -0.5021543      A\n\n\nThese data could be plotted as follows. I’m using the brewer.greens color palette from the pals package.:\n\npg <- ggplot(xdf, aes(x=groups, y=values, fill=groups)) +\n  geom_boxplot() +\n  scale_fill_manual(values=pals::brewer.greens(6)) +\n  theme_pubclean() +\n  theme(legend.position = 'none') +\n  xlab(\"\") +\n  ylab(\"Values\") \n\npg\n\n\n\n\nBelow, using ref.group=\"A\" we run independent t-tests comparing each group to A. Instead of notating p-values here, we use asterisks by including a label= option.\n\nmaxvals <- xdf %>% \n  group_by(groups) %>% \n  summarise(maxval = max(values)) %>% \n  pull(maxval) \n\npg +  \n  stat_compare_means(aes(label = after_stat(p.signif)),\n                   method = \"t.test\", ref.group = \"A\"\n                   )"
  },
  {
    "objectID": "waffle.html",
    "href": "waffle.html",
    "title": "13  Waffle Charts",
    "section": "",
    "text": "Waffle charts are square grid based plots that convert frequencies or proportions to different numbers of squares. These are easier to interpret than their pie chart cousins. Let’s see an example:\nHere we have 7 groups and associated frequencies in each group.\n\nset.seed(10)\nx <- round(runif(7, 1, 100),0)\nnames(x) <- LETTERS[1:7]\n\nx\n\n A  B  C  D  E  F  G \n51 31 43 70  9 23 28 \n\n\nTo make the basic waffle plot, we can just use the function waffle() on a numerical vector:\n\nlibrary(waffle)\nwaffle(x)\n\n\n\n\nIn this default plot, waffle is using one square to represent each value. However, we can control this more effectively. First, we could divide our own vector by 5 such that each square represents 5. We can also specify the number of rows we wish to plot the data on:\n\nwaffle(x/5, rows=6)\n\n\n\n\nDigging into this a bit more. Group A has 10 squares each worth 5 which makes 50. This is 1 less than the 51 in group A. Group E only has one square (worth 5) when it’s value was 9. On the other hand, group G has 5 squares worth 25, when it’s value was 28. So, it can be seen that some artistic license has been made in the creation of the blocks in the waffle chart. This may be problematic in some representations of data, but may be perfectly fine in others. As an aside, I discuss the issues of aportionment (determining how to deal with left overs of fractions when grouping variables) in a blog post here.\nThe function waffle() also has some other functionality such as user-defining the colors to be used and the legend position:\n\nwaffle(x/5, rows = 6,\n       colors = c(\"#f9f988\",\"#f6be68\",\"#e1875e\",\"#ba585c\",\n                           \"#853357\",\"#491b49\",\"#0a0431\"\n       ),\n       legend_pos = \"bottom\")\n\n\n\n\n\n\n13.0.1 geom_waffle()\nThere are a lot of other interesting functionalities in the waffle package. Notably, we can use the function geom_waffle() in conjunction with other ggplot2 functions to create elegant plots. Note, that I have sometimes found that you need to install the developmental version of waffle directly from GitHub to get some of these to work.\n\n#remotes::install_github(\"hrbrmstr/waffle\")\nlibrary(waffle)\n\ninsert waffle examples here -\n-small multiples -alpha transparency -changing borders and sizes\n\n\n\n13.0.2 Combining waffles with pictograms\nSometimes a fun way to represent data in a waffle chart is to use some pictogram instead of a square. Below are a few examples.\nWaffles + Icons\nThere are a few ways to add icons to waffles.\nHere are some data showing the proportion of US people that have different eye colors.\n\neyecolor <- c(45,27,18,9,1)\nnames(eyecolor) <- c(\"Brown\", \"Blue\", \"Hazel\", \"Green\",\"Other\")\n\n\nMaybe include ggwaffle linked here\n\nWaffles + Phylopics\nThe below is an example of using the package rphylopic to use elephant images within a waffle chart. (Need to look up my code for how to do this):\n\n\n\n\n13.0.3 Practical Example - waffle charts\nThis practical example of how to use waffle charts is taken directly from Bob Rudis’s guide on waffle charts. It uses the storms dataset which is available in the dplyr package. It describes the frequencies of different types of storm across different years.\n\nlibrary(tidyverse)\n\nstorms_df <- storms %>%\n  filter(year >= 2010) %>%\n  count(year, status) \n\nstorms_df\n\n# A tibble: 33 x 3\n    year status                  n\n   <dbl> <chr>               <int>\n 1  2010 hurricane             138\n 2  2010 tropical depression    71\n 3  2010 tropical storm        193\n 4  2011 hurricane              79\n 5  2011 tropical depression    41\n 6  2011 tropical storm        203\n 7  2012 hurricane             122\n 8  2012 tropical depression    56\n 9  2012 tropical storm        276\n10  2013 hurricane              13\n# ... with 23 more rows\n\n\n\nlibrary(waffle)\nlibrary(ggthemes)\n\nggplot(storms_df, aes(fill = status, values = n)) +\n  geom_waffle(color = \"white\", size = .25, n_rows = 10, flip = TRUE) +\n  facet_wrap(~year, nrow = 1, strip.position = \"bottom\") +\n  scale_x_discrete() +\n  scale_y_continuous(labels = function(x) x * 10, # make this multiplyer the same as n_rows\n                     expand = c(0,0)) +\n  ggthemes::scale_fill_tableau(name=NULL) +\n  coord_equal() +\n  labs(\n    title = \"Faceted Waffle Bar Chart\",\n    subtitle = \"{dplyr} storms data\",\n    x = \"Year\",\n    y = \"Count\"\n  ) +\n  theme_minimal(base_family = \"Roboto Condensed\") +\n  theme(panel.grid = element_blank(), axis.ticks.y = element_line()) +\n  guides(fill = guide_legend(reverse = TRUE))"
  },
  {
    "objectID": "pie.html",
    "href": "pie.html",
    "title": "14  Pie Charts",
    "section": "",
    "text": "Friends don’t let friends use pie charts except in specific situations. I’ll discuss those at the end. But why are pie charts bad? Basically humans are very bad at estimating quantities based on angles - and pie charts (and donut charts) use slices. This can lead to situations in which we perceive groups to have equivalent areas, but they do not. This is particularly a problem when we are plotting data including more than 2 groups. Much more often, we can represent the data more efficiently using a bar graph.\n\nImage credit: wikimedia\nBut, for the sake of completeness, let’s look at how pie charts could be coded in ggplot2. But, please, don’t ever make them.\nPie charts with coord_polar()\nHere are some data showing the proportion of Australia’s population in each state or territory:\n\naus <- data.frame(\n  state = c(\"NSW\",\"Vic\",\"Qld\",\"WA\",\"SA\",\"Tas\",\"ACT\",\"NT\"),\n  prop = c(32,26,20,10,7,2,2,1)\n)\n\naus\n\n  state prop\n1   NSW   32\n2   Vic   26\n3   Qld   20\n4    WA   10\n5    SA    7\n6   Tas    2\n7   ACT    2\n8    NT    1\n\n\nAnd here is some ggplot2 code to make a pie chart. The trick is to make a bar graph that gets turned into a circle with coord_polar.\n\nlibrary(tidyverse)\n\nggplot(aus, aes(x=\"\", y=prop, fill=state)) +\n  geom_bar(stat=\"identity\") +\n  coord_polar(\"y\") +\n  theme_void()\n\n\n\n\nI think it looks horrendous. It’s also plotted it in alphabetical order, so we could tell it to plot from highest to lowest proportion using reorder. I’m also editing the legend title using labs.\n\nggplot(aus, aes(x=\"\", y=prop, fill=reorder(state,-prop))) +\n  geom_bar(stat=\"identity\") +\n  coord_polar(\"y\") +\n  theme_void() +\n  labs(fill=\"State\")\n\n\n\n\nIt’s still awful. Below I’m adjusting the colors using the parula palette from the R package pals. I’m also adding the size of each area with geom_text().\n\nggplot(aus, aes(x=\"\", y=prop, fill=reorder(state,-prop))) +\n  geom_bar(stat=\"identity\", width=1) +\n  coord_polar(\"y\", start=0) +\n  theme_void() +\n  labs(fill=\"State\") +\n  geom_text(aes(label = prop), position = position_stack(vjust = 0.5)) +\n  scale_fill_manual(values=pals::parula(nrow(aus)))\n\n\n\n\nAs can be seen from the above, it can actually be quite painstaking to add the text in the right place - especially if there are lots of small segments.\nOne way I have found around this is to use the code below to calculate the starting position of where labels should go and then to use geom_text_repel() to wiggle the labels.\nCalculate starting positions:\n\naus <- aus %>% \n  arrange(prop)\n\naus$pos <- (cumsum(c(0, aus$prop)) + c(aus$prop / 2, .01))[1:nrow(aus)]\n\naus \n\n  state prop  pos\n1    NT    1  0.5\n2   Tas    2  2.0\n3   ACT    2  4.0\n4    SA    7  8.5\n5    WA   10 17.0\n6   Qld   20 32.0\n7   Vic   26 55.0\n8   NSW   32 84.0\n\n\nAdding labels which convey the proportions with label=prop inside geom_text_repel():\n\nlibrary(ggrepel)\n\nggplot(aus, aes(x=\"\", y=prop, fill=reorder(state,-prop))) +\n  geom_bar(stat=\"identity\", width=1) +\n  coord_polar(\"y\", start=0) +\n  theme_void() +\n  labs(fill=\"State\") +\n  scale_fill_manual(values=pals::parula(nrow(aus))) +\n  geom_text_repel(aes(x = 1.4, y = pos, label = prop), \n                    nudge_x = .3, \n                    segment.size = .7, \n                    show.legend = FALSE) \n\n\n\n\nAlternatively, we can ditch the legend and use the labels to add the categories. Despite me writing all this code - we shouldn’t be bothering with adding numbers to pie chart segments, we should just be making bar graphs where you can actually see how much is in each group. Nonetheless, this time with category labels with label=state:\n\nggplot(aus, aes(x=\"\", y=prop, fill=reorder(state,-prop))) +\n  geom_bar(stat=\"identity\", width=1) +\n  coord_polar(\"y\", start=0) +\n  theme_void() +\n  labs(fill=\"State\") +\n  scale_fill_manual(values=pals::parula(nrow(aus))) +\n  geom_text_repel(aes(x = 1.4, y = pos, label = state), \n                    nudge_x = .3, \n                    segment.size = .7, \n                    show.legend = FALSE) +\n  theme(legend.position = 'none')\n\n\n\n\nOne final tweak - we can make the segments more pronounced by adding a line color and a linewidth to the geom_bar() . I also add a title in labs() and position it in the center with the plot.title theme element and hjust = 0.5.\n\nggplot(aus, aes(x=\"\", y=prop, fill=reorder(state,-prop))) +\n  geom_bar(stat=\"identity\", width=1, linewidth=.75, color='black') +\n  coord_polar(\"y\", start=0) +\n  theme_void() +\n  labs(fill=\"State\", \n       title = \"I don't like pie charts\") +\n  scale_fill_manual(values=pals::parula(nrow(aus))) +\n  geom_text_repel(aes(x = 1.4, y = pos, label = state), \n                    nudge_x = .3, \n                    segment.size = .7, \n                    show.legend = FALSE) +\n  theme(legend.position = 'none',\n        plot.title = element_text(hjust = 0.5)) \n\n\n\n\nWith all the above being said. Here’s how I would actually plot the above data. In a bar chart:\n\nggplot(aus, aes(x=reorder(state,prop), y=prop)) +\n  geom_col(color='cornflowerblue', fill='cornflowerblue', alpha=.6) +\n  theme_classic() +\n  coord_flip() +\n  xlab(\"\") +\n  ylab(\"Proportion (%)\") +\n  ggtitle(\"Proportion of Population by State in Australia\") +\n  theme(axis.text = element_text(face='bold', size=rel(1.2)),\n        axis.title = element_text(face='bold', size=rel(1.2)),\n        plot.title = element_text(face='bold', size=rel(1.4)),) \n\n\n\n\n\n\n14.0.1 Pie charts with two groups\nThe one exception to the “pie charts are bad” rule may be if we are representing proportions between two groups, especially when we wish to compare across a number of different subjects. For example, imagine we were running a study where we measure the proportion of correct answers given by subjects on a memory task in a control group and in a treatment group where they are given a proposed memory enhancing drug. In such a dataset, we may record the proportion of correct and incorrect responses for each subject in a dataframe like the one below:\n\n# Generating Random Data for Example\nset.seed(71)\ndf <- data.frame(\n  Subject = c(paste0(\"C\",1:10),paste0(\"T\",1:10)),\n  Group = rep(c('control', 'treatment'), each=10),\n  Correct = runif(20)\n)\n\ndf$Incorrect <- 1 - df$Correct\n\nhead(df)\n\n  Subject   Group   Correct  Incorrect\n1      C1 control 0.3329281 0.66707194\n2      C2 control 0.5551039 0.44489613\n3      C3 control 0.3273700 0.67263004\n4      C4 control 0.2116670 0.78833304\n5      C5 control 0.3161214 0.68387864\n6      C6 control 0.9472664 0.05273357\n\n\nIf you glance at the final plot a few lines below, you will notice that we have plotted individuals in the control group on the first row, and individuals from the treatment group on the second row. We have also plotted individuals from highest to lowest proportion of correct responses in each group. To do this, we need to set the levels of the Subject factor to be in this order. We grab these names in the appropriate order by using arrange() to sort the data (controls sorted by highest to lowest, then treatments sorted by highest to lowest), and then using pull() to take the names.\n\nsubjs <- df %>%\n  arrange(Group,-Correct) %>%\n  pull(Subject)\n\nsubjs\n\n [1] \"C6\"  \"C8\"  \"C7\"  \"C2\"  \"C10\" \"C9\"  \"C1\"  \"C3\"  \"C5\"  \"C4\"  \"T10\" \"T9\" \n[13] \"T5\"  \"T8\"  \"T6\"  \"T4\"  \"T2\"  \"T3\"  \"T7\"  \"T1\" \n\n\nTo get the data into plotting format, we need to pivot the data into long form using pivot_longer(). Then we can set our factor level.\n\ndf <- df %>% pivot_longer(cols=3:4, names_to=\"choice\")\ndf$Subject <- factor(df$Subject, levels = subjs)\n\nhead(df)\n\n# A tibble: 6 x 4\n  Subject Group   choice    value\n  <fct>   <chr>   <chr>     <dbl>\n1 C1      control Correct   0.333\n2 C1      control Incorrect 0.667\n3 C2      control Correct   0.555\n4 C2      control Incorrect 0.445\n5 C3      control Correct   0.327\n6 C3      control Incorrect 0.673\n\n\nThen we use facet_wrap() to plot by both Group and Subject so that we get the text above each pie chart. I used a black and white fill of the pie charts as it makes it easy to look at how subjects vary.\n\nggplot(df, aes(x=\"\", y=value, fill=choice)) +\n  geom_bar(stat=\"identity\", width=1, linewidth=.75, color='black') +\n  coord_polar(\"y\", start=0) +\n  theme_void() +\n  facet_wrap(~Group*Subject,nrow=2) +\n  scale_fill_manual(values=c(\"black\",\"white\")) +\n  theme(legend.position = 'bottom',\n        legend.title = element_blank())\n\n\n\n\nThis sort of pie chart I actually secretly quite like - and it is probably the only one that I would ever willfully make."
  },
  {
    "objectID": "lollipop.html",
    "href": "lollipop.html",
    "title": "8  Lollipop Plots",
    "section": "",
    "text": "Lollipop plots are a way to represent the same information as bar charts but in a more aesthetically pleasing way. They are comprised of a line and a dot.\nIn ggplot2 we can create them using geom_segment() to create the line and geom_point() to create the dot.\nThe dataset we’ll use in this tutorial is station_usage which provides information on passenger numbers using UK train stations during 2017. We’ll just keep the variables we need and clean up the column names. We also need to edit the Passengers column to ensure it’s numeric after we remove the commas.\n\nrail <- read.csv(\"data_raw/station_usage.csv\")\n\ndf <- rail[c(2:4,15,20)]\ncolnames(df) <- c(\"TLC\",\"Name\",\"Region\",\"Network\",\"Passengers\")\ndf$Passengers <- as.numeric(gsub(\",\",\"\",df$Passengers))\nhead(df)\n\n  TLC       Name        Region            Network Passengers\n1 ABW Abbey Wood        London           Southern    3769402\n2 ABE       Aber Wales - Cymru    Wales & Western     283894\n3 ACY  Abercynon Wales - Cymru    Wales & Western     329532\n4 ABA   Aberdare Wales - Cymru    Wales & Western     581388\n5 ABD   Aberdeen      Scotland Scotland's Railway    2616142\n6 AUR   Aberdour      Scotland Scotland's Railway     140048\n\n\nLet’s say we wished to create a dot plot of the top 10 stations in Scotland for passenger numbers. We can use slice_max() to get the top 10:\n\nlibrary(tidyverse)\n\ntop10 <- df %>% filter(Region==\"Scotland\") %>% slice_max(Passengers, n=10)\ntop10\n\n   TLC                    Name   Region            Network Passengers\n1  GLC         Glasgow Central Scotland Scotland's Railway   32797088\n2  EDB               Edinburgh Scotland Scotland's Railway   23872996\n3  GLQ    Glasgow Queen Street Scotland Scotland's Railway   17207208\n4  PYG  Paisley Gilmour Street Scotland Scotland's Railway    4027962\n5  HYM               Haymarket Scotland Scotland's Railway    3068112\n6  PTK                 Partick Scotland Scotland's Railway    2944084\n7  ABD                Aberdeen Scotland Scotland's Railway    2616142\n8  STG                Stirling Scotland Scotland's Railway    2480154\n9  CHC Charing Cross (Glasgow) Scotland Scotland's Railway    2229356\n10 DEE                  Dundee Scotland Scotland's Railway    2015782\n\n\nTo make our basic lollipop plot with no customization, we need to add a point and a segment. We’ll use the station code rather than the full name for space. With geom_segment() we need to give it’s horizontal width by giving a start and end point for the x-axis, and we do the same on the y-axis for the height.\n\nggplot(top10, aes(x=TLC, y=Passengers)) +\n  geom_point() + \n  geom_segment(aes(x=TLC, xend=TLC, y=0, yend=Passengers))\n\n\n\n\nThe first thing I’d like to do here is reorder the stations so they are not in alphabetical order, but in descending numerical order. We also provide a title on the x-axis:\n\nggplot(top10, aes(x=reorder(TLC,-Passengers), y=Passengers)) +\n  geom_point() + \n  geom_segment(aes(x=TLC, xend=TLC, y=0, yend=Passengers)) +\n  xlab(\"Station\")\n\n\n\n\nWe can customize the colors and sizes of our segment lines and dots. Below, we first factor the TLC column to have the top 10 stations in Passenger order. This is so when we assign the red color and fill (using the brewer.reds palette from the pals package), it plots the colors in the correct order and not in alphabetical order.\n\ntop10$TLC <- factor(top10$TLC, levels = top10 %>% pull(TLC))\n\n\nggplot(top10, aes(x=TLC, y=Passengers, color=TLC, fill=TLC)) +\n  geom_segment(aes(x=TLC, xend=TLC, y=0, yend=Passengers),linewidth=1.5)+\n  geom_point(size=4, stroke=2) +\n  xlab(\"Station\") +\n  scale_color_manual(values = rev(pals::brewer.reds(10))) +\n  scale_fill_manual(values = rev(pals::brewer.reds(10))) \n\n\n\n\nBelow I add some extra customization. We set the theme to be theme_light, remove the legend which is superfluous and tidy up the panel border and x-axis ticks. I also change the y-axis scale to show numbers in millions with the letter “M”. This is using the scales::label_number function (from the scales package).\n\nggplot(top10, aes(x=TLC, y=Passengers, color=TLC, fill=TLC)) +\n  geom_segment(aes(x=TLC, xend=TLC, y=0, yend=Passengers),linewidth=1.5)+\n  geom_point(size=4, stroke=2) +\n  xlab(\"Station\") +\n  scale_color_manual(values = rev(pals::brewer.reds(10))) +\n  scale_fill_manual(values = rev(pals::brewer.reds(10))) +\n  scale_y_continuous(labels = scales::label_number(suffix = \" M\", scale = 1e-6)) +\n  theme_light() +\n  theme(legend.position='none',\n        axis.ticks.x = element_blank(),\n        panel.border = element_blank())\n\n\n\n\n\n\n8.0.1 Lollipop Charts adding Baselines and Highlighting\nSometimes it helps to visualize changes from some baseline level. In the following example, we are going to look at percent changes in rail passengers usage from 2017 compared to the previous year. Below, we grab all the stations in the “East Midlands” region and collect and rename the columns we want. We also ensure that the columns we need to be numeric are:\n\nrr <- rail[rail$Region==\"East Midlands\",]\nrr <- rr[c(2:4,15,20,27)]\ncolnames(rr) <- c(\"TLC\",\"Name\",\"Region\",\"Network\",\"Passengers\",\"PctChange\")\nrr$Passengers <- as.numeric(gsub(\",\",\"\",rr$Passengers))\nrr$PctChange <- as.numeric(gsub(\"%\",\"\",rr$PctChange))\nhead(rr)\n\n    TLC         Name        Region              Network Passengers PctChange\n43  ALF     Alfreton East Midlands              Eastern     314464       5.6\n56  AMB    Ambergate East Midlands              Eastern      41130     -11.6\n60  ANC     Ancaster East Midlands              Eastern       5904     -10.2\n107 ALK    Aslockton East Midlands              Eastern      31204      25.1\n114 ATB Attenborough East Midlands              Eastern      99484      -7.8\n139 BAM      Bamford East Midlands North West & Central      34526       9.1\n\n\nFor the plot, we want to have a new column that will be called UpDown which will depict whether the percent change is positive or negative. Also, we are going to plot stations on the x-axis in their rank order, so we set the levels of the station column TLC to be in the correct order by using arrange and pull.\n\nrr$UpDown <- ifelse(rr$PctChange > 0, \"up\",\"down\")\n\nrr %>% arrange(-Passengers) %>% pull(TLC)\n\n  [1] \"NOT\" \"LEI\" \"DBY\" \"NMP\" \"LCN\" \"CHD\" \"GRA\" \"LBO\" \"GLO\" \"KET\" \"WEL\" \"NNG\"\n [13] \"MHR\" \"NCT\" \"LGE\" \"BEE\" \"RET\" \"WRK\" \"MFT\" \"HDF\" \"NBR\" \"LBK\" \"SMD\" \"EMD\"\n [25] \"SKG\" \"HNK\" \"BUX\" \"ALF\" \"SLR\" \"COR\" \"MMO\" \"OKM\" \"NMN\" \"BSN\" \"SYS\" \"NMC\"\n [37] \"BLP\" \"MAT\" \"HKN\" \"SPK\" \"DRO\" \"SPA\" \"MSW\" \"KKB\" \"HKM\" \"DTG\" \"GBL\" \"WBR\"\n [49] \"ILN\" \"CLY\" \"SIL\" \"CLM\" \"MGM\" \"ATB\" \"EDL\" \"LGM\" \"BWS\" \"SHB\" \"SWS\" \"RKT\"\n [61] \"BIN\" \"KGS\" \"SXY\" \"LOW\" \"TUT\" \"MKR\" \"HOP\" \"DFI\" \"HSG\" \"BLW\" \"CEF\" \"HEC\"\n [73] \"BTF\" \"MTB\" \"GRN\" \"CTO\" \"WFL\" \"CMF\" \"AMB\" \"NSD\" \"CWD\" \"WIL\" \"FSK\" \"SRO\"\n [85] \"BAM\" \"ALK\" \"FNV\" \"WTS\" \"WWL\" \"LAG\" \"SPO\" \"SWD\" \"BUJ\" \"RAU\" \"RDF\" \"NET\"\n [97] \"BSB\" \"ROL\" \"DVH\" \"ANC\" \"SWE\" \"THU\" \"PEA\" \"GNB\" \"HBB\" \"TPC\" \"ELO\" \"HVN\"\n\nrr$TLC <- factor(rr$TLC, levels = rr %>% arrange(-Passengers) %>% pull(TLC))\nrr$Name <- factor(rr$Name, levels = rr %>% arrange(-Passengers) %>% pull(Name))\n\nThe code for the plot is below. geom_segment() and geom_point() are doing the same job as before. Our y-axis ranges from negative values to positive, and 0 is our baseline. So we use y=0 as the baseline value in geom_segment().\n\nggplot(rr,aes(x=Name, y=PctChange,color=UpDown, fill=UpDown)) +\n  geom_segment(aes(x=Name, xend=Name, y=0, yend=PctChange))+\n  geom_point(size=2)+\n  scale_color_manual(values = c(\"#FA8072\",\"darkblue\" )) +\n  scale_fill_manual(values = c( \"#FA8072\",\"darkblue\"))  +\n  xlab(\"Station\") +\n  ylab(\"Percent Change from Previous Year %\") +\n  theme_light() +\n  theme(legend.position='none',\n        axis.ticks.x = element_blank(),\n        panel.border = element_blank(),\n        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1,size=5)) \n\n\n\n\nThe above chart is quite useful for visualizing overall trends quickly, but the plot is quite busy with many individual stations on the x-axis. Without zooming in, it’s hard to identify which stations had the biggest percentage changes. One way to help with this is to use highlighting of the segments and points as well as the axis labels. In this example we do it by using ifelse() logical expressions. This does work, although ggplot2 gives a warning message for using it inside the axis.text.x argument. But, for now, at least, it works fine.\n\nggplot(rr,aes(x=Name, y=PctChange)) +\n  geom_segment(\n    aes(x=Name, \n        xend=Name, \n        y=0, \n        yend=PctChange),\n        color=ifelse(rr$PctChange < -25, \"darkorange\", \"grey44\"), \n        linewidth=ifelse(rr$PctChange < -25, 1.1, 0.7)\n    )+\n  geom_point(\n         color=ifelse(rr$PctChange < -25, \"darkorange\", \"grey44\"), \n         size=ifelse(rr$PctChange < -25, 3, 1)) +\n  xlab(\"Station\") +\n  ylab(\"Percent Change from Previous Year %\") +\n  theme_light() +\n  theme(legend.position='none',\n        axis.ticks.x = element_blank(),\n        panel.border = element_blank(),\n        panel.grid.major.x = element_blank(),\n        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1,\n                     face=ifelse(rr$PctChange < -25,\"bold\",\"plain\"),\n                     size=ifelse(rr$PctChange < -25,7,5),\n                     color=ifelse(rr$PctChange < -25,\"#A14A11\",\"grey44\"))\n        )"
  },
  {
    "objectID": "dot.html",
    "href": "dot.html",
    "title": "7  Dot Plots",
    "section": "",
    "text": "Dot plots, sometimes called Cleveland dot plots, are a way to represent frequencies in a simple way. Often we use them to compare the frequencies of two groups across subjects."
  }
]