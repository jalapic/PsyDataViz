[
  {
    "objectID": "bumps.html#basic-bump-chart-in-ggplot",
    "href": "bumps.html#basic-bump-chart-in-ggplot",
    "title": "10  Bump charts",
    "section": "10.1 Basic Bump Chart in ggplot()",
    "text": "10.1 Basic Bump Chart in ggplot()\nWe can look at how to make a bump chart using basic ggplot2 syntax. We’ll recreate the above chart. Let’s import the data:\n\nlibrary(tidyverse)\n\ndf <- read_csv(\"data_raw/torpids.csv\")\nhead(df)\n\n# A tibble: 6 x 8\n  Team            Day1  Day2  Day3  Day4  Day5  Day6  Day7\n  <chr>          <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 Exeter             1     2     3     3     4     5     4\n2 Brasenose          2     1     1     1     1     1     1\n3 Balliol            3     4     4     5     6     7     8\n4 Corpus Christi     4     3     2     2     2     3     3\n5 Pembroke           5     5     6     7     8     9     9\n6 Trinity            6     7     7     6     5     4     5\n\n\nWe have 12 rows of data. Each row is a college team. There are eight columns with the last seven being the ranking of each college on that day. To turn the data into a plottable format, we need to have a long data frame with columns team, day and rank.\n\ndfl <- df %>%\n  pivot_longer(cols=2:8, names_to = \"day\", values_to = \"rank\")\nhead(dfl)\n\n# A tibble: 6 x 3\n  Team   day    rank\n  <chr>  <chr> <dbl>\n1 Exeter Day1      1\n2 Exeter Day2      2\n3 Exeter Day3      3\n4 Exeter Day4      3\n5 Exeter Day5      4\n6 Exeter Day6      5\n\n\nWe can now plot day against rank using a combination of geom_line() and geom_plot(). First we will create a plot color with a legend depicting each college. We use scale_y_reverse() to plot the rankings on the y-axis from highest rank at the top of the plot to lowest ranking at the bottom.\n\nggplot(dfl, aes(x = day, y = rank, color = Team, group = Team)) +\n  geom_line(lwd=1) +\n  geom_point(size=4) +\n  xlab(\"\")+\n  scale_y_reverse(breaks=1:12) +\n  theme_classic()\n\n\n\n\nHowever, I think this plot is a little too colorful. Alternatively, we could create the plot in one color and add labels on the y-axis that have the names of the original ranks of teams. This would be more similar to the original plot:\n\nggplot(dfl, aes(x = day, y = rank, group = Team)) +\n  geom_line(lwd=1) +\n  geom_point(size=4) +\n  xlab(\"\")+\n  scale_y_reverse(breaks=1:12, labels = df$Team) +\n  theme_classic()\n\n\n\n\nThere are probably several stylistic changes we could make to this plot to make it more visually appealing. It’s often nice with bump charts to have the dots be empty circles. We can do this by adding smaller white points on top of the points that we already plotted:\n\nggplot(dfl, aes(x = day, y = rank, group = Team)) +\n  geom_line(lwd=1) +\n  geom_point(size=4) +\n  geom_point(color = \"#FFFFFF\", size = 2) +\n  scale_y_reverse(breaks=1:12, labels = df$Team) +\n  xlab(\"\") +\n  ylab(\"\") +\n  theme_classic() \n\n\n\n\nIn this plot, I have used the theme() function to remove the y axis line and tick marks and to make the text larger.\n\nggplot(dfl, aes(x = day, y = rank, group = Team)) +\n  geom_line(lwd=1) +\n  geom_point(size=4) +\n  geom_point(color = \"#FFFFFF\", size = 2) +\n  scale_y_reverse(breaks=1:12, labels = df$Team) +\n  xlab(\"\") +\n  ylab(\"\") +\n  theme_classic() +\n  theme(\n        axis.ticks.y = element_blank(),\n        axis.line.y = element_blank(),\n        axis.text.y = element_text(size = rel(1.5))\n        )\n\n\n\n\nHighlighting Individual Groups\nAnother thing that is often beneficial in bump charts is to highlight individual groups of interest. This is particularly useful if there are lots of subjects. For example, let’s say we are interested in the change in ranking of the Trinity boat over time. What we would like to do is make the other lines more transparent and to make Trinity’s line bolder. To do this, we use alpha() to set the transparencies of the other crews and I also made their colors grayer. Then I create a dataframe that only includes Trinity’s data to plot over the top of our plot, and change the color of their points and lines and thicken their line to emphasize it.\n\nTrinity <- dfl %>% filter(Team==\"Trinity\")\n\nggplot(dfl, aes(x = day, y = rank, group = Team)) +\n  geom_line(lwd=1, color=\"gray50\", alpha=.3) +\n  geom_point(size=4, color=\"gray50\", alpha=.3) +\n  geom_line(data=Trinity, lwd=2, color=\"#710909\") +\n  geom_point(data=Trinity, size=4, color=\"#710909\") +\n  geom_point(color = \"#FFFFFF\", size = 2) +\n  scale_y_reverse(breaks=1:12, labels = df$Team) +\n  xlab(\"\") +\n  ylab(\"\") +\n  theme_classic() +\n  theme(\n        axis.ticks.y = element_blank(),\n        axis.line.y = element_blank(),\n        axis.text.y = element_text(size = rel(1.5))\n        )"
  },
  {
    "objectID": "bumps.html#ggbump-package",
    "href": "bumps.html#ggbump-package",
    "title": "10  Bump charts",
    "section": "10.2 ggbump() package",
    "text": "10.2 ggbump() package\nI like the classic angular lines aesthetic of bump charts. However, there may be use cases where we wish to have curved lines joining points. This can be done effectively with the ggbump package.\nThe below code creates the generic plot for the college bumps dataset above. I’ve kept the scale_y_reverse() in the code so that we have the highest ranked team (i.e. 1) at the top of the y-axis, and the lowest ranked at the bottom. The geom_bump() function adds a curved line rather than straight line for each subject across time. The other difference is that I have made the day column numeric by using as.numeric(factor(day)) rather than just day. Although geom_bump() should work with characters, I have found that converting them to numeric variables works best.\n\nlibrary(ggbump)\n\nggplot(dfl, aes(as.numeric(factor(day)), rank, color = Team)) +\n    geom_bump(size=1) +\n    scale_y_reverse(breaks=1:12) \n\n\n\n\nBelow I have customized this plot with some additional code. I have decided to create a palette of 12 colors using the viridis palette, though having 12 separate colors for a discrete category is probably pushing the limits of what is easily interpretable. These colors would be added in alphabetical order as a default as the Team variable is a character. This would mean that Balliol would have the darkest purple color and Wadham the lightest yellow. A better way of assigning color would be by initial or final rank. I decided to assign here by initial rank. Therefore I converted the Team variable to a factor and made the levels the order of ranks on the first day. The easiest way to do this was to use unique(dfl$Team) as they appear in rank order of the first day in the dataset.\n\nlibrary(viridis) #for color scale\n\n#refactor Team to be in rank order (same as order appears in dataset)\ndfl$Team <- factor(dfl$Team, levels = unique(dfl$Team))\n\nggplot(dfl, aes(as.numeric(factor(day)), rank, color = Team)) +\n  geom_bump(size=1) +\n  geom_point(size=4) +\n  geom_point(color = \"#FFFFFF\", size = 2) +\n  scale_x_continuous(breaks=1:7) +\n  scale_y_reverse(breaks=1:12, labels = df$Team) +\n  scale_color_manual(values=viridis(12,option=\"C\")) +\n  xlab(\"Day\") +\n  ylab(\"Rank\") +\n  theme_classic() +\n  xlab(\"Day\") +\n  ylab(\"\") +\n  theme_classic() +\n  theme(\n    axis.ticks.y = element_blank(),\n    axis.line.y = element_blank(),\n    axis.text.y = element_text(size = rel(1.5)),\n    legend.position = \"none\"\n  )\n\n\n\n\n\n10.2.1 Practical Example - Babyname Popularity Over Time.\nBelow is an example of using the ggbump package to plot changing trends of babyname popularity over time. The code for this was inspired by a plot of European Flight traffic made by Stephan Teodosescu.\nEssentially what we want to do is find the rankings in popularity of different babynames between two timepoints. We will plot the top 12 names at the final timepoint and track their evolution in popularity from the first timepoint. By only including these names, we avoid too much clutter in the chart and we are able to see how stable or otherwise the rankings are. I chose to look at the popularity of male names between 2012 and 2017.\nWe first get the ranking of all male names between 2012 and 2017. The data come from the babynames package:\n\nlibrary(babynames)\n\nbaby_year <- babynames %>%\n  filter(sex==\"M\") %>%\n  filter(year>=2012, year<=2017) %>%\n  select(year, name, total = n) %>%\n  group_by(year) %>%\n  mutate(\n    rank = row_number(desc(total))\n  ) %>%\n  ungroup() %>%\n  arrange(rank, year)\n\nbaby_year\n\n# A tibble: 84,665 x 4\n    year name  total  rank\n   <dbl> <chr> <int> <int>\n 1  2012 Jacob 19069     1\n 2  2013 Noah  18241     1\n 3  2014 Noah  19286     1\n 4  2015 Noah  19613     1\n 5  2016 Noah  19082     1\n 6  2017 Liam  18728     1\n 7  2012 Mason 18964     2\n 8  2013 Jacob 18148     2\n 9  2014 Liam  18451     2\n10  2015 Liam  18355     2\n# ... with 84,655 more rows\n\n\nWe can see that for the years 2012-2017, the names “Jacob”, “Noah” and “Liam” were the most popular.\nTo limit our chart to just the 12 most popular names in 2017, we can collect those names by filtering for rank and year and using pull() to grab the names:\n\nbaby_top <- baby_year %>%\n  filter(year == 2017, rank <= 12) %>%\n  pull(name)\n\nbaby_top\n\n [1] \"Liam\"     \"Noah\"     \"William\"  \"James\"    \"Logan\"    \"Benjamin\"\n [7] \"Mason\"    \"Elijah\"   \"Oliver\"   \"Jacob\"    \"Lucas\"    \"Michael\" \n\n\nAlways a difficulty with 12 discrete groups is what colors to assign to each in the chart. Here, I create a vector of colors using the pals color palette package:\n\nbaby_colors <- pals::tol(12)\nnames(baby_colors)<-baby_top\nbaby_colors\n\n     Liam      Noah   William     James     Logan  Benjamin     Mason    Elijah \n\"#332288\" \"#6699CC\" \"#88CCEE\" \"#44AA99\" \"#117733\" \"#999933\" \"#DDCC77\" \"#661100\" \n   Oliver     Jacob     Lucas   Michael \n\"#CC6677\" \"#AA4466\" \"#882255\" \"#AA4499\" \n\n\nNow for the actual plot. The use of geom_point(), geom_bump(), scale_y_reverse(), and scale_color_manual() are similar to how we have used them before. Notably in scale_y_reverse() we make the breaks go from 80 to -2. This is to ensure that Oliver gets plotted in 2012 as it’s ranking was just inside that value then. The -2 is to ensure that we can annotate the 2012 and 2017 at the top of the plot.\nThe coord_cartesian() is used to make sure that our plot stretches across the canvas appropriately.\nNext, the theme elements dictate the color of the plot background and the positioning of the title. The x-axis and y-axis titles are removed with labs() and the title’s name is added.\nFinally, we add text to the plot. The rankings and names of each line are positioned using geom_text() from the ggtext package, and the labels “2012” and “2017” are manually positioned using annotate().\n\nlibrary(ggtext)\n\nbaby_year %>%\n  filter(name %in% baby_top) %>%\n  ggplot(aes(year, rank, col = name)) +\n  geom_point(size = 2) +\n  geom_bump(size = 1) +\n  scale_y_reverse(position = \"right\", breaks = seq(80, -2, -2)) +\n  scale_color_manual(values = baby_colors) +\n  coord_cartesian(xlim = c(2010, 2017.5), ylim = c(80, -1.25), expand = F) +\n  theme_void() +\n  theme(\n    legend.position = \"none\",\n    plot.background = element_rect(fill = \"floralwhite\", color = \"floralwhite\"),\n    plot.title = element_text(\n      margin = margin(t = 3, b = 4, unit = \"mm\"),\n      hjust = 0.5\n    ),\n    plot.margin = margin(0,1,1.5,1.2, \"cm\")\n  ) +\n  labs(\n    x = \"\",\n    y = \"\",\n    title = \"Popularity of Selected Boy's Names in USA 2012-2017\"\n  )+\n  geom_text(\n    data = baby_year %>%\n    filter(year == 2012, name %in% baby_top),\n    aes(label = name),\n    hjust = 1,\n    nudge_x = -0.1,\n    fontface = \"bold\"\n  ) +\n  geom_text(\n    data = baby_year %>%\n      filter(year == 2017, name %in% baby_top),\n    aes(label = rank),\n    hjust = 0,\n    nudge_x = 0.1,\n    size = 4,\n    fontface = \"bold\"\n  ) +\n  annotate(\n    \"text\",\n    x = c(2011.75, 2016.75),\n    y = c(-0.75, -0.75),\n    label = c(2012, 2017),\n    hjust = c(0, 0),\n    vjust = 1,\n    size = 4,\n    fontface = \"bold\"\n  )"
  },
  {
    "objectID": "savingexporting.html#ggsave",
    "href": "savingexporting.html#ggsave",
    "title": "12  Saving and Exporting Plots",
    "section": "12.1 ggsave()",
    "text": "12.1 ggsave()\nA more premium option is to use a function from ggplot called ggsave(). The first step you should do is to assign your plot to an object name. In the code below, we are making a scatterplot that we save to the object plot1:\n\nlibrary(tidyverse)\n\ncheese <- read_csv(\"data_raw/cheese.csv\")\n\nplot1 <- ggplot(cheese, aes(x = chol, y = kcal)) + \n     geom_point(color='purple', size=2) + \n     theme_classic() +\n     xlab(\"Cholesterol\") +\n     ylab(\"Calories in kcal\") +\n     ggtitle(\"Cheese\")\n\nplot1\n\n\n\n\nNext, run a line of code that will save your plot. You type ggsave(). The first thing you put inside this is the location where you want your plot to be stored. You need to write a location on your computer. If you are using an Rproject such as with this course, you could put your plot in a folder called img. Remember to type the file extension .png or .pdf after the name of your new plot. The second thing you need to write is the name of the graph object you wish to save. Here our graph is called plot1.\n\nggsave(\"img/cheese_plot.png\", plot1)  # save as a png\n\nggsave(\"img/cheese_plot.pdf\", plot1)  # save as a pdf\n\nYou can also play around with the width and height of your saved image. You probably need to trial and error this a few times to get the proportions that you really like. Here we are making an image that is 10 inches wide and 8 inches high.\n\n#(in inches, though can be in cm)\nggsave(\"img/cheese_plot2.png\", plot1, width = 10, height = 8)"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "13  Summary",
    "section": "",
    "text": "There is no summary. I was just scared to delete this file."
  },
  {
    "objectID": "pie.html",
    "href": "pie.html",
    "title": "12  Pie Charts",
    "section": "",
    "text": "Friends don’t let friends use pie charts except in specific situations. I’ll discuss those at the end. But why are pie charts bad? Basically humans are very bad at estimating quantities based on angles - and pie charts (and donut charts) use slices. This can lead to situations in which we perceive groups to have equivalent areas, but they do not. This is particularly a problem when we are plotting data including more than 2 groups. Much more often, we can represent the data more efficiently using a bar graph.\n\nImage credit: wikimedia\nBut, for the sake of completeness, let’s look at how pie charts could be coded in ggplot2. But, please, don’t ever make them.\nPie charts with coord_polar()\nHere are some data showing the proportion of Australia’s population in each state or territory:\n\naus <- data.frame(\n  state = c(\"NSW\",\"Vic\",\"Qld\",\"WA\",\"SA\",\"Tas\",\"ACT\",\"NT\"),\n  prop = c(32,26,20,10,7,2,2,1)\n)\n\naus\n\n  state prop\n1   NSW   32\n2   Vic   26\n3   Qld   20\n4    WA   10\n5    SA    7\n6   Tas    2\n7   ACT    2\n8    NT    1\n\n\nAnd here is some ggplot2 code to make a pie chart. The trick is to make a bar graph that gets turned into a circle with coord_polar.\n\nlibrary(tidyverse)\n\nggplot(aus, aes(x=\"\", y=prop, fill=state)) +\n  geom_bar(stat=\"identity\") +\n  coord_polar(\"y\") +\n  theme_void()\n\n\n\n\nI think it looks horrendous. It’s also plotted it in alphabetical order, so we could tell it to plot from highest to lowest proportion using reorder. I’m also editing the legend title using labs.\n\nggplot(aus, aes(x=\"\", y=prop, fill=reorder(state,-prop))) +\n  geom_bar(stat=\"identity\") +\n  coord_polar(\"y\") +\n  theme_void() +\n  labs(fill=\"State\")\n\n\n\n\nIt’s still awful. Below I’m adjusting the colors using the parula palette from the R package pals. I’m also adding the size of each area with geom_text().\n\nggplot(aus, aes(x=\"\", y=prop, fill=reorder(state,-prop))) +\n  geom_bar(stat=\"identity\", width=1) +\n  coord_polar(\"y\", start=0) +\n  theme_void() +\n  labs(fill=\"State\") +\n  geom_text(aes(label = prop), position = position_stack(vjust = 0.5)) +\n  scale_fill_manual(values=pals::parula(nrow(aus)))\n\n\n\n\nAs can be seen from the above, it can actually be quite painstaking to add the text in the right place - especially if there are lots of small segments.\nOne way I have found around this is to use the code below to calculate the starting position of where labels should go and then to use geom_text_repel() to wiggle the labels.\nCalculate starting positions:\n\naus <- aus %>% \n  arrange(prop)\n\naus$pos <- (cumsum(c(0, aus$prop)) + c(aus$prop / 2, .01))[1:nrow(aus)]\n\naus \n\n  state prop  pos\n1    NT    1  0.5\n2   Tas    2  2.0\n3   ACT    2  4.0\n4    SA    7  8.5\n5    WA   10 17.0\n6   Qld   20 32.0\n7   Vic   26 55.0\n8   NSW   32 84.0\n\n\nAdding labels which convey the proportions with label=prop inside geom_text_repel():\n\nlibrary(ggrepel)\n\nggplot(aus, aes(x=\"\", y=prop, fill=reorder(state,-prop))) +\n  geom_bar(stat=\"identity\", width=1) +\n  coord_polar(\"y\", start=0) +\n  theme_void() +\n  labs(fill=\"State\") +\n  scale_fill_manual(values=pals::parula(nrow(aus))) +\n  geom_text_repel(aes(x = 1.4, y = pos, label = prop), \n                    nudge_x = .3, \n                    segment.size = .7, \n                    show.legend = FALSE) \n\n\n\n\nAlternatively, we can ditch the legend and use the labels to add the categories. Despite me writing all this code - we shouldn’t be bothering with adding numbers to pie chart segments, we should just be making bar graphs where you can actually see how much is in each group. Nonetheless, this time with category labels with label=state:\n\nggplot(aus, aes(x=\"\", y=prop, fill=reorder(state,-prop))) +\n  geom_bar(stat=\"identity\", width=1) +\n  coord_polar(\"y\", start=0) +\n  theme_void() +\n  labs(fill=\"State\") +\n  scale_fill_manual(values=pals::parula(nrow(aus))) +\n  geom_text_repel(aes(x = 1.4, y = pos, label = state), \n                    nudge_x = .3, \n                    segment.size = .7, \n                    show.legend = FALSE) +\n  theme(legend.position = 'none')\n\n\n\n\nOne final tweak - we can make the segments more pronounced by adding a line color and a linewidth to the geom_bar() . I also add a title in labs() and position it in the center with the plot.title theme element and hjust = 0.5.\n\nggplot(aus, aes(x=\"\", y=prop, fill=reorder(state,-prop))) +\n  geom_bar(stat=\"identity\", width=1, linewidth=.75, color='black') +\n  coord_polar(\"y\", start=0) +\n  theme_void() +\n  labs(fill=\"State\", \n       title = \"I don't like pie charts\") +\n  scale_fill_manual(values=pals::parula(nrow(aus))) +\n  geom_text_repel(aes(x = 1.4, y = pos, label = state), \n                    nudge_x = .3, \n                    segment.size = .7, \n                    show.legend = FALSE) +\n  theme(legend.position = 'none',\n        plot.title = element_text(hjust = 0.5)) \n\n\n\n\nWith all the above being said. Here’s how I would actually plot the above data. In a bar chart:\n\nggplot(aus, aes(x=reorder(state,prop), y=prop)) +\n  geom_col(color='cornflowerblue', fill='cornflowerblue', alpha=.6) +\n  theme_classic() +\n  coord_flip() +\n  xlab(\"\") +\n  ylab(\"Proportion (%)\") +\n  ggtitle(\"Proportion of Population by State in Australia\") +\n  theme(axis.text = element_text(face='bold', size=rel(1.2)),\n        axis.title = element_text(face='bold', size=rel(1.2)),\n        plot.title = element_text(face='bold', size=rel(1.4)),) \n\n\n\n\n\n\n12.0.1 Pie charts with two groups\nThe one exception to the “pie charts are bad” rule may be if we are representing proportions between two groups, especially when we wish to compare across a number of different subjects. For example, imagine we were running a study where we measure the proportion of correct answers given by subjects on a memory task in a control group and in a treatment group where they are given a proposed memory enhancing drug. In such a dataset, we may record the proportion of correct and incorrect responses for each subject in a dataframe like the one below:\n\n# Generating Random Data for Example\nset.seed(71)\ndf <- data.frame(\n  Subject = c(paste0(\"C\",1:10),paste0(\"T\",1:10)),\n  Group = rep(c('control', 'treatment'), each=10),\n  Correct = runif(20)\n)\n\ndf$Incorrect <- 1 - df$Correct\n\nhead(df)\n\n  Subject   Group   Correct  Incorrect\n1      C1 control 0.3329281 0.66707194\n2      C2 control 0.5551039 0.44489613\n3      C3 control 0.3273700 0.67263004\n4      C4 control 0.2116670 0.78833304\n5      C5 control 0.3161214 0.68387864\n6      C6 control 0.9472664 0.05273357\n\n\nIf you glance at the final plot a few lines below, you will notice that we have plotted individuals in the control group on the first row, and individuals from the treatment group on the second row. We have also plotted individuals from highest to lowest proportion of correct responses in each group. To do this, we need to set the levels of the Subject factor to be in this order. We grab these names in the appropriate order by using arrange() to sort the data (controls sorted by highest to lowest, then treatments sorted by highest to lowest), and then using pull() to take the names.\n\nsubjs <- df %>%\n  arrange(Group,-Correct) %>%\n  pull(Subject)\n\nsubjs\n\n [1] \"C6\"  \"C8\"  \"C7\"  \"C2\"  \"C10\" \"C9\"  \"C1\"  \"C3\"  \"C5\"  \"C4\"  \"T10\" \"T9\" \n[13] \"T5\"  \"T8\"  \"T6\"  \"T4\"  \"T2\"  \"T3\"  \"T7\"  \"T1\" \n\n\nTo get the data into plotting format, we need to pivot the data into long form using pivot_longer(). Then we can set our factor level.\n\ndf <- df %>% pivot_longer(cols=3:4, names_to=\"choice\")\ndf$Subject <- factor(df$Subject, levels = subjs)\n\nhead(df)\n\n# A tibble: 6 x 4\n  Subject Group   choice    value\n  <fct>   <chr>   <chr>     <dbl>\n1 C1      control Correct   0.333\n2 C1      control Incorrect 0.667\n3 C2      control Correct   0.555\n4 C2      control Incorrect 0.445\n5 C3      control Correct   0.327\n6 C3      control Incorrect 0.673\n\n\nThen we use facet_wrap() to plot by both Group and Subject so that we get the text above each pie chart. I used a black and white fill of the pie charts as it makes it easy to look at how subjects vary.\n\nggplot(df, aes(x=\"\", y=value, fill=choice)) +\n  geom_bar(stat=\"identity\", width=1, linewidth=.75, color='black') +\n  coord_polar(\"y\", start=0) +\n  theme_void() +\n  facet_wrap(~Group*Subject,nrow=2) +\n  scale_fill_manual(values=c(\"black\",\"white\")) +\n  theme(legend.position = 'bottom',\n        legend.title = element_blank())\n\n\n\n\nThis sort of pie chart I actually secretly quite like - and it is probably the only one that I would ever willfully make."
  },
  {
    "objectID": "waffle.html",
    "href": "waffle.html",
    "title": "11  Waffle Charts",
    "section": "",
    "text": "Waffle charts are square grid based plots that convert frequencies or proportions to different numbers of squares. These are easier to interpret than their pie chart cousins. Let’s see an example:\nHere we have 7 groups and associated frequencies in each group.\n\nset.seed(10)\nx <- round(runif(7, 1, 100),0)\nnames(x) <- LETTERS[1:7]\n\nx\n\n A  B  C  D  E  F  G \n51 31 43 70  9 23 28 \n\n\nTo make the basic waffle plot, we can just use the function waffle() on a numerical vector:\n\nlibrary(waffle)\nwaffle(x)\n\n\n\n\nIn this default plot, waffle is using one square to represent each value. However, we can control this more effectively. First, we could divide our own vector by 5 such that each square represents 5. We can also specify the number of rows we wish to plot the data on:\n\nwaffle(x/5, rows=6)\n\n\n\n\nDigging into this a bit more. Group A has 10 squares each worth 5 which makes 50. This is 1 less than the 51 in group A. Group E only has one square (worth 5) when it’s value was 9. On the other hand, group G has 5 squares worth 25, when it’s value was 28. So, it can be seen that some artistic license has been made in the creation of the blocks in the waffle chart. This may be problematic in some representations of data, but may be perfectly fine in others. As an aside, I discuss the issues of aportionment (determining how to deal with left overs of fractions when grouping variables) in a blog post here.\nThe function waffle() also has some other functionality such as user-defining the colors to be used and the legend position:\n\nwaffle(x/5, rows = 6,\n       colors = c(\"#f9f988\",\"#f6be68\",\"#e1875e\",\"#ba585c\",\n                           \"#853357\",\"#491b49\",\"#0a0431\"\n       ),\n       legend_pos = \"bottom\")\n\n\n\n\n\n\n11.0.1 geom_waffle()\nThere are a lot of other interesting functionalities in the waffle package. Notably, we can use the function geom_waffle() in conjunction with other ggplot2 functions to create elegant plots. Note, that I have sometimes found that you need to install the developmental version of waffle directly from GitHub to get some of these to work.\n\n#remotes::install_github(\"hrbrmstr/waffle\")\nlibrary(waffle)\n\ninsert waffle examples here -\n-small multiples -alpha transparency -changing borders and sizes\n\n\n\n11.0.2 Combining waffles with pictograms\nSometimes a fun way to represent data in a waffle chart is to use some pictogram instead of a square. Below are a few examples.\nWaffles + Icons\nThere are a few ways to add icons to waffles.\nHere are some data showing the proportion of US people that have different eye colors.\n\neyecolor <- c(45,27,18,9,1)\nnames(eyecolor) <- c(\"Brown\", \"Blue\", \"Hazel\", \"Green\",\"Other\")\n\n\nMaybe include ggwaffle linked here\n\nWaffles + Phylopics\nThe below is an example of using the package rphylopic to use elephant images within a waffle chart. (Need to look up my code for how to do this):\n\n\n\n\n11.0.3 Practical Example - waffle charts\nThis practical example of how to use waffle charts is taken directly from Bob Rudis’s guide on waffle charts. It uses the storms dataset which is available in the dplyr package. It describes the frequencies of different types of storm across different years.\n\nlibrary(tidyverse)\n\nstorms_df <- storms %>%\n  filter(year >= 2010) %>%\n  count(year, status) \n\nstorms_df\n\n# A tibble: 89 x 3\n    year status                     n\n   <dbl> <fct>                  <int>\n 1  2010 disturbance                7\n 2  2010 extratropical             52\n 3  2010 hurricane                163\n 4  2010 other low                152\n 5  2010 subtropical depression     1\n 6  2010 subtropical storm          4\n 7  2010 tropical depression       72\n 8  2010 tropical storm           212\n 9  2011 disturbance               10\n10  2011 extratropical             55\n# ... with 79 more rows\n\n\n\nlibrary(waffle)\nlibrary(ggthemes)\n\nggplot(storms_df, aes(fill = status, values = n)) +\n  geom_waffle(color = \"white\", size = .25, n_rows = 10, flip = TRUE) +\n  facet_wrap(~year, nrow = 1, strip.position = \"bottom\") +\n  scale_x_discrete() +\n  scale_y_continuous(labels = function(x) x * 10, # make this multiplyer the same as n_rows\n                     expand = c(0,0)) +\n  ggthemes::scale_fill_tableau(name=NULL) +\n  coord_equal() +\n  labs(\n    title = \"Faceted Waffle Bar Chart\",\n    subtitle = \"{dplyr} storms data\",\n    x = \"Year\",\n    y = \"Count\"\n  ) +\n  theme_minimal(base_family = \"Roboto Condensed\") +\n  theme(panel.grid = element_blank(), axis.ticks.y = element_line()) +\n  guides(fill = guide_legend(reverse = TRUE))\n\n\n\n\n\nAll of this is to say - just make an actual bar graph/.\nad pie chart example and bar graph improvement.\n\n\n11.0.4 Pie charts with two groups\nThe one exception to the “pie charts are bad” rule may be if we are representing proportions between two groups, especially when we wish to compare across a number of different subjects. For example (include example):"
  }
]