[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PsyDataViz",
    "section": "",
    "text": "Preface\nI am James Curley, Professor in the Psychology Department, UT Austin.\nThis guide to using ggplot2 to make graphs is aimed primarily at Psychology students, but could be used by anyone interested in improving their data visualization skills.\nI have adapted many different visualizations from many different authors. I have tried to acknowledge everyone as I have gone along.\nThe book is very much in progress - I am just adding bits and pieces as I go along. More will be added all the time.\nYou can reach me at curley AT utexas DOT edu."
  },
  {
    "objectID": "intro.html#introduction-to-ggplot2",
    "href": "intro.html#introduction-to-ggplot2",
    "title": "1  Introduction",
    "section": "1.1 Introduction to ggplot2",
    "text": "1.1 Introduction to ggplot2\nThe first thing to do when we want to make a visualization with ggplot2 is to load the tidyverse:\n\nlibrary(tidyverse)\n\nNext, let’s load in some data. We’ll pick the BlueJays.csv data:\n\ndf <- read_csv(\"data_raw/BlueJays.csv\")\nhead(df)\n\n# A tibble: 6 x 9\n  BirdID     KnownSex BillDepth BillWidth BillLength  Head  Mass Skull   Sex\n  <chr>      <chr>        <dbl>     <dbl>      <dbl> <dbl> <dbl> <dbl> <dbl>\n1 0000-00000 M             8.26      9.21       25.9  56.6  73.3  30.7     1\n2 1142-05901 M             8.54      8.76       25.0  56.4  75.1  31.4     1\n3 1142-05905 M             8.39      8.78       26.1  57.3  70.2  31.2     1\n4 1142-05907 F             7.78      9.3        23.5  53.8  65.5  30.3     0\n5 1142-05909 M             8.71      9.84       25.5  57.3  74.9  31.8     1\n6 1142-05911 F             7.28      9.3        22.2  52.2  63.9  30       0\n\n\nIn the next few steps, we’ll slowly build up a plot using ggplot2. This is not how you would typically write the code. However, it is worth going step by step, just to show you the logic behind the code.\nIf we just run the function ggplot() notice that all we get is a blank gray canvas. R knows that we want to make a plot, but it has no idea what type of plot or with what data - so it just throws up the canvas:\n\nggplot()  \n\n\n\n\nNow, if we add the dataset to ggplot(), it still only gives us the blank canvas. It now knows we want to make a graph from the dataset called df but doesn’t plot anything yet as we didn’t tell it what to plot:\n\nggplot(df)   \n\n\n\n\nFor R to ‘know’ what you are trying to plot, you need to use aes(). You put that most of the time inside ggplot() after your dataframe name. (There are exceptions to this, but let’s not worry about that yet). Inside the aes() we’ll put what columns contain our data for the x and y axes. We may also refer to other columns inside aes() if we wish to modify the color or shape or something else about our data based on the values in some column.\nFor our first example, let’s make a scatterplot of body mass against head size of these Blue Jays. If you look at the original dataset, you’ll notice that both the Mass and Head columns contain continuous numeric data (i.e. they are numbers).\nIn the code below, we are telling aes() to plot the Mass data on the x-axis and to plot the Head data on the y-axis.\n\nggplot(df, aes(x=Mass, y=Head) )   \n\n\n\n\nSomething did change this time. We get a plot with labels on the x- and y-axes. It recognizes that we wish to plot Mass and Head data. It even knows the range of our data on each axis. For instance, it knows that the Mass data lies somewhere between 55 and 85. However, we haven’t yet told it precisely what type of plot we want to make (it doesn’t just assume that we wanted to make a scatterplot - it can’t read our minds).\nSo our next step is to tell it to make a scatterplot by adding points to the graph. We tell ggplot() what we are adding to the chart by using different geoms. For a scatterplot, the geom we require is geom_point() - that means add datapoints. It is hard to remember all the different geoms, but you can just look them up.\nHere is how we add datapoints to our graph with + geom_point().\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point()\n\n\n\n\nThat is our first ggplot graph! It looks pretty good. The amazing thing about ggplot is almost everything you are looking at on that graph can be customized to your preferred design choice. We’ll discuss several of these customizations throughout this chapter. First, let’s talk about changing the color of the datapoints. Inside of geom_point() we can change the color of all the points like this:\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point(color=\"red\")\n\n\n\n\nThis made the points red. Just make sure you put a recognized color name (you can look them up here) or a recognized hex code. Notice though that color name must be put inside of quotes.\nWhat if we want to color the points based on another variable? For example, instead of having all of our data points be red, say we want them to be colored based on whether the birds or male or female? The column that has the information about whether the birds are male or female is KnownSex. Because we are basing the color on a column, we put that information inside of aes() with color = KnownSex. We don’t put that inside geom_point(). This code looks like this:\n\nggplot(df, aes(x=Mass, y=Head, color = KnownSex) ) + geom_point() \n\n\n\n\n\n\n1.1.1 Assigning plots\nWhen we make plots, our code can start to get quite long as we make more and more additions or changes to the plot. One very useful thing to know is that we can assign our plot to be an object, just as we would with a vector or a dataframe. For instance, let’s remake the plot above, but this time we’ll assign it the name p. We do that using p <-.\n\np <- ggplot(df, aes(x=Mass, y=Head, color = KnownSex) ) + geom_point() \n\nNow, whenever we type and run p we will get our plot. e.g.\n\np\n\n\n\n\n\n\n\n1.1.2 Titles and Axes Titles\nThe advantage of assigning our plots to a short name, is that we can add things with less code. In R, if we wish to add a title to a plot, we do this with + ggtitle(). So, here is how we add a title to our above plot:\n\np + ggtitle(\"Our first scatterplot\")\n\n\n\n\nThe above plot is basically the same as writing:\n\nggplot(df, aes(x=Mass, y=Head, color = KnownSex) ) + \n  geom_point() +\n  ggtitle(\"Our First Scatterplot\")\n\n\n\n\nYou’ll notice that we are chaining together commands with the +. This is similar to how we chain together commands with the %>% when doing data carpentry. ggplot() instead chains with the +. Again, be careful not to start a row with a +, and you must end a row with a + unless it’s the very last row.\nTo change the title of the x-axis or the y-axis, we use xlab and ylab respectively. We can do it like this:\n\np + xlab(\"Body Mass (g)\") + ylab(\"Head Size (mm)\")\n\n\n\n\n\n\n\n1.1.3 Colors, Shapes and Sizes\nR recognizes many default color names. These can be found at either of these places:\n Color names 1  Color names 2  Or, you can use a hex code \nHere we use the color dodgerblue to change all the points to that color:\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point(color=\"dodgerblue\")\n\n\n\n\nHere we change the points to the color #ababcc using a hexcode - note that hexcodes need to have # in front of them:\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point(color=\"#ababcc\")\n\n\n\n\nYou can also change the shape of the points you plot with geom_point(pch = ). You need to insert the appropriate number according to this guide:\n\nFor example, to have dodgerblue asterisks, we add pch = 8, separating the color and shape commands by a comma:\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point(color=\"dodgerblue\", pch = 8)\n\n\n\n\nFinally, we can change the size of our datapoints (or other shape we choose), using size =:\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point(color=\"purple\", size=2)\n\n\n\n\n\n\n\n1.1.4 Themes\nDefault Themes\nYou may have noticed that every plot we have made so far has the same gray background with faint white gridlines. This is the default setting for the look of ggplot() graphs. There are several other themes that are available to us that change the overall appearance of our plots. Some of these are listed below:\ntheme_bw() a variation on theme_grey() that uses a white background and thin grey grid lines.\ntheme_linedraw() A theme with only black lines of various widths on white backgrounds, reminiscent of a line drawing.\ntheme_light() similar to theme_linedraw() but with light grey lines and axes, to direct more attention towards the data.\ntheme_dark() the dark cousin of theme_light(), with similar line sizes but a dark background. Useful to make thin colored lines pop out.\ntheme_minimal() A minimalistic theme with no background annotations.\ntheme_classic() A classic-looking theme, with x and y axis lines and no gridlines.\ntheme_void() A completely empty theme\nLet’s shows a couple of these different themes. The theme that we use the most in this course is theme_classic(). This is how you would apply this theme to your plot:\n\nggplot(df, aes(x=Mass, y=Head) ) + \n  geom_point() +\n  theme_classic()\n\n\n\n\nIt creates a very sleek simple graph. The downside to this type of graph is that it does get rid of the gridlines which can be helpful sometimes.\nAnother theme that we use often is theme_minimal(). Here is how we would add this:\n\nggplot(df, aes(x=Mass, y=Head) ) + \n  geom_point() +\n  theme_minimal()\n\n\n\n\nThis theme is also simplistic, but has gridlines too.\n\nCustom themes\nRather than changing many different aspects of the graph at once, we can change individual things one by one with theme(). We don’t propose to cover this in more detail in this book - for more information about themes look here - however, here is one quick example.\nLet’s say we wanted to make the panel background light blue instead of gray. We could do it like this:\n\nggplot(df, aes(x=Mass, y=Head) ) + \n  geom_point() +\n  theme(panel.background = element_rect(fill = \"lightblue\"))\n\n\n\n\nAgain, this can get quite complicated - so stick with the default themes if you want to change your plots up a bit, or go to other help guides or later chapters in this book for more fine detail on customization."
  },
  {
    "objectID": "rainclouds.html#basic-raincloud-plots",
    "href": "rainclouds.html#basic-raincloud-plots",
    "title": "6  Rainclouds",
    "section": "6.1 Basic Raincloud plots",
    "text": "6.1 Basic Raincloud plots\nFirst we will look at how to make the clouds. These are effectively density plots.\nThe dataset we will use contains the monthly rainfall levels (in mm) for various Bangladesh cities from 1948-2014. We will filter this dataset to keep data from three cities (Bogra, Chittagong, Rangpur) for the month of June.\n\nlibrary(tidyverse)\n\ndf <- read_csv(\"data_raw/bangladesh.csv\")\n\ndf <- df %>% \n  filter(Station %in% c(\"Bogra\",\"Chittagong\",\"Rangpur\")) %>% \n  filter(Month==6)\n\nhead(df)\n\n# A tibble: 6 x 4\n  Station     Year Month Total\n  <chr>      <dbl> <dbl> <dbl>\n1 Bogra       1948     6    NA\n2 Bogra       1949     6    NA\n3 Chittagong  1949     6   624\n4 Bogra       1950     6   180\n5 Chittagong  1950     6  1676\n6 Bogra       1951     6   351\n\n\nThis plot uses stat_halfeye() to draw the density plots. Associated with each density plot is a point interval summary. The default is the median and interquartile range.\n\nlibrary(ggdist)\n\ndf %>%\n  ggplot(aes(y = Station, x = Total)) +\n  stat_halfeye() +\n  xlab(\"Rainfall (mm)\")+\n  ylab(\"\")+\n  ggtitle(\"Rainfall in June in Selected Bangladesh Cities\")\n\n\n\n\nNext, we will use stat_slabinterval() to show the density plots and summary information. We can dictated which side of the summary information the density plots are shown using the (side=) parameter. This is the basic plot:\n\np = df %>%\n  ggplot(aes(x = Station, y = Total)) +\n  theme(panel.background = element_rect(color = \"grey70\")) +\n  xlab(\"\")+\n  ylab(\"Rainfall (mm)\")\n\n\nThen we can dictate the side. I’m using the grid.arrange() function from the gridExtra package to just show these plots side-by-side.\n\np1 <- p + stat_slabinterval(side = \"left\") +\n  labs(subtitle = \"side = 'left'\")\n\np2 <- p + stat_slabinterval(side = \"both\") +\n  labs(subtitle = \"side = 'both'\")\n\np3 <- p + stat_slabinterval(side = \"right\") +\n  labs(subtitle = \"side = 'right'\")\n\nlibrary(gridExtra)\ngrid.arrange(p1,p2,p3,nrow=1)\n\n\n\n\n\nSometimes when constructing these composite plots we may wish to show the summary information and density plots separate from each other. Or, to be more precise, we may wish to show the summary information for each group next to each other and overlay the density plots. We can do that using stat_slab() and stat_pointinterval(). Using stat_pointinterval() instead of a combined stat_slabinterval() allows us to use position_dodge() on the intervals but not the slabs:\n\ndf %>%\n  ggplot(aes(fill = Station, color = Station, x = Total)) +\n  stat_slab(alpha = .3) +\n  stat_pointinterval(position = position_dodge(width = .4, preserve = \"single\")) +\n  labs(\n    title = \"stat_slab() and stat_pointinterval()\",\n    subtitle = \"with position_dodge() applied to the intervals\",\n    y = NULL,\n    fill = NULL\n  ) +\n  scale_y_continuous(breaks = NULL) +\n  theme_minimal() +\n  scale_color_manual(values=c(\"#a6160c\", \"#c97e55\", \"#e0cb80\"))+\n  scale_fill_manual(values=c(\"#a6160c\", \"#c97e55\", \"#e0cb80\"))"
  },
  {
    "objectID": "rainclouds.html#more-advanced-raincloud-plots",
    "href": "rainclouds.html#more-advanced-raincloud-plots",
    "title": "6  Rainclouds",
    "section": "6.3 More Advanced Raincloud Plots",
    "text": "6.3 More Advanced Raincloud Plots\nThere are some elegant examples of raincloud plots being used to show distribution of data points between groups. The following example was adapted from this blog post. It looks at the variation in weight gain from birth to weaning for four genotypes of lambs from sheep breeds in Kenya. The original data come from the ilri.sheep dataset from the agridat R package.\n\nlibrary(tidyverse)\n\ndf <- agridat::ilri.sheep\n\ndf <- df %>% mutate(birthwt=as.numeric(birthwt),\n                       weanwt=as.numeric(weanwt),\n                       weanage=as.numeric(weanage),\n                       weight_gain_gram=as.numeric(round((((weanwt-birthwt)/weanage)*1000),2),na.rm=T)) %>%\n                 select(lamb, gen, weight_gain_gram)\n\n\nhead(df,10) \n\n   lamb gen weight_gain_gram\n1   627  DD           108.80\n2   629  DD           138.39\n3   635  DD           111.93\n4   636  DD           119.44\n5   638  DD               NA\n6   639  DD            78.50\n7   640  RD           113.08\n8   642  DD               NA\n9   643  DD           142.99\n10  644  DD            83.18\n\n\nWe also use a color palette called SpiritedMedium from the ghibli R package using the scale_fill_ghibli_d() function. This is a blue/brown color palette. The dots are being added to the plot using the stat_dots() function from the ggdist() package. Note that we include outlier.shape=NA inside geom_boxplot() to prevent the outlier dots from being shown twice. binwidth = 1.7 is used to ensure that the dots do not overflow into the distributions of neighboring groups. The half boxplots are being added using the stat_halfeye() function from the same package.\n\n\nlibrary(ghibli)\nggplot(df, aes(x = gen, y = weight_gain_gram, fill=gen)) +\n  geom_boxplot(width = 0.1, outlier.shape=NA) +\n  xlab('Lamb genotype') +\n  ylab('Weight gain, in g/d') +\n  scale_color_ghibli_d(\"SpiritedMedium\") +\n  scale_fill_ghibli_d(\"SpiritedMedium\", direction = -1) +\n  ggtitle(\"Weight gain from birth to weaning in 4 lamb genotypes\") +\n  theme_classic(base_size=16, base_family=\"serif\")+\n  theme(text = element_text(size=16),\n        axis.text.x = element_text(angle=0, hjust=.5, vjust = 0.5, color = \"black\"),\n        axis.text.y = element_text(color = \"black\"),\n        plot.title = element_text(hjust = 0.5),\n        plot.subtitle = element_text(hjust = 0.5),\n        legend.position=\"none\")+\n  scale_y_continuous(breaks = seq(0, 180, by=20), limits=c(0,180), expand = c(0, 0)) +\n  stat_dots(side = \"left\", justification = 1.12, binwidth = 1.7, dotsize=1.35, color=NA) +\n  stat_halfeye(adjust = .5, width = .6, justification = -.2, .width = 0, point_colour = NA)"
  },
  {
    "objectID": "rainclouds.html#basic-raincloud-plots-1",
    "href": "rainclouds.html#basic-raincloud-plots-1",
    "title": "6  Rainclouds",
    "section": "6.2 Basic Raincloud Plots",
    "text": "6.2 Basic Raincloud Plots\nThe key to making a raincloud plot is to separate the plotting of the points and the density plots.\nThis is achieved by using multiple slab geometries together. First, decide which side of the interval to draw the dots. In this example we draw them at the bottom with stat_dotsinterval(side='bottom'). The scale parameter should be adjusted to help avoid overlap of dots and density plots between each group.\nThe density plot part of the figure (the raincloud) is plotted here using stat_slab(). Its thickness is scaled by n (the number of observations in each group). Doing this and setting the scale properly makes the area of each density plot similar in total to its corresponding dotplot.\nThe labs(fill=NULL, y=NULL) just removes the title from the legend which is often unnecessary as well as the y-axis title. We also use theme_ggdist() which is a custom ggplot theme similar to theme_classic().\n\n ggplot(df, aes(y = Station, x = Total, fill = Station)) +\n  stat_slab(aes(thickness = after_stat(pdf*n)), scale = 0.7) +\n  stat_dotsinterval(side = \"bottom\", scale = 0.7, slab_linewidth = NA) +\n  theme_ggdist() +\n  labs(fill=NULL, y=NULL)+\n  xlab(\"Total June Rainfall (mm)\")+\n  scale_color_manual(values=c(\"#a6160c\", \"#c97e55\", \"#e0cb80\"))+\n  scale_fill_manual(values=c(\"#a6160c\", \"#c97e55\", \"#e0cb80\"))"
  }
]