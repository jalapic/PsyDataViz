[
  {
    "objectID": "lollipop.html",
    "href": "lollipop.html",
    "title": "8  Lollipop Plots",
    "section": "",
    "text": "Lollipop plots are a way to represent the same information as bar charts but in a more aesthetically pleasing way. They are comprised of a line and a dot.\nIn ggplot2 we can create them using geom_segment() to create the line and geom_point() to create the dot.\nThe dataset we’ll use in this tutorial is station_usage which provides information on passenger numbers using UK train stations during 2017. We’ll just keep the variables we need and clean up the column names. We also need to edit the Passengers column to ensure it’s numeric after we remove the commas.\n\nrail <- read.csv(\"data_raw/station_usage.csv\")\n\ndf <- rail[c(2:4,15,20)]\ncolnames(df) <- c(\"TLC\",\"Name\",\"Region\",\"Network\",\"Passengers\")\ndf$Passengers <- as.numeric(gsub(\",\",\"\",df$Passengers))\nhead(df)\n\n  TLC       Name        Region            Network Passengers\n1 ABW Abbey Wood        London           Southern    3769402\n2 ABE       Aber Wales - Cymru    Wales & Western     283894\n3 ACY  Abercynon Wales - Cymru    Wales & Western     329532\n4 ABA   Aberdare Wales - Cymru    Wales & Western     581388\n5 ABD   Aberdeen      Scotland Scotland's Railway    2616142\n6 AUR   Aberdour      Scotland Scotland's Railway     140048\n\n\nLet’s say we wished to create a dot plot of the top 10 stations in Scotland for passenger numbers. We can use slice_max() to get the top 10:\n\nlibrary(tidyverse)\n\ntop10 <- df %>% filter(Region==\"Scotland\") %>% slice_max(Passengers, n=10)\ntop10\n\n   TLC                    Name   Region            Network Passengers\n1  GLC         Glasgow Central Scotland Scotland's Railway   32797088\n2  EDB               Edinburgh Scotland Scotland's Railway   23872996\n3  GLQ    Glasgow Queen Street Scotland Scotland's Railway   17207208\n4  PYG  Paisley Gilmour Street Scotland Scotland's Railway    4027962\n5  HYM               Haymarket Scotland Scotland's Railway    3068112\n6  PTK                 Partick Scotland Scotland's Railway    2944084\n7  ABD                Aberdeen Scotland Scotland's Railway    2616142\n8  STG                Stirling Scotland Scotland's Railway    2480154\n9  CHC Charing Cross (Glasgow) Scotland Scotland's Railway    2229356\n10 DEE                  Dundee Scotland Scotland's Railway    2015782\n\n\nTo make our basic lollipop plot with no customization, we need to add a point and a segment. We’ll use the station code rather than the full name for space. With geom_segment() we need to give it’s horizontal width by giving a start and end point for the x-axis, and we do the same on the y-axis for the height.\n\nggplot(top10, aes(x=TLC, y=Passengers)) +\n  geom_point() + \n  geom_segment(aes(x=TLC, xend=TLC, y=0, yend=Passengers))\n\n\n\n\nThe first thing I’d like to do here is reorder the stations so they are not in alphabetical order, but in descending numerical order. We also provide a title on the x-axis:\n\nggplot(top10, aes(x=reorder(TLC,-Passengers), y=Passengers)) +\n  geom_point() + \n  geom_segment(aes(x=TLC, xend=TLC, y=0, yend=Passengers)) +\n  xlab(\"Station\")\n\n\n\n\nWe can customize the colors and sizes of our segment lines and dots. Below, we first factor the TLC column to have the top 10 stations in Passenger order. This is so when we assign the red color and fill (using the brewer.reds palette from the pals package), it plots the colors in the correct order and not in alphabetical order.\n\ntop10$TLC <- factor(top10$TLC, levels = top10 %>% pull(TLC))\n\n\nggplot(top10, aes(x=TLC, y=Passengers, color=TLC, fill=TLC)) +\n  geom_segment(aes(x=TLC, xend=TLC, y=0, yend=Passengers),linewidth=1.5)+\n  geom_point(size=4, stroke=2) +\n  xlab(\"Station\") +\n  scale_color_manual(values = rev(pals::brewer.reds(10))) +\n  scale_fill_manual(values = rev(pals::brewer.reds(10))) \n\n\n\n\nBelow I add some extra customization. We set the theme to be theme_light, remove the legend which is superfluous and tidy up the panel border and x-axis ticks. I also change the y-axis scale to show numbers in millions with the letter “M”. This is using the scales::label_number function (from the scales package).\n\nggplot(top10, aes(x=TLC, y=Passengers, color=TLC, fill=TLC)) +\n  geom_segment(aes(x=TLC, xend=TLC, y=0, yend=Passengers),linewidth=1.5)+\n  geom_point(size=4, stroke=2) +\n  xlab(\"Station\") +\n  scale_color_manual(values = rev(pals::brewer.reds(10))) +\n  scale_fill_manual(values = rev(pals::brewer.reds(10))) +\n  scale_y_continuous(labels = scales::label_number(suffix = \" M\", scale = 1e-6)) +\n  theme_light() +\n  theme(legend.position='none',\n        axis.ticks.x = element_blank(),\n        panel.border = element_blank())\n\n\n\n\n\n\n8.0.1 Lollipop Charts adding Baselines and Highlighting\nSometimes it helps to visualize changes from some baseline level. In the following example, we are going to look at percent changes in rail passengers usage from 2017 compared to the previous year. Below, we grab all the stations in the “East Midlands” region and collect and rename the columns we want. We also ensure that the columns we need to be numeric are:\n\nrr <- rail[rail$Region==\"East Midlands\",]\nrr <- rr[c(2:4,15,20,27)]\ncolnames(rr) <- c(\"TLC\",\"Name\",\"Region\",\"Network\",\"Passengers\",\"PctChange\")\nrr$Passengers <- as.numeric(gsub(\",\",\"\",rr$Passengers))\nrr$PctChange <- as.numeric(gsub(\"%\",\"\",rr$PctChange))\nhead(rr)\n\n    TLC         Name        Region              Network Passengers PctChange\n43  ALF     Alfreton East Midlands              Eastern     314464       5.6\n56  AMB    Ambergate East Midlands              Eastern      41130     -11.6\n60  ANC     Ancaster East Midlands              Eastern       5904     -10.2\n107 ALK    Aslockton East Midlands              Eastern      31204      25.1\n114 ATB Attenborough East Midlands              Eastern      99484      -7.8\n139 BAM      Bamford East Midlands North West & Central      34526       9.1\n\n\nFor the plot, we want to have a new column that will be called UpDown which will depict whether the percent change is positive or negative. Also, we are going to plot stations on the x-axis in their rank order, so we set the levels of the station column TLC to be in the correct order by using arrange and pull.\n\nrr$UpDown <- ifelse(rr$PctChange > 0, \"up\",\"down\")\n\nrr %>% arrange(-Passengers) %>% pull(TLC)\n\n  [1] \"NOT\" \"LEI\" \"DBY\" \"NMP\" \"LCN\" \"CHD\" \"GRA\" \"LBO\" \"GLO\" \"KET\" \"WEL\" \"NNG\"\n [13] \"MHR\" \"NCT\" \"LGE\" \"BEE\" \"RET\" \"WRK\" \"MFT\" \"HDF\" \"NBR\" \"LBK\" \"SMD\" \"EMD\"\n [25] \"SKG\" \"HNK\" \"BUX\" \"ALF\" \"SLR\" \"COR\" \"MMO\" \"OKM\" \"NMN\" \"BSN\" \"SYS\" \"NMC\"\n [37] \"BLP\" \"MAT\" \"HKN\" \"SPK\" \"DRO\" \"SPA\" \"MSW\" \"KKB\" \"HKM\" \"DTG\" \"GBL\" \"WBR\"\n [49] \"ILN\" \"CLY\" \"SIL\" \"CLM\" \"MGM\" \"ATB\" \"EDL\" \"LGM\" \"BWS\" \"SHB\" \"SWS\" \"RKT\"\n [61] \"BIN\" \"KGS\" \"SXY\" \"LOW\" \"TUT\" \"MKR\" \"HOP\" \"DFI\" \"HSG\" \"BLW\" \"CEF\" \"HEC\"\n [73] \"BTF\" \"MTB\" \"GRN\" \"CTO\" \"WFL\" \"CMF\" \"AMB\" \"NSD\" \"CWD\" \"WIL\" \"FSK\" \"SRO\"\n [85] \"BAM\" \"ALK\" \"FNV\" \"WTS\" \"WWL\" \"LAG\" \"SPO\" \"SWD\" \"BUJ\" \"RAU\" \"RDF\" \"NET\"\n [97] \"BSB\" \"ROL\" \"DVH\" \"ANC\" \"SWE\" \"THU\" \"PEA\" \"GNB\" \"HBB\" \"TPC\" \"ELO\" \"HVN\"\n\nrr$TLC <- factor(rr$TLC, levels = rr %>% arrange(-Passengers) %>% pull(TLC))\nrr$Name <- factor(rr$Name, levels = rr %>% arrange(-Passengers) %>% pull(Name))\n\nThe code for the plot is below. geom_segment() and geom_point() are doing the same job as before. Our y-axis ranges from negative values to positive, and 0 is our baseline. So we use y=0 as the baseline value in geom_segment().\n\nggplot(rr,aes(x=Name, y=PctChange,color=UpDown, fill=UpDown)) +\n  geom_segment(aes(x=Name, xend=Name, y=0, yend=PctChange))+\n  geom_point(size=2)+\n  scale_color_manual(values = c(\"#FA8072\",\"darkblue\" )) +\n  scale_fill_manual(values = c( \"#FA8072\",\"darkblue\"))  +\n  xlab(\"Station\") +\n  ylab(\"Percent Change from Previous Year %\") +\n  theme_light() +\n  theme(legend.position='none',\n        axis.ticks.x = element_blank(),\n        panel.border = element_blank(),\n        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1,size=5)) \n\n\n\n\nThe above chart is quite useful for visualizing overall trends quickly, but the plot is quite busy with many individual stations on the x-axis. Without zooming in, it’s hard to identify which stations had the biggest percentage changes. One way to help with this is to use highlighting of the segments and points as well as the axis labels. In this example we do it by using ifelse() logical expressions. This does work, although ggplot2 gives a warning message when using them with the axis.text.x argument. I like to put the logical statements for use inside element_text() outside of the plot as shown below. It is important to ensure that your dataframe is arranged in the same order as your x-axis will be plotted when directly assinging colors, face font or size in this way.\nFor the sake of space, let’s only look at those stations that have more than 250,000 passengers a year, and we’ll highlight stations that gained passengers by 10% or more from the previous year.\n\nrrr <- rr %>% filter(Passengers>250000) %>% arrange(-Passengers)\n\n c1 <- ifelse(rrr$PctChange > 10,\"bold\",\"plain\")\n c2 <- ifelse(rrr$PctChange > 10,12,9)\n c3 <- ifelse(rrr$PctChange > 10,\"#A14A11\",\"grey44\")\n\nggplot(rrr,aes(x=Name, y=PctChange)) +\n  geom_segment(\n    aes(x=Name, \n        xend=Name, \n        y=0, \n        yend=PctChange),\n        color=ifelse(rrr$PctChange > 10, \"darkorange\", \"grey44\"), \n        linewidth=ifelse(rrr$PctChange > 10, 1.5, 1.1)\n    )+\n  geom_point(\n         color=ifelse(rrr$PctChange > 10, \"darkorange\", \"grey44\"), \n         size=ifelse(rrr$PctChange > 10, 5, 2)) +\n  xlab(\"Station\") +\n  ylab(\"Percent Change from Previous Year %\") +\n  geom_hline(yintercept=0, color='gray33')+\n  theme_light() +\n  theme(legend.position='none',\n        axis.ticks.x = element_blank(),\n        panel.border = element_blank(),\n        panel.grid.major.x = element_blank(),\n        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1,\n                                   face=c1,size=c2,color=c3)\n        )"
  },
  {
    "objectID": "labelsig.html#adding-stars-and-p-values-to-plots",
    "href": "labelsig.html#adding-stars-and-p-values-to-plots",
    "title": "10  Labeling Significance",
    "section": "10.1 Adding stars and p-values to plots",
    "text": "10.1 Adding stars and p-values to plots\nProbably the simplest way to add stars and p-values to plots is by using the ggsignif package. This adds an extra layer to each ggplot chart containing the stars.\nHere is some example data with two groups:\n\nset.seed(100)\n\ndf <- data.frame(\n  values = c(rnorm(n=10,mean=4, sd = 0.5), \n             rnorm(n=12,mean=3.4, sd = 0.4)),\n  subject = c(rep(\"Control\",10), rep(\"Treatment\",12))\n)\nhead(df)\n\n    values subject\n1 3.748904 Control\n2 4.065766 Control\n3 3.960541 Control\n4 4.443392 Control\n5 4.058486 Control\n6 4.159315 Control\n\n\nIf we run a simple t-test on these data, we can see that the p-value for this test is 0.0009517.\n\nt.test(data=df, values ~ subject)\n\n\n    Welch Two Sample t-test\n\ndata:  values by subject\nt = 3.8715, df = 19.975, p-value = 0.0009517\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n 0.2316228 0.7728943\nsample estimates:\n  mean in group Control mean in group Treatment \n               3.991021                3.488763 \n\n\nTo make a boxplot with stars, we just add geom_signif() to our plot, but we need to add comparisons = list(c(\"Control\",\"Treatment\")) to tell it which groups we wish to compare.\n\nlibrary(tidyverse)\nlibrary(ggsignif)\n\nggplot(df, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(comparisons = list(c(\"Control\",\"Treatment\")))\n\n\n\n\nHowever, what you may notice is that this p-value is not the same as the one we got from the t-test above. This is because the default test it runs to compare groups is the wilcoxon rank sum test (a non-parametric equivalent to the independent’ t-test that compares medians between independent groups).\n\nggplot(df, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(test = \"wilcox.test\", \n              comparisons = list(c(\"Control\",\"Treatment\")))\n\n\n\n\nTo get the p-value for the t-test we need to assign the test to be the t.test:\n\nggplot(df, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(test = \"t.test\", \n              comparisons = list(c(\"Control\",\"Treatment\")))\n\n\n\n\nIt’s also possible to round numbers to desired decimal places by adding a function within the parameter map_signif_level. Here, I round the p-value to 3 decimal places with round().\n\nggplot(df, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(test = \"t.test\", \n              comparisons = list(c(\"Control\",\"Treatment\")),\n              map_signif_level = function(p) paste(\"p =\",round(p,3)))\n\n\n\n\nWithin this same function, we can actually also annotate text. Here I add “p =” to the beginning of the p-value output on the plot.\n\nggplot(df, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(test = \"t.test\", \n              comparisons = list(c(\"Control\",\"Treatment\")),\n              map_signif_level = function(p) paste(\"p =\",round(p,3)))\n\n\n\n\nThere are several other parameters within geom_signif() that can be tweaked to adjust the font type and position. This is using textsize to adjust the text size.\n\nggplot(df, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(test = \"t.test\", \n              comparisons = list(c(\"Control\",\"Treatment\")),\n              textsize = 5)\n\n\n\n\n\nAdding stars to plots\nTo switch from adding p-values to stars we just need to add map_signif_level = T\n\nggplot(df, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(test = \"t.test\", \n              comparisons = list(c(\"Control\",\"Treatment\")),\n              map_signif_level = T,\n              textsize = 5) +\n  theme_classic()\n\n\n\n\n\nWhat if not significant ?\nIn the data below, we can see that there is no significant difference between our two groups in means.\n\nset.seed(100)\n\nddf <- data.frame(\n  values = c(rnorm(n=10,mean=7.1, sd = 0.5), \n             rnorm(n=12,mean=7.2, sd = 0.4)),\n  subject = c(rep(\"Control\",10), rep(\"Treatment\",12))\n)\n\nt.test(data=ddf, values ~ subject)\n\n\n    Welch Two Sample t-test\n\ndata:  values by subject\nt = -1.5242, df = 19.975, p-value = 0.1431\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -0.46837715  0.07289431\nsample estimates:\n  mean in group Control mean in group Treatment \n               7.091021                7.288763 \n\n\nWhat does this look like if we use geom_signif() to plot ?\n\nggplot(ddf, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(test = \"t.test\", \n              comparisons = list(c(\"Control\",\"Treatment\")),\n              textsize = 5)\n\n\n\n\nThe default plot will add the p-value. If we add map_signif_level = T to plot ‘stars’, we get the following:\n\nggplot(ddf, aes(x=subject, y=values)) +\n  geom_boxplot() +\n  geom_signif(test = \"t.test\", \n              comparisons = list(c(\"Control\",\"Treatment\")),\n              map_signif_level = T,\n              textsize = 5)\n\n\n\n\nFor some reason to me, the dot after NS I find quite irritating. However, this can be all overridden by applying direct annotations (see below).\n\nPaired Data\nThe above examples are all two-tailed independent tests. However, it is possible to apply geom_signif() to one-tailed or paired tests. Let’s create some paired data:\n\nset.seed(103)\n\npdf <- data.frame(\n  subj = letters[1:12],\n  before = runif(12),\n  after = runif(12)\n)\n\npdf\n\n   subj     before     after\n1     a 0.21594161 0.7955919\n2     b 0.06316809 0.8247906\n3     c 0.52182676 0.8830082\n4     d 0.50361726 0.1303339\n5     e 0.12048608 0.1375370\n6     f 0.08727517 0.2851473\n7     g 0.43356197 0.3537884\n8     h 0.19308082 0.3349347\n9     i 0.03108849 0.1756115\n10    j 0.31385192 0.5507040\n11    k 0.45206720 0.5132493\n12    l 0.28632367 0.5776094\n\n\nIf we run a paired t-test on these data we can see a significant difference in means of p=0.04:\n\nt.test(pdf$before, pdf$after, paired=T)\n\n\n    Paired t-test\n\ndata:  pdf$before and pdf$after\nt = -2.2853, df = 11, p-value = 0.04313\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -0.382805290 -0.007197583\nsample estimates:\nmean of the differences \n             -0.1950014 \n\n\nTo make the basic boxplot, we need to turn the data into long form. We also factor the new time column as annoyingly the word ‘after’ is alphabetically earlier than ‘before’ and we want them plotted the opposite way around on the x-axis:\n\npdf.long <- pdf %>% pivot_longer(cols=2:3, names_to = \"time\")\npdf.long$time <- factor(pdf.long$time, levels=c(\"before\",\"after\"))\npdf.long\n\n# A tibble: 24 x 3\n   subj  time    value\n   <chr> <fct>   <dbl>\n 1 a     before 0.216 \n 2 a     after  0.796 \n 3 b     before 0.0632\n 4 b     after  0.825 \n 5 c     before 0.522 \n 6 c     after  0.883 \n 7 d     before 0.504 \n 8 d     after  0.130 \n 9 e     before 0.120 \n10 e     after  0.138 \n# ... with 14 more rows\n\n\nHere is the basic boxplot. I’m using the theme_pubclean() from the ggpubr package:\n\nlibrary(ggpubr)\n\np0 <- ggplot(pdf.long, aes(x=time, y=value)) +\n  geom_boxplot(fill='dodgerblue', alpha=.3) +\n  theme_pubclean() +\n  xlab(\"Time\") +\n  ylab(\"Value\")\n\np0\n\n\n\n\nTo add the p-values for paired data we need to add in extra information related to the test in the test.args() argument. Make sure that the parameters are in a list.\n\np0  +\n    stat_signif(comparisons=list(c(\"before\", \"after\")),\n                test=\"t.test\", \n                test.args=list(alternative = \"two.sided\", \n                               var.equal = FALSE, \n                               paired=T))\n\n\n\n\n… in the above example, we perform a two-tailed paired t-test not assuming equal variances. If we wished to perform a one-tailed t-test, testing if the ‘before’ mean is significantly lower than the ‘after’ group, we can change that in the test.args parameter. Recall, that for a one-sided t-test, the p-value will be half the value of a two-tailed t-test:\n\nt.test(pdf$before, pdf$after, paired=T, alternative = \"less\")\n\n\n    Paired t-test\n\ndata:  pdf$before and pdf$after\nt = -2.2853, df = 11, p-value = 0.02156\nalternative hypothesis: true difference in means is less than 0\n95 percent confidence interval:\n        -Inf -0.04176365\nsample estimates:\nmean of the differences \n             -0.1950014 \n\n\n… and the plot would look as follows:\n\np0  +\n    stat_signif(comparisons=list(c(\"before\", \"after\")),\n                test=\"t.test\", \n                test.args=list(alternative = \"less\", \n                               var.equal = FALSE, \n                               paired=T))\n\n\n\n\nAs before, we can add stars using the map_signif_level = T argument. I also increase the font size using textsize = 7 and reduce the sides of the horizontal bar with tip_length=0. vjust=0.5 pushes the asterisk closer to the horizontal line.\n\n p0  +\n    stat_signif(comparisons=list(c(\"before\", \"after\")),\n                test=\"t.test\", \n                map_signif_level = T,\n                textsize = 7,\n                tip_length = 0,\n                vjust=0.5,\n                test.args=list(alternative = \"less\", \n                               var.equal = FALSE, \n                               paired=T))\n\n\n\n\n\n\n10.1.1 Adding Significance to Multiple Groups\nAdding stars or p-values to plots can also be done when there are more than two groups. Obviously, the more groups that exist, the more potential pairwise comparisons there are. It should be noted that by default, geom_signif() will run pairwise wilcoxon ranked sum tests or independent t-tests on each of hte pairwise comparisons. This may be what you wish to report, but more often we are likely to want to report posthoc comparisons or such like. I personally would still advocate for using the Tukey Significance Letters as shown below. It’s also possible to directly annotate plots ourselves with geom_signif() - see below. But first, let’s look at how it does add these pairwise t-tests p-values to plots.\nHere is some example data with three groups:\n\nset.seed(10)\n\nmdf <- data.frame(\n  values = c(rnorm(n=10,mean=3.8, sd = 0.5), \n             rnorm(n=12,mean=3.1, sd = 0.4),\n             rnorm(n=15, mean=3.5, sd=0.3)),\n  grp = c(rep(\"A\",10), rep(\"B\",12), rep(\"C\",15))\n)\nhead(mdf)\n\n    values grp\n1 3.809373   A\n2 3.707874   A\n3 3.114335   A\n4 3.500416   A\n5 3.947273   A\n6 3.994897   A\n\n\nIf we run a one way ANOVA, with posthoc tests, we can see how the groups differ:\n\nfit <- aov(data = mdf, values ~ grp)\n\nsummary(fit)\n\n            Df Sum Sq Mean Sq F value Pr(>F)  \ngrp          2  0.983  0.4917   4.503 0.0184 *\nResiduals   34  3.713  0.1092                 \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nTukeyHSD(fit)\n\n  Tukey multiple comparisons of means\n    95% family-wise confidence level\n\nFit: aov(formula = values ~ grp, data = mdf)\n\n$grp\n          diff        lwr         upr     p adj\nB-A -0.4241943 -0.7709278 -0.07746088 0.0136482\nC-A -0.2462637 -0.5768611  0.08433364 0.1766410\nC-B  0.1779306 -0.1357016  0.49156280 0.3571951\n\n\nThis might be how we would plot the data in a basic boxplot:\n\npb <- ggplot(mdf, aes(x=grp, y=values, fill=grp)) +\n  geom_boxplot() +\n  scale_fill_manual(values=c(\"#cceeee\", \"#bbebbe\", \"#dddeee\")) +\n  theme_pubclean() +\n  theme(legend.position = 'none') +\n  xlab(\"\") +\n  ylab(\"Values\")\n\npb\n\n\n\n\nWe can add our stars and NS in the same way as before. We just need to put all the relevant comparisons we wish to make in the list, and add step_increase= to make sure that the lines do not overlap each other. Note that the order in which the horizontal lines are added onto the plot are dictated by the order in which they occur in the list.\n\npb +\n  geom_signif(comparisons = list(c(\"A\", \"B\"),\n                                 c(\"A\", \"C\"),\n                                 c(\"B\", \"C\")),\n              test = \"t.test\", \n              step_increase = 0.075,\n              map_signif_level = TRUE, \n              tip_length = 0)\n\n\n\n\nThis way of plotting stars and significance levels is completely functional, however, another options would be to manually add them (see section below). One major advantage of this is that we can plot posthoc tests rather than running t-tests on each comparison.\n\n\n\n10.1.2 Adding stars or p-values manually\nWe can compute the individual p-values separately and then use the annotations parameter to draw them. The code below grabs the p-values for Tukey HSD posthoc comparions between each of the groups from the previous example.\n\npvals <- round(TukeyHSD(fit)$grp[,4],2)\npvals\n\n B-A  C-A  C-B \n0.01 0.18 0.36 \n\n\nWe can add these manually to our plot. The y_position dictates how high up the y-axis each lines goes. The xmin and xmax dictate the start and end point of each horizontal line. Group A starts at 1 on the x-axis, Group B at 2 and Group C at 3.\n\npb + \n  geom_signif(y_position = c(4.1,4.25,4.4), \n              xmin = c(1,1,2), \n              xmax = c(2,3,3), \n              annotation = pvals,\n              tip_length = 0) \n\n\n\n\nInstead of passing a vector of annotations that is an object, you can write your own vector like this:\n\npb + \n  geom_signif(y_position = c(4.1,4.25,4.4), \n              xmin = c(1,1,2), \n              xmax = c(2,3,3), \n              annotation = c(\"p < .05\", \"NS\", \"NS\"),\n              tip_length = 0) \n\n\n\n\nIf you didn’t want to mess around with xmin and xmax, you can pass a list of comparisons. You just need to then supply the annotations and the y_position. Here, I switched up the order in which the lines were drawn:\n\npb +\n  geom_signif(comparisons = list(c(\"A\",\"B\"),\n                                 c(\"B\",\"C\"),\n                                 c(\"A\",\"C\")), \n              y_position = c(4.1,4.25,4.4),\n             annotation = c(\"p < .05\", \"NS\", \"NS\"),\n              tip_length = 0.01)\n\n\n\n\n\n\n\n10.1.3 Adding Significance to Bar graphs\nAdding stars or p-values to bar graphs is the same as with boxplots. We add layers to the plot using geom_signif(). If we produce the bar graph with geom_col() then we are plotting summary information without the underlying raw data, we will need to add information to the graph using annotations.\n\ndat <- data.frame(Group = c(\"G1\",\"G1\",\"G2\",\"G2\"),\n                   Subject = c(\"A\",\"B\",\"A\",\"B\"),\n                   Value = c(3,2,12,17))\n\ndat\n\n  Group Subject Value\n1    G1       A     3\n2    G1       B     2\n3    G2       A    12\n4    G2       B    17\n\n\nThis dataframe just has four rows, with the Value column showing the height of the bar to be plotted. We can plot a bar graph using geom_col() and we include position='dodge' to make a side-by-side bar chart as opposed to a stacked bar chart. I’ve also used the theme_pubclean() from the ggpubr package and set some custom fills. I assign this plot to the object p so we can modify other layers without rewriting the code:\n\np <- ggplot(dat, aes(Group,Value,fill=Subject))+\n  geom_col(position = 'dodge') +\n  theme_pubclean() +\n  scale_fill_manual(values=c(\"#ababde\",\"#123abc\"))\n\np\n\n\n\n\nTo add either stars or p-values we just use geom_signif(). First, we’ll annotate the A vs B comparisons. We dictate the position of the horizontal line we add with xmin and xmax and y_position. The mid-point between the light and dark blue bars are at x=1 for G1 and x=2 for G2. This helps us determine what values to use for xmin and xmax. The values of y_position are picked based on the values of A & B in each group. Using tip_length=0 sets there to be no lines coming down from the edges of the horizontal black lines we add. If we wish to have some of those downward lines, then a really small value like 0.03 would probably be best.\n\np + \n  geom_signif(y_position = c(4,18), \n              xmin = c(0.8,1.8), \n              xmax = c(1.2,2.2), \n              annotation = c(\"NS\",\"**\"),\n              tip_length = 0)\n\n\n\n\nTo add the horizontal black line between our two groups (G1 and G2), we add another geom_signif() layer. Because this is a comparison between the levels of our groups in our original dataframe, we use the comparisons= parameter. That will add the x positions - although it is still possible to do these manually should we wish. We can also set the y_position() ourselves.\n\np + \n  geom_signif(y_position = c(4,18), \n              xmin = c(0.8,1.8), \n              xmax = c(1.2,2.2), \n              annotation = c(\"NS\",\"**\"),\n              tip_length = 0) +\n  geom_signif(comparisons = list(c(\"G1\",\"G2\")), \n              y_position = 21,\n              annotation = \"p < 0.001\",\n              tip_length = 0) \n\n\n\n\nClearly, you wouldn’t mix numerical p-values with stars like this on an actual figure, but for the purpose of illustration, you can write anything you like inside annotation = and it will appear on the plot.\n\n\n\n10.1.4 Adding significance to dynamite plots\nI don’t like dynamite plots. However, it is possible to add these significance annotations to them. It is done in the identical way to the bar charts above. Note how when we add extra annotations, the plot margins automatically adjust, so we don’t need to worry about rescaling the axes.\nLet’s use some example data:\n\ndat1 <- data.frame(Group = c(\"G1\",\"G1\",\"G2\",\"G2\"),\n                   Subject = c(\"A\",\"B\",\"A\",\"B\"),\n                   Mean = c(1.1, 1.4, 2.5, 2.0),\n                   Serr = c(0.1, 0.2, 0.35, 0.3))\n\ndat1\n\n  Group Subject Mean Serr\n1    G1       A  1.1 0.10\n2    G1       B  1.4 0.20\n3    G2       A  2.5 0.35\n4    G2       B  2.0 0.30\n\n\nHere we plot these data in the same manner as with the bar charts above, but we add error bars manually using geom_errorbar() based on the summary data in the dataframe. Note that with these stacked bar charts, we also need to add position=position_dodge(.9) to ensure the error bars stay in the middle of the respective bars.\n\np1 <- ggplot(dat1, aes(x=Group, y=Mean, fill=Subject)) + \n  geom_col(color=\"black\", position=position_dodge()) +\n  scale_fill_manual(values=c('#999999','#E69F00')) +\n  theme_pubclean() +\n  geom_errorbar(aes(ymin = Mean-Serr, \n                    ymax = Mean+Serr), \n                  width=.2,\n                  position=position_dodge(.9)) \n\np1\n\n\n\n\nUsing geom_signif() we manually add the stars and other annotations:\n\np1 + \n  geom_signif(y_position = c(1.75,3.0), \n              xmin = c(0.8,1.8), \n              xmax = c(1.2,2.2), \n              annotation = c(\"*\",\"NS\"),\n              tip_length = 0) \n\n\n\n\n\n\n\n10.1.5 Adding significance to other plots\nWe can add significance labels to other plots that show raw or summary data. Here are two examples - dot plots and strip plots. We’ll use a data set looking at viral load values in subjects under different exposures risks (condition) who are in different treatment groups group.\nLoad in the data:\n\ndf <- read.csv(\"data_raw/viralload.csv\")\nhead(df)\n\n     values subjs group condition\n1  7.824307    s1     B       low\n2  3.921456    s2     B       low\n3 10.001437    s3     C       low\n4  4.035973    s4     A       low\n5  8.886767    s5     B       low\n6  3.003866    s6     B       low\n\n\nDot plots\nTo plot dot plots we need to calculate the summary statistics we wish to plot. Here, I determine the mean and standard deviation of each condition by group. I also refactor the condition variable so that in the plot it will appear in the order high, medium,low.\n\ndf.sum <- df %>%\n  group_by(group, condition) %>%\n  summarise(\n    sd = sd(values),\n    mean = mean(values)\n  )\ndf.sum$condition <- factor(df.sum$condition, levels=c(\"low\",\"medium\",\"high\"))\n\ndf.sum\n\n# A tibble: 12 x 4\n# Groups:   group [4]\n   group condition    sd  mean\n   <chr> <fct>     <dbl> <dbl>\n 1 A     high       6.12 24.4 \n 2 A     low        3.46  6.83\n 3 A     medium     5.00  9.72\n 4 B     high       5.11 16.3 \n 5 B     low        4.48  9.17\n 6 B     medium     6.53  9.65\n 7 C     high       4.92 10.2 \n 8 C     low        3.36  6.46\n 9 C     medium     4.73 13.1 \n10 D     high       9.82 13.2 \n11 D     low        3.90  9.74\n12 D     medium     4.87 11.1 \n\n\nThis is the plot with annotated error bars. Essentially, in geom_signif() we just determine the x and y locations of each thing we wish to plot. Here, I am plotting significance stars to indicate where each condition is significantly different from each other condition in posthoc tests.\n\nggplot(df.sum, aes(x = group, y = mean, color=condition)) +\n  geom_errorbar(\n    aes(ymin = mean-sd, \n        ymax = mean+sd),\n    position = position_dodge(0.3), \n    width = 0.2,\n    linewidth = 1\n  ) +\n  geom_point(size=2,\n             position = position_dodge(0.3)) +\n  scale_color_manual(values = c(\"#bacddd\", \"#E7B800\",\"#bb3300\")) +\n  theme_classic() +\n  coord_flip() +\n  ylab(\"Group\") +\n  xlab(\"Viral Load\") +\n  geom_signif(xmin = c(1,1.1,2,2.1,3),\n              xmax = c(1.1,0.9,2.1,1.9,2.9),\n              y_position = c(32,33.5,23,24.5,19.5),\n              annotation = c(\"***\", \"***\",\"*\", \"**\",\"**\"),\n              tip_length = 0.01,\n              color='black',\n              vjust=0.6)\n\n\n\n\n\nStrip plots\nHere’s another example. This time, we’ll plot the raw data only from group A above in the form of a strip plot. Then we add the stars with geom_signif. We can use comparisons= to do the hard work of determining the x-axis.\n\ndfa <- df %>% filter(group==\"A\")\ndfa$condition <- factor(dfa$condition, levels = c(\"low\",\"medium\",\"high\"))\n\nggplot(dfa, \n       aes(x = condition, y = values, color=condition)) +\ngeom_jitter(width=.085, alpha=.8, size=2) +\n  scale_color_manual(values = c(\"#bacddd\", \"#E7B800\",\"#bb3300\")) +\n  theme_classic() +\n  ylab(\"Viral Load\") +\n  xlab(\"Condition\") +\n  geom_signif(comparisons = list(c(\"low\",\"medium\"),\n                                 c(\"medium\",\"high\"),\n                                 c(\"low\",\"high\")),\n              y_position = c(32,33.5,35),\n              annotation = c(\"NS\",\"***\", \"***\"),\n              tip_length = 0,\n              color='black',\n              step_increase = 0.075,\n              vjust=.3) +\n  theme(legend.position = 'none')\n\n\n\n\n\n\n\n\n10.1.6 Other R packages for adding significance levels\nNot to sidetrack too much, but other R packages also offer the possibility of interfacing with ggplots and adding significance levels. One such example that could be looked at is the ggpubr package, which actually uses geom_signif() in the background but has some nice additional features. I won’t give a full overview of how this package achieves much of what we have shown above - please refer to some of the help guides. However, here are a couple of quick examples.\nLet’s use the dataset mdf which has two columns: values and group. There are three groups in this dataset.\n\nhead(mdf)\n\n    values grp\n1 3.809373   A\n2 3.707874   A\n3 3.114335   A\n4 3.500416   A\n5 3.947273   A\n6 3.994897   A\n\n\nThis is the plot we previously made:\n\npb\n\n\n\n\nThe syntax to add p-values is with stat_compare_means() in a very similar way to geom_signif(). Note we can also add the p-value from the One-Way ANVOA directly onto the plot here also, if we wish:\n\nlibrary(ggpubr)\n\npb +  \n  stat_compare_means(method = \"anova\", label.y = 5)+\n  stat_compare_means(comparisons = list(c(\"A\",\"B\"),\n                                        c(\"B\",\"C\"),\n                                        c(\"A\",\"C\")), \n                     method = \"t.test\", \n                     label.y = c(4.15,4.3,4.45)\n  )\n\n\n\n\nA nice feature of this package is the ability to compare individual groups to a reference group or control. Let’s create some data to do this:\n\nset.seed(15)\nxdf <- data.frame(\n  values = c(\nrnorm(n = 20, mean = 0, sd = .4),\nrnorm(n = 20, mean = 0.3, sd = .7),\nrnorm(n = 20, mean = 0.6, sd = .15),\nrnorm(n = 20, mean = 0.2, sd = .4),\nrnorm(n = 20, mean = 0.4, sd = .4),\nrnorm(n = 20, mean = 0.7, sd = .5)\n),\ngroups = rep(LETTERS[1:6],each=20)\n)\n\nhead(xdf)\n\n      values groups\n1  0.1035291      A\n2  0.7324483      A\n3 -0.1358474      A\n4  0.3588793      A\n5  0.1952065      A\n6 -0.5021543      A\n\n\nThese data could be plotted as follows. I’m using the brewer.greens color palette from the pals package.:\n\npg <- ggplot(xdf, aes(x=groups, y=values, fill=groups)) +\n  geom_boxplot() +\n  scale_fill_manual(values=pals::brewer.greens(6)) +\n  theme_pubclean() +\n  theme(legend.position = 'none') +\n  xlab(\"\") +\n  ylab(\"Values\") \n\npg\n\n\n\n\nBelow, using ref.group=\"A\" we run independent t-tests comparing each group to A. Instead of notating p-values here, we use asterisks by including a label= option.\n\nmaxvals <- xdf %>% \n  group_by(groups) %>% \n  summarise(maxval = max(values)) %>% \n  pull(maxval) \n\npg +  \n  stat_compare_means(aes(label = after_stat(p.signif)),\n                   method = \"t.test\", ref.group = \"A\"\n                   )"
  },
  {
    "objectID": "labelsig.html#adding-tukeys-significance-letters",
    "href": "labelsig.html#adding-tukeys-significance-letters",
    "title": "10  Labeling Significance",
    "section": "10.2 Adding Tukey’s Significance Letters",
    "text": "10.2 Adding Tukey’s Significance Letters\nRather than denoting pairwise comparisons with stars or p-values, I prefer to use letter notation. Letters that are the same between two groups indicate no significant differences between those groups. Letters that differ between two groups indicate that those groups have significant differencess.\n\nOne-Way ANOVA example\nLet’s create some random data. We’ll make a dataframe of six groups.\n\nset.seed(10)\ndf <- data.frame(\n  value = c(rnorm(n = 10, mean = 10, sd = 1.8),\n            rnorm(n = 12, mean = 11, sd = 1.0),\n            rnorm(n = 14, mean = 13, sd = 1.1),\n            rnorm(n = 16, mean = 15, sd = 1.2),\n            rnorm(n = 12, mean = 14, sd = 2.2),\n            rnorm(n = 10, mean = 10, sd = 1.0)),\n  categ = c(rep(\"A\",10), rep(\"B\",12), rep(\"C\",14), \n          rep(\"D\",16), rep(\"E\",12), rep(\"F\",10)\n          )\n)\n\nhead(df)\n\n      value categ\n1 10.033743     A\n2  9.668345     A\n3  7.531605     A\n4  8.921498     A\n5 10.530181     A\n6 10.701630     A\n\n\nWe can plot the basic boxplot of these data like this:\n\nggplot(df, aes(x=categ, y=value)) +\n  geom_boxplot() +\n  theme_classic()\n\n\n\n\nTo compare significance differences between groups, we could run Tukey post-hoc tests using Honestly Signficant Differences. This is done using the TukeyHSD() function in base R, but using the HSD.test() function from the agricolae R package, we can get the letter notation we need directly.\nThis code runs the post hoc test and the groups part of it gives us the letter notations we need:\n\nlibrary(agricolae)\n\nhsd <- HSD.test(aov(value ~ categ, data=df), \"categ\", group=T)\nhsd\n\n$statistics\n   MSerror Df     Mean       CV\n  1.624327 68 12.19191 10.45357\n\n$parameters\n   test name.t ntr StudentizedRange alpha\n  Tukey  categ   6         4.147238  0.05\n\n$means\n      value       std  r       Min      Max       Q25       Q50       Q75\nA  9.116818 1.2598083 10  7.071989 10.70163  8.099472  9.441861  9.942394\nB 11.076193 0.9758832 12  8.814713 12.10178 10.672247 11.286163 11.798216\nC 12.218867 0.9310972 14 10.669033 14.06542 11.513617 12.250668 12.846258\nD 14.710048 0.8877416 16 12.889096 16.30386 14.161383 14.604540 15.317899\nE 14.346442 2.2162032 12 11.277292 18.70309 12.477597 14.694213 15.311768\nF  9.953696 0.9761422 10  8.569573 11.21613  9.093364 10.081209 10.692454\n\n$comparison\nNULL\n\n$groups\n      value groups\nD 14.710048      a\nE 14.346442      a\nC 12.218867      b\nB 11.076193     bc\nF  9.953696     cd\nA  9.116818      d\n\nattr(,\"class\")\n[1] \"group\"\n\n\nTo add these letters on to the plot, we need to decide where to put them. The x coordinate will be the mid point of each category (which can just be the name of the group), and the y coordinate will be above the maximum value of that group. But note that the groups in the summary output are reorganized from highest median value to lowest. I find it easiest to add these to our summary output in the appropriate order.\n\ndf.sum <- df %>% \n  group_by(categ) %>% \n  summarize(maxval = max(value), \n            med = median(value),\n            uq = quantile(value, .75)) %>% \n  arrange(-med)\n\ndf.sum$letters <- hsd$groups$groups\n\ndf.sum\n\n# A tibble: 6 x 5\n  categ maxval   med    uq letters\n  <chr>  <dbl> <dbl> <dbl> <chr>  \n1 E       18.7 14.7  15.3  a      \n2 D       16.3 14.6  15.3  a      \n3 C       14.1 12.3  12.8  b      \n4 B       12.1 11.3  11.8  bc     \n5 F       11.2 10.1  10.7  cd     \n6 A       10.7  9.44  9.94 d      \n\n\nThis code plots the letters above the boxplots at a y coordinate 0.2 higher than the max value.\n\nggplot(df,aes(x=categ,y=value))+\n  geom_boxplot()+\n  geom_text(data=df.sum,\n            aes(x=categ,y=0.2+maxval,\n                label=letters)) +\n  theme_classic() +\n  xlab(\"Category\")\n\n\n\n\nIn the above plot, we can see that Group B is not significantly different from Group C or Group F (because both share the b and c letter, but is significantly different from the other groups. Groups D and E are not significantly different from each other (they both have an a) but are significantly different from all other groups.\nWe should reorder the plot though to make it more readable:\n\nggplot(df,aes(x=reorder(categ,-value,median),y=value))+\n  geom_boxplot()+\n  geom_text(data=df.sum,\n            aes(x=categ,y=0.2+maxval,\n                label=letters)) +\n  theme_classic() +\n  xlab(\"Category\")\n\n\n\n\nWe can nudge the letters up a bit using vjust=0:\n\nggplot(df,aes(x=reorder(categ,-value,median),y=value))+\n  geom_boxplot()+\n  geom_text(data=df.sum,\n            aes(x=categ,y=0.2+maxval,\n                label=letters), vjust=0) +\n  theme_classic() +\n  xlab(\"Category\")\n\n\n\n\nAlternatively, you may wish to plot the letters to the side of the upper quartile. I don’t like this very much, but it’s an option. I also make the letters bold in this example using fontface=\"bold\".\n\nggplot(df,aes(x=reorder(categ,-value,median),y=value))+\n  geom_boxplot()+\n  geom_text(data=df.sum,\n            aes(x=categ,y=uq,\n                label=letters,\n                hjust = -1, \n                vjust = -0.8, \n                fontface = \"bold\")) +\n  theme_classic() +\n  xlab(\"Category\")\n\n\n\n\nJust for fun, here I’m including aes(fill = factor(..middle..))) and scale_fill_brewer(palette = \"Reds\") to make the colors of the boxplots a shade of red that is equivalent to their categorical position.\n\nggplot(df,aes(x=reorder(categ,-value,median),y=value))+\n  geom_boxplot(aes(fill = factor(..middle..)))+\n  geom_text(data=df.sum,\n            aes(x=categ,y=0.2+maxval,\n                label=letters), vjust=0) +\n  theme_classic() +\n  xlab(\"Category\") +\n  scale_fill_brewer(palette = \"Reds\") +\n  theme(legend.position = 'none')\n\n\n\n\nThis approach using geom_text() to add letters to a plot can be modified for any statistical test."
  }
]