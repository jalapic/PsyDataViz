[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PsyDataViz",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.\nMaybe I should add a pretty picture in here ?"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code. Adding something to check.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "heatmaps.html",
    "href": "heatmaps.html",
    "title": "2  Heatmaps",
    "section": "",
    "text": "Heatmaps are generated by filling in the cells of a grid with a color gradient or palette. In ggplot2 the function to use is geom_tile() to achieve this effect.\n\n\n2.0.1 Example 1 -Categorical axes\nHere, we have a dataset where we have three columns. The first column represents categorical variables (A to E) that will go on the bottom x-axis. The second column represents categorical variables (A to E) that will go on the y-axis. We have one row for every possible combination, so in this case we have 25 rows. The third column contains the value that we wish to represent by the fill color in the tile of the heatmap. I am using random values between 1 and 100 for this. The higher the value, the deeper the color we will use.\n\nset.seed(101)\nn <- 5\ndf <- data.frame(Var1=rep(LETTERS[1:n],n),\n                 Var2=rep(LETTERS[1:n],each=n),\n                 Value=sample(1:100, replace=T, n*n)\n)\nhead(df)\n\n  Var1 Var2 Value\n1    A    A    73\n2    B    A    57\n3    C    A    46\n4    D    A    95\n5    E    A    81\n6    A    B    58\n\n\nBelow, we will plot the heatmap without adding any stylistic elements.\n\n\n\n\nlibrary(tidyverse)\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile() \n\n\n\n\nAs can be seen, each cell (or tile) has a different degree of color fill based on it’s cell value in the Value column of the dataframe df. Brighter and lighter colors represent higher values of the Value column.\nA first step to make this prettier may be to add boundaries between the cells. This can be done by adding a linewidth and a color of this line as follows:\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75)\n\n\n\n\nThis looks nicer. Another thing that bugs me is that the default is to produce rectangular cells rather than square cells. This can be fixed by adding coord_equal().\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal()\n\n\n\n\nA next step that I often to is to add the following code to ensure that my cells are centered above each label. In this case, this doesn’t seem to change very much, but I have found it to be useful occasionally:\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) \n\n\n\n\nThe next thing that bugs me about this heatmap is that the default color gradient isn’t particularly intuitive to me. I’d rather my values go from a light color (low values) to a darker color (high values). To do this, we can state a low and high color value within scale_fill_continuous(). Here, we go from a very light to a darker purple color.\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\")\n\n\n\n\nNext, I find the axes labels and tick marks annoying, so I can remove these using xlab(\"\"), ylab(\"\"), and axis.ticks() inside theme(). I also increase the size of the labels on the axes.\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2))\n  )\n\n\n\n\nFinally, I’d rather my legend be on the bottom of the heatmap, and we don’t need the label on the legend. This can also be fixed within the theme() argument:\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  ) \n\n\n\n\nAs a quick aside - what happens if we have missing values in our Value column? Let’s introduce five random NA values into that column:\n\ndf$Value[sample(1:25,5)]<-NA\nhead(df)\n\n  Var1 Var2 Value\n1    A    A    NA\n2    B    A    57\n3    C    A    46\n4    D    A    95\n5    E    A    81\n6    A    B    NA\n\n\nNow we can plot with the same code as above:\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  ) \n\n\n\n\nWhat happens is that these default to a dark-greyish beige color, as seen above. In some circumstances, this color fill will be fine. However, in other situations we might want to dictate the color. Here, we make those NA cells white by adding na.value = \"white\" inside our scale_fill_continuous() .\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\", na.value = \"white\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  )\n\n\n\n\n\n\n\n2.0.2 Example 2 - Discrete numerical axes.\nAxes don’t have to be categorical. You can use discrete numbers also. They will be plotted in numerical order. Here we produce an example of a matrix which is 56 columns wide and 4 rows tall.\n\nset.seed(101)\ndf1 <- data.frame(Var1=rep(1:6,4),\n                 Var2=rep(1:4,each=6),\n                 Value=sample(1:100, replace=T, 24)\n)\nhead(df1)\n\n  Var1 Var2 Value\n1    1    1    73\n2    2    1    57\n3    3    1    46\n4    4    1    95\n5    5    1    81\n6    6    1    58\n\n\nUsing the same code as above - just changing the colors to a green palette:\n\nggplot(df1, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#ddead1\", high=\"#378805\", na.value = \"white\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  )\n\n\n\n\nNote that numeric values don’t show automatically here. This is because of the scale_x_discrete() and scale_y_discrete() lines. We can add the numeric labels by using the continuous scales instead and dictating what the breaks should be if required:\n\nggplot(df1, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_continuous(expand = c(0, 0), breaks=1:6) +\n  scale_y_continuous(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#ddead1\", high=\"#378805\", na.value = \"white\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  )\n\n\n\n\n\n\n\n2.0.3 Example 3: Correlation Matrices\nA common usage of heatmaps is to illustrate the correlations between a set of continuous variables.\nFirst, we should look at some data. Let’s import the dataset cordata.csv from our folder data_raw. This dataset contains eight continuous variables, boringly named V1, V2,…… V8.\n\ncd <- read.csv(\"data_raw/cordata.csv\")\nhead(cd)\n\n    V1    V2     V3     V4    V5     V6    V7   V8\n1 7.07 34.18 179.62 141.72 14.24 113.47 15.83 1.59\n2 7.43 43.51 107.77 111.40 10.86 139.11 16.76 0.00\n3 1.75  4.74 224.06 113.71 10.65 102.81 22.50 7.29\n4 0.68 16.75  20.00 101.66 16.48 127.23 22.12 5.36\n5 3.15 19.81 251.27 144.41 10.08 125.46 22.34 7.73\n6 3.60 27.98 233.61 137.11 10.02 156.36 24.18 2.18\n\n\nA quick way to get all the correlations between continuous variables in a data.frame is to use cor(). I’m surrounding this function with round() to make the output more easy to read:\n\ncdmat <- round(cor(cd),2)\ncdmat\n\n      V1    V2    V3    V4    V5    V6    V7    V8\nV1  1.00  0.87 -0.26 -0.02  0.15  0.19 -0.75 -0.79\nV2  0.87  1.00 -0.33 -0.15  0.15  0.17 -0.74 -0.92\nV3 -0.26 -0.33  1.00  0.34 -0.81 -0.25  0.44  0.38\nV4 -0.02 -0.15  0.34  1.00 -0.03  0.40  0.03  0.26\nV5  0.15  0.15 -0.81 -0.03  1.00  0.33 -0.30 -0.23\nV6  0.19  0.17 -0.25  0.40  0.33  1.00 -0.39 -0.08\nV7 -0.75 -0.74  0.44  0.03 -0.30 -0.39  1.00  0.64\nV8 -0.79 -0.92  0.38  0.26 -0.23 -0.08  0.64  1.00\n\n\nThis matrix is essentially what we want to plot, however, to do that, we first need to turn it into a dataframe with three columns. The first two being the row and column of the eventual plot and the third being the fill value (the correlation coeffecient). We can melt() the matrix into that dataframe:\n\ncdmat.df <- reshape2::melt(cdmat)\nhead(cdmat.df)\n\n  Var1 Var2 value\n1   V1   V1  1.00\n2   V2   V1  0.87\n3   V3   V1 -0.26\n4   V4   V1 -0.02\n5   V5   V1  0.15\n6   V6   V1  0.19\n\n\nLet’s plot this long data using similar code to above. However, here I’m using scale_fill_gradient2() to set low, mid and high colors at Pearson correlations of -1, 0 and +1 respectively:\n\nggplot(cdmat.df, aes(Var1, Var2, fill = value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_gradient2(low = \"blue\", high = \"red\", mid = \"white\", \n                       midpoint = 0, limit = c(-1,1), space = \"Lab\", \n                       name=\"Pearson's r\")  +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.0)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\"\n  )\n\n\n\n\nThere are three problems with this matrix. First, who cares that the diagonals are all r=1. We don’t need that information. Second, correlation matrices have symmetry along the axis, and so we could just plot either the upper or lower triangle of the matrix. Third, these variables could be reordered to make the relationships between variables be more intuitive.\nLet’s get rid of the diagonal and only keep the lower triangle. We can use the functions diag() and upper.tri() to make the diagonal and top triangle of the matrix NA. Then we melt the matrix again:\n\ndiag(cdmat)<-NA\ncdmat[upper.tri(cdmat)]<-NA\ncdmat\n\n      V1    V2    V3    V4    V5    V6   V7 V8\nV1    NA    NA    NA    NA    NA    NA   NA NA\nV2  0.87    NA    NA    NA    NA    NA   NA NA\nV3 -0.26 -0.33    NA    NA    NA    NA   NA NA\nV4 -0.02 -0.15  0.34    NA    NA    NA   NA NA\nV5  0.15  0.15 -0.81 -0.03    NA    NA   NA NA\nV6  0.19  0.17 -0.25  0.40  0.33    NA   NA NA\nV7 -0.75 -0.74  0.44  0.03 -0.30 -0.39   NA NA\nV8 -0.79 -0.92  0.38  0.26 -0.23 -0.08 0.64 NA\n\n\n\ncdlt.df <- reshape2::melt(cdmat)\nhead(cdlt.df)\n\n  Var1 Var2 value\n1   V1   V1    NA\n2   V2   V1  0.87\n3   V3   V1 -0.26\n4   V4   V1 -0.02\n5   V5   V1  0.15\n6   V6   V1  0.19\n\n\nWe can plot this in the same way as before but adding na.value=\"white\" inside the scale_fill_gradient2() to white out the NA values, leaving the bottom of the matrix.\n\nggplot(cdlt.df, aes(Var1, Var2, fill = value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_gradient2(low = \"blue\", high = \"red\", mid = \"white\",\n                       na.value=\"white\",\n                       midpoint = 0, limit = c(-1,1), space = \"Lab\", \n                       name=\"Pearson's r\")  +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.0)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\"\n  )\n\n\n\n\nTo reorder the matrix, we first need to recreate our original correlation matrix.\n\ncdmat1 <- round(cor(cd),2)\ncdmat1\n\n      V1    V2    V3    V4    V5    V6    V7    V8\nV1  1.00  0.87 -0.26 -0.02  0.15  0.19 -0.75 -0.79\nV2  0.87  1.00 -0.33 -0.15  0.15  0.17 -0.74 -0.92\nV3 -0.26 -0.33  1.00  0.34 -0.81 -0.25  0.44  0.38\nV4 -0.02 -0.15  0.34  1.00 -0.03  0.40  0.03  0.26\nV5  0.15  0.15 -0.81 -0.03  1.00  0.33 -0.30 -0.23\nV6  0.19  0.17 -0.25  0.40  0.33  1.00 -0.39 -0.08\nV7 -0.75 -0.74  0.44  0.03 -0.30 -0.39  1.00  0.64\nV8 -0.79 -0.92  0.38  0.26 -0.23 -0.08  0.64  1.00\n\n\nNext, we can use a clustering method such as hierarchical clustering to identify the relationships between each variable:\n\ndd <- as.dist((1-cdmat1)/2)\nhc <- hclust(dd)\ncdmat1 <-cdmat1[hc$order, hc$order]\ncdmat1\n\n      V3    V7    V8    V4    V6    V5    V1    V2\nV3  1.00  0.44  0.38  0.34 -0.25 -0.81 -0.26 -0.33\nV7  0.44  1.00  0.64  0.03 -0.39 -0.30 -0.75 -0.74\nV8  0.38  0.64  1.00  0.26 -0.08 -0.23 -0.79 -0.92\nV4  0.34  0.03  0.26  1.00  0.40 -0.03 -0.02 -0.15\nV6 -0.25 -0.39 -0.08  0.40  1.00  0.33  0.19  0.17\nV5 -0.81 -0.30 -0.23 -0.03  0.33  1.00  0.15  0.15\nV1 -0.26 -0.75 -0.79 -0.02  0.19  0.15  1.00  0.87\nV2 -0.33 -0.74 -0.92 -0.15  0.17  0.15  0.87  1.00\n\n\nWe then do the same process of adding NA to the diagonal and upper triangle of the matrix, and we can plot:\n\ndiag(cdmat1)<-NA\ncdmat1[upper.tri(cdmat1)]<-NA\ncdlt1.df <- reshape2::melt(cdmat1)\n\nggplot(cdlt1.df, aes(Var1, Var2, fill = value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_gradient2(low = \"blue\", high = \"red\", mid = \"white\",\n                       na.value=\"white\",\n                       midpoint = 0, limit = c(-1,1), space = \"Lab\", \n                       name=\"Pearson's r\")  +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.0)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\"\n  )\n\n\n\n\nOne final step that we might want to do is to add the actual correlations over the top of the colored cells. We can add this with geom_text().\n\nggplot(cdlt1.df, aes(Var1, Var2, fill = value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  geom_text(aes(Var1, Var2, label = value), color = \"black\", size = 3.5) +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_gradient2(low = \"blue\", high = \"red\", mid = \"white\",\n                       na.value=\"white\",\n                       midpoint = 0, limit = c(-1,1), space = \"Lab\", \n                       name=\"Pearson's r\")  +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.0)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\"\n  ) \n\n\n\n\n\n\n\n\n2.0.4 Some practical examples\nBelow are some well known examples of using geom_tile() to create heatmaps examining trends in the prevalence of diseseas over time. First, we’ll look at the effect of birth month on risk of developing schizophrenia in an Australian cohort. This is using the schz dataset from the season R package:\n\nschz <- read.csv(\"data_raw/schz.csv\")\nhead(schz)\n\n  year month    yrmon NBirths SczBroad  SOI\n1 1930     1 1930.000    1578        8 12.7\n2 1930     2 1930.083    1519       11  7.7\n3 1930     3 1930.167    1630       15  1.8\n4 1930     4 1930.250    1607       12 -3.8\n5 1930     5 1930.333    1566       10  2.1\n6 1930     6 1930.417    1491        8 -5.5\n\nrange(schz$year)\n\n[1] 1930 1971\n\n\nEach row of this dataset contains information on the incidence of schizophrenia for individuals born for each month of the year between 1930-1971. We use the column SczBroad as a measure of schizophrenia risk at each timepoint.\nWe plot the data below using similar code to above. In addition, we are using scale_fill_viridis() from the viridis R package to fill our tiles from a gradient of dark purple (low risk) to bright yellow (high risk). We are using option D, one of four colorblind friendly palettes available in this package. Within theme() most of the lines are making the background panel and borders a dark gray color (gray10), and adjusting the placement of text labels.\n\nlibrary(viridis)\n\nLoading required package: viridisLite\n\nggplot(schz, aes(year, month, fill = SczBroad)) + \n  geom_tile(colour=\"gray10\", linewidth=1.1) + \n  coord_equal() +\n  scale_fill_viridis(option=\"D\",na.value = \"gray10\") +\n  scale_y_continuous(breaks=1:12, labels=month.abb[1:12])+\n  xlab(\"\") + \n  ylab(\"\") +\n  ggtitle(\"Schizophrenia Risk By Birth Month and Year in Australia\") +\n  theme(\n    plot.title = element_text(color=\"white\",hjust=0,vjust=1, size=rel(1.3)),\n    plot.background = element_rect(fill=\"gray10\"),\n    panel.background = element_rect(fill=\"gray10\"),\n    panel.border = element_rect(fill=NA,color=\"gray10\", linewidth = 0.5, linetype=\"solid\"),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    axis.line = element_blank(),\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"white\", size=rel(0.8)),\n    axis.text.y  = element_text(hjust=1, margin = margin(r = -20)),\n    legend.text = element_text(color=\"white\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"gray10\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  )\n\n\n\n\n\nIn the next example, we are looking at the effect of the introduction of vaccinations on the prevalence of measles in the USA. The data are in the diseases.csv dataset. I’ve based this on code from this blog post.\n\ndis <- read.csv(\"data_raw/diseases.csv\")\nhead(dis)\n\n      disease   state year weeks_reporting count population\n1 Hepatitis A Alabama 1966              50   321    3345787\n2 Hepatitis A Alabama 1967              49   291    3364130\n3 Hepatitis A Alabama 1968              52   314    3386068\n4 Hepatitis A Alabama 1969              49   380    3412450\n5 Hepatitis A Alabama 1970              51   413    3444165\n6 Hepatitis A Alabama 1971              51   378    3481798\n\n\nThe dataset contains the total number of cases reported by each state for each disease for each year between 1928-2011. It should be noted that not all states start at the same time point. As can be seen above, Alabama’s Hepatitis reporting starts in 1966. In total, there are data on 7 different diseases, but we’ll just look at measles.\n\ntable(dis$disease)\n\n\nHepatitis A     Measles       Mumps   Pertussis       Polio     Rubella \n       2346        3876        1836        3774        3774        1938 \n   Smallpox \n       1326 \n\n\nTo compare across years and states, we need to make our data more uniform. One way is to look at the number of cases per e.g. 100,000 people. However, this is complicated by the issue that the data don’t come from full years but from different number of weeks within a year. So first, we should get a “per week” count for each disease in each state and then multiply by 52 to get a “per year” count. Then we can divide this by the population of the state in that year and multiply that by 100,000 to get an incidence per 100k people:\n\ndis.sum <- dis %>%\n  group_by(state,disease,year) %>%\n  summarise(peryear = 52*(count/weeks_reporting),\n            per100k = 100000*(peryear/population))\n\nhead(dis.sum)\n\n# A tibble: 6 x 5\n# Groups:   state, disease [1]\n  state   disease      year peryear per100k\n  <chr>   <chr>       <int>   <dbl>   <dbl>\n1 Alabama Hepatitis A  1966    334.    9.98\n2 Alabama Hepatitis A  1967    309.    9.18\n3 Alabama Hepatitis A  1968    314     9.27\n4 Alabama Hepatitis A  1969    403.   11.8 \n5 Alabama Hepatitis A  1970    421.   12.2 \n6 Alabama Hepatitis A  1971    385.   11.1 \n\n\nLet’s focus on Hepatitis A. Before plotting we will do two additional data carpentry steps. We will first reverse the order of the levels of the factor state. The default way to plot these states will be in alphabetical order along the y-axis starting with Alabama closest to the x-axis and Wyoming the furthest away. However, this is annoying to read as we are used to seeing A’s at the top and W’s near the bottom of a list of states. Second, rather than filling the tiles in a continuous gradient, we will create 7 discrete bins of color. These bins are not equivalent in terms of size which does somewhat break the rules of data visualization - i.e. an equal step in color gradient should map to an equal step in value. However, I think it can be justified in this context as we are interested in picking out “very low”, “low”, “medium”, “high”, “very high” number of cases etc. This new variable will be called countfactor.\n\nmeas <- dis.sum %>% filter(disease==\"Measles\") %>%\n        mutate(countfactor=cut(per100k, breaks=c(-1, 0, 1, 10, 100, 500, 1000, max(per100k, na.rm=T)),labels=c(\"0\", \"0-1\", \"1-10\", \"10-100\", \"100-500\", \"500-1000\", \">1000\"))) %>%\n  mutate(countfactor=factor(as.character(countfactor), levels=rev(levels(countfactor))))\n\nmeas$state <- factor(meas$state, levels = rev(unique(meas$state)))\n\nhead(meas)\n\n# A tibble: 6 x 6\n# Groups:   state, disease [1]\n  state   disease  year peryear per100k countfactor\n  <fct>   <chr>   <int>   <dbl>   <dbl> <fct>      \n1 Alabama Measles  1928   8843    341.  100-500    \n2 Alabama Measles  1929   3140.   120.  100-500    \n3 Alabama Measles  1930   4156    157.  100-500    \n4 Alabama Measles  1931   9481.   355.  100-500    \n5 Alabama Measles  1932    342.    12.7 10-100     \n6 Alabama Measles  1933   1769.    65.2 10-100     \n\n\nBelow we plot the data using geom_tile(). We use scale_fill_manual() with 7 colors that we pick ourselves to represent the 7 categories. Inside theme() we control the sizes and colors of text and the background colors. We also use coord_cartesian(), geom_vline() and annotate() to add the black line at 1963 and associate text to indicate when the vaccine was introduced.\n\n# assign text color\ntextcol <- \"grey40\"\n\np <- ggplot(meas, aes(x=year, y=state, fill=countfactor))+\n  geom_tile(color=\"white\", linewidth=0.2)+\n  guides(fill=guide_legend(title=\"Cases per\\n100,000 people\"))+\n  labs(x=\"\", y=\"\", title=\"Incidence of Measles in the US\")+\n  scale_y_discrete(expand=c(0, 0))+\n  scale_x_continuous(expand=c(0, 0), breaks=seq(1930,2000,10))+\n  scale_fill_manual(values=c(\"#d53e4f\", \"#f46d43\", \"#fdae61\", \"#fee08b\", \"#e6f598\", \"#abdda4\", \"#ddf1da\"), na.value = \"grey90\")+\n  coord_cartesian(clip = 'off')+\n  geom_vline(xintercept = 1963, col = \"black\") +\n  theme_grey(base_size=10)+\n  theme(legend.position=\"right\", legend.direction=\"vertical\",\n        legend.title=element_text(colour=textcol),\n        legend.margin=margin(grid::unit(0, \"cm\")),\n        legend.text=element_text(colour=textcol, size=7, face=\"bold\"),\n        legend.key.height=grid::unit(0.8, \"cm\"),\n        legend.key.width=grid::unit(0.2, \"cm\"),\n        axis.text.x=element_text(size=10, color=textcol),\n        axis.text.y=element_text(vjust=0.2, size=rel(0.7), color=textcol),\n        axis.ticks=element_line(size=0.4),\n        plot.background=element_blank(),\n        panel.border=element_blank(),\n        plot.margin=margin(0.7, 0.4, 0.1, 0.2, \"cm\"),\n        plot.title=element_text(colour=textcol, hjust=0, size=14, face=\"bold\")\n      )+ \n  annotate(geom = \"text\", x = 1963.5, y = 52, label = \"Vaccine introduced\", size = 3, hjust = 0)\n\nWarning: The `size` argument of `element_line()` is deprecated as of ggplot2 3.4.0.\ni Please use the `linewidth` argument instead.\n\np\n\n\n\n\n\nRather than manually writing in the colors we want to represent each discrete group, we could also use a palette of 7 colors by using the RColorBrewer package.\n\nlibrary(RColorBrewer)\np + scale_fill_manual(values=rev(brewer.pal(7, \"YlGnBu\")), na.value=\"grey90\")"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "4  Summary",
    "section": "",
    "text": "There is no summary. I was just scared to delete this file."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "heatmaps.html#example-1--categorical-axes",
    "href": "heatmaps.html#example-1--categorical-axes",
    "title": "2  Heatmaps",
    "section": "2.1 Example 1 -Categorical axes",
    "text": "2.1 Example 1 -Categorical axes\nHere, we have a dataset where we have three columns. The first column represents categorical variables (A to E) that will go on the bottom x-axis. The second column represents categorical variables (A to E) that will go on the y-axis. We have one row for every possible combination, so in this case we have 25 rows. The third column contains the value that we wish to represent by the fill color in the tile of the heatmap. I am using random values between 1 and 100 for this. The higher the value, the deeper the color we will use.\n\nset.seed(101)\nn <- 5\ndf <- data.frame(Var1=rep(LETTERS[1:n],n),\n                 Var2=rep(LETTERS[1:n],each=n),\n                 Value=sample(1:100, replace=T, n*n)\n)\nhead(df)\n\n  Var1 Var2 Value\n1    A    A    73\n2    B    A    57\n3    C    A    46\n4    D    A    95\n5    E    A    81\n6    A    B    58\n\n\nBelow, we will plot the heatmap without adding any stylistic elements.\n\n\n\n\nlibrary(tidyverse)\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile() \n\n\n\n\nAs can be seen, each cell (or tile) has a different degree of color fill based on it’s cell value in the Value column of the dataframe df. Brighter and lighter colors represent higher values of the Value column.\nA first step to make this prettier may be to add boundaries between the cells. This can be done by adding a linewidth and a color of this line as follows:\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75)\n\n\n\n\nThis looks nicer. Another thing that bugs me is that the default is to produce rectangular cells rather than square cells. This can be fixed by adding coord_equal().\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal()\n\n\n\n\nA next step that I often to is to add the following code to ensure that my cells are centered above each label. In this case, this doesn’t seem to change very much, but I have found it to be useful occasionally:\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) \n\n\n\n\nThe next thing that bugs me about this heatmap is that the default color gradient isn’t particularly intuitive to me. I’d rather my values go from a light color (low values) to a darker color (high values). To do this, we can state a low and high color value within scale_fill_continuous(). Here, we go from a very light to a darker purple color.\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\")\n\n\n\n\nNext, I find the axes labels and tick marks annoying, so I can remove these using xlab(\"\"), ylab(\"\"), and axis.ticks() inside theme(). I also increase the size of the labels on the axes.\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2))\n  )\n\n\n\n\nFinally, I’d rather my legend be on the bottom of the heatmap, and we don’t need the label on the legend. This can also be fixed within the theme() argument:\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  ) \n\n\n\n\nAs a quick aside - what happens if we have missing values in our Value column? Let’s introduce five random NA values into that column:\n\ndf$Value[sample(1:25,5)]<-NA\nhead(df)\n\n  Var1 Var2 Value\n1    A    A    NA\n2    B    A    57\n3    C    A    46\n4    D    A    95\n5    E    A    81\n6    A    B    NA\n\n\nNow we can plot with the same code as above:\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  ) \n\n\n\n\nWhat happens is that these default to a dark-greyish beige color, as seen above. In some circumstances, this color fill will be fine. However, in other situations we might want to dictate the color. Here, we make those NA cells white by adding na.value = \"white\" inside our scale_fill_continuous() .\n\nggplot(df, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#edf4f7\", high=\"#123abc\", na.value = \"white\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  )"
  },
  {
    "objectID": "heatmaps.html#example-2---discrete-numerical-axes.",
    "href": "heatmaps.html#example-2---discrete-numerical-axes.",
    "title": "2  Heatmaps",
    "section": "2.2 Example 2 - Discrete numerical axes.",
    "text": "2.2 Example 2 - Discrete numerical axes.\nAxes don’t have to be categorical. You can use discrete numbers also. They will be plotted in numerical order. Here we produce an example of a matrix which is 56 columns wide and 4 rows tall.\n\nset.seed(101)\ndf1 <- data.frame(Var1=rep(1:6,4),\n                 Var2=rep(1:4,each=6),\n                 Value=sample(1:100, replace=T, 24)\n)\nhead(df1)\n\n  Var1 Var2 Value\n1    1    1    73\n2    2    1    57\n3    3    1    46\n4    4    1    95\n5    5    1    81\n6    6    1    58\n\n\nUsing the same code as above - just changing the colors to a green palette:\n\nggplot(df1, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#ddead1\", high=\"#378805\", na.value = \"white\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  )\n\n\n\n\nNote that numeric values don’t show automatically here. This is because of the scale_x_discrete() and scale_y_discrete() lines. We can add the numeric labels by using the continuous scales instead and dictating what the breaks should be if required:\n\nggplot(df1, aes(Var1, Var2, fill = Value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_continuous(expand = c(0, 0), breaks=1:6) +\n  scale_y_continuous(expand = c(0, 0)) + \n  scale_fill_continuous(low=\"#ddead1\", high=\"#378805\", na.value = \"white\") +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  )"
  },
  {
    "objectID": "heatmaps.html#example-3-correlation-matrices",
    "href": "heatmaps.html#example-3-correlation-matrices",
    "title": "2  Heatmaps",
    "section": "2.3 Example 3: Correlation Matrices",
    "text": "2.3 Example 3: Correlation Matrices\nA common usage of heatmaps is to illustrate the correlations between a set of continuous variables.\nFirst, we should look at some data. Let’s import the dataset cordata.csv from our folder data_raw. This dataset contains eight continuous variables, boringly named V1, V2,…… V8.\n\ncd <- read.csv(\"data_raw/cordata.csv\")\nhead(cd)\n\n    V1    V2     V3     V4    V5     V6    V7   V8\n1 7.07 34.18 179.62 141.72 14.24 113.47 15.83 1.59\n2 7.43 43.51 107.77 111.40 10.86 139.11 16.76 0.00\n3 1.75  4.74 224.06 113.71 10.65 102.81 22.50 7.29\n4 0.68 16.75  20.00 101.66 16.48 127.23 22.12 5.36\n5 3.15 19.81 251.27 144.41 10.08 125.46 22.34 7.73\n6 3.60 27.98 233.61 137.11 10.02 156.36 24.18 2.18\n\n\nA quick way to get all the correlations between continuous variables in a data.frame is to use cor(). I’m surrounding this function with round() to make the output more easy to read:\n\ncdmat <- round(cor(cd),2)\ncdmat\n\n      V1    V2    V3    V4    V5    V6    V7    V8\nV1  1.00  0.87 -0.26 -0.02  0.15  0.19 -0.75 -0.79\nV2  0.87  1.00 -0.33 -0.15  0.15  0.17 -0.74 -0.92\nV3 -0.26 -0.33  1.00  0.34 -0.81 -0.25  0.44  0.38\nV4 -0.02 -0.15  0.34  1.00 -0.03  0.40  0.03  0.26\nV5  0.15  0.15 -0.81 -0.03  1.00  0.33 -0.30 -0.23\nV6  0.19  0.17 -0.25  0.40  0.33  1.00 -0.39 -0.08\nV7 -0.75 -0.74  0.44  0.03 -0.30 -0.39  1.00  0.64\nV8 -0.79 -0.92  0.38  0.26 -0.23 -0.08  0.64  1.00\n\n\nThis matrix is essentially what we want to plot, however, to do that, we first need to turn it into a dataframe with three columns. The first two being the row and column of the eventual plot and the third being the fill value (the correlation coeffecient). We can melt() the matrix into that dataframe:\n\ncdmat.df <- reshape2::melt(cdmat)\nhead(cdmat.df)\n\n  Var1 Var2 value\n1   V1   V1  1.00\n2   V2   V1  0.87\n3   V3   V1 -0.26\n4   V4   V1 -0.02\n5   V5   V1  0.15\n6   V6   V1  0.19\n\n\nLet’s plot this long data using similar code to above. However, here I’m using scale_fill_gradient2() to set low, mid and high colors at Pearson correlations of -1, 0 and +1 respectively:\n\nggplot(cdmat.df, aes(Var1, Var2, fill = value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_gradient2(low = \"blue\", high = \"red\", mid = \"white\", \n                       midpoint = 0, limit = c(-1,1), space = \"Lab\", \n                       name=\"Pearson's r\")  +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.0)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\"\n  )\n\n\n\n\nThere are three problems with this matrix. First, who cares that the diagonals are all r=1. We don’t need that information. Second, correlation matrices have symmetry along the axis, and so we could just plot either the upper or lower triangle of the matrix. Third, these variables could be reordered to make the relationships between variables be more intuitive.\nLet’s get rid of the diagonal and only keep the lower triangle. We can use the functions diag() and upper.tri() to make the diagonal and top triangle of the matrix NA. Then we melt the matrix again:\n\ndiag(cdmat)<-NA\ncdmat[upper.tri(cdmat)]<-NA\ncdmat\n\n      V1    V2    V3    V4    V5    V6   V7 V8\nV1    NA    NA    NA    NA    NA    NA   NA NA\nV2  0.87    NA    NA    NA    NA    NA   NA NA\nV3 -0.26 -0.33    NA    NA    NA    NA   NA NA\nV4 -0.02 -0.15  0.34    NA    NA    NA   NA NA\nV5  0.15  0.15 -0.81 -0.03    NA    NA   NA NA\nV6  0.19  0.17 -0.25  0.40  0.33    NA   NA NA\nV7 -0.75 -0.74  0.44  0.03 -0.30 -0.39   NA NA\nV8 -0.79 -0.92  0.38  0.26 -0.23 -0.08 0.64 NA\n\n\n\ncdlt.df <- reshape2::melt(cdmat)\nhead(cdlt.df)\n\n  Var1 Var2 value\n1   V1   V1    NA\n2   V2   V1  0.87\n3   V3   V1 -0.26\n4   V4   V1 -0.02\n5   V5   V1  0.15\n6   V6   V1  0.19\n\n\nWe can plot this in the same way as before but adding na.value=\"white\" inside the scale_fill_gradient2() to white out the NA values, leaving the bottom of the matrix.\n\nggplot(cdlt.df, aes(Var1, Var2, fill = value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_gradient2(low = \"blue\", high = \"red\", mid = \"white\",\n                       na.value=\"white\",\n                       midpoint = 0, limit = c(-1,1), space = \"Lab\", \n                       name=\"Pearson's r\")  +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.0)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\"\n  )\n\n\n\n\nTo reorder the matrix, we first need to recreate our original correlation matrix.\n\ncdmat1 <- round(cor(cd),2)\ncdmat1\n\n      V1    V2    V3    V4    V5    V6    V7    V8\nV1  1.00  0.87 -0.26 -0.02  0.15  0.19 -0.75 -0.79\nV2  0.87  1.00 -0.33 -0.15  0.15  0.17 -0.74 -0.92\nV3 -0.26 -0.33  1.00  0.34 -0.81 -0.25  0.44  0.38\nV4 -0.02 -0.15  0.34  1.00 -0.03  0.40  0.03  0.26\nV5  0.15  0.15 -0.81 -0.03  1.00  0.33 -0.30 -0.23\nV6  0.19  0.17 -0.25  0.40  0.33  1.00 -0.39 -0.08\nV7 -0.75 -0.74  0.44  0.03 -0.30 -0.39  1.00  0.64\nV8 -0.79 -0.92  0.38  0.26 -0.23 -0.08  0.64  1.00\n\n\nNext, we can use a clustering method such as hierarchical clustering to identify the relationships between each variable:\n\ndd <- as.dist((1-cdmat1)/2)\nhc <- hclust(dd)\ncdmat1 <-cdmat1[hc$order, hc$order]\ncdmat1\n\n      V3    V7    V8    V4    V6    V5    V1    V2\nV3  1.00  0.44  0.38  0.34 -0.25 -0.81 -0.26 -0.33\nV7  0.44  1.00  0.64  0.03 -0.39 -0.30 -0.75 -0.74\nV8  0.38  0.64  1.00  0.26 -0.08 -0.23 -0.79 -0.92\nV4  0.34  0.03  0.26  1.00  0.40 -0.03 -0.02 -0.15\nV6 -0.25 -0.39 -0.08  0.40  1.00  0.33  0.19  0.17\nV5 -0.81 -0.30 -0.23 -0.03  0.33  1.00  0.15  0.15\nV1 -0.26 -0.75 -0.79 -0.02  0.19  0.15  1.00  0.87\nV2 -0.33 -0.74 -0.92 -0.15  0.17  0.15  0.87  1.00\n\n\nWe then do the same process of adding NA to the diagonal and upper triangle of the matrix, and we can plot:\n\ndiag(cdmat1)<-NA\ncdmat1[upper.tri(cdmat1)]<-NA\ncdlt1.df <- reshape2::melt(cdmat1)\n\nggplot(cdlt1.df, aes(Var1, Var2, fill = value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_gradient2(low = \"blue\", high = \"red\", mid = \"white\",\n                       na.value=\"white\",\n                       midpoint = 0, limit = c(-1,1), space = \"Lab\", \n                       name=\"Pearson's r\")  +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.0)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\"\n  )\n\n\n\n\nOne final step that we might want to do is to add the actual correlations over the top of the colored cells. We can add this with geom_text().\n\nggplot(cdlt1.df, aes(Var1, Var2, fill = value)) + \n  geom_tile(color=\"white\", linewidth=1.75) +\n  coord_equal() +\n  geom_text(aes(Var1, Var2, label = value), color = \"black\", size = 3.5) +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) + \n  scale_fill_gradient2(low = \"blue\", high = \"red\", mid = \"white\",\n                       na.value=\"white\",\n                       midpoint = 0, limit = c(-1,1), space = \"Lab\", \n                       name=\"Pearson's r\")  +\n  xlab(\"\") + \n  ylab(\"\") +\n  theme(\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"black\", size=rel(1.2)),\n    legend.text = element_text(color=\"black\", size=rel(1.0)),\n    legend.background = element_rect(fill=\"white\"),\n    legend.position = \"bottom\"\n  )"
  },
  {
    "objectID": "heatmaps.html#some-practical-examples",
    "href": "heatmaps.html#some-practical-examples",
    "title": "2  Heatmaps",
    "section": "2.4 Some practical examples",
    "text": "2.4 Some practical examples\nBelow are some well known examples of using geom_tile() to create heatmaps examining trends in the prevalence of diseseas over time. First, we’ll look at the effect of birth month on risk of developing schizophrenia in an Australian cohort. This is using the schz dataset from the season R package:\n\nschz <- read.csv(\"data_raw/schz.csv\")\nhead(schz)\n\n  year month    yrmon NBirths SczBroad  SOI\n1 1930     1 1930.000    1578        8 12.7\n2 1930     2 1930.083    1519       11  7.7\n3 1930     3 1930.167    1630       15  1.8\n4 1930     4 1930.250    1607       12 -3.8\n5 1930     5 1930.333    1566       10  2.1\n6 1930     6 1930.417    1491        8 -5.5\n\nrange(schz$year)\n\n[1] 1930 1971\n\n\nEach row of this dataset contains information on the incidence of schizophrenia for individuals born for each month of the year between 1930-1971. We use the column SczBroad as a measure of schizophrenia risk at each timepoint.\nWe plot the data below using similar code to above. In addition, we are using scale_fill_viridis() from the viridis R package to fill our tiles from a gradient of dark purple (low risk) to bright yellow (high risk). We are using option D, one of four colorblind friendly palettes available in this package. Within theme() most of the lines are making the background panel and borders a dark gray color (gray10), and adjusting the placement of text labels.\n\nlibrary(viridis)\n\nLoading required package: viridisLite\n\nggplot(schz, aes(year, month, fill = SczBroad)) + \n  geom_tile(colour=\"gray10\", linewidth=1.1) + \n  coord_equal() +\n  scale_fill_viridis(option=\"D\",na.value = \"gray10\") +\n  scale_y_continuous(breaks=1:12, labels=month.abb[1:12])+\n  xlab(\"\") + \n  ylab(\"\") +\n  ggtitle(\"Schizophrenia Risk By Birth Month and Year in Australia\") +\n  theme(\n    plot.title = element_text(color=\"white\",hjust=0,vjust=1, size=rel(1.3)),\n    plot.background = element_rect(fill=\"gray10\"),\n    panel.background = element_rect(fill=\"gray10\"),\n    panel.border = element_rect(fill=NA,color=\"gray10\", linewidth = 0.5, linetype=\"solid\"),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    axis.line = element_blank(),\n    axis.ticks = element_blank(), \n    axis.text = element_text(color=\"white\", size=rel(0.8)),\n    axis.text.y  = element_text(hjust=1, margin = margin(r = -20)),\n    legend.text = element_text(color=\"white\", size=rel(1.1)),\n    legend.background = element_rect(fill=\"gray10\"),\n    legend.position = \"bottom\",\n    legend.title=element_blank()\n  )\n\n\n\n\n\nIn the next example, we are looking at the effect of the introduction of vaccinations on the prevalence of measles in the USA. The data are in the diseases.csv dataset. I’ve based this on code from this blog post.\n\ndis <- read.csv(\"data_raw/diseases.csv\")\nhead(dis)\n\n      disease   state year weeks_reporting count population\n1 Hepatitis A Alabama 1966              50   321    3345787\n2 Hepatitis A Alabama 1967              49   291    3364130\n3 Hepatitis A Alabama 1968              52   314    3386068\n4 Hepatitis A Alabama 1969              49   380    3412450\n5 Hepatitis A Alabama 1970              51   413    3444165\n6 Hepatitis A Alabama 1971              51   378    3481798\n\n\nThe dataset contains the total number of cases reported by each state for each disease for each year between 1928-2011. It should be noted that not all states start at the same time point. As can be seen above, Alabama’s Hepatitis reporting starts in 1966. In total, there are data on 7 different diseases, but we’ll just look at measles.\n\ntable(dis$disease)\n\n\nHepatitis A     Measles       Mumps   Pertussis       Polio     Rubella \n       2346        3876        1836        3774        3774        1938 \n   Smallpox \n       1326 \n\n\nTo compare across years and states, we need to make our data more uniform. One way is to look at the number of cases per e.g. 100,000 people. However, this is complicated by the issue that the data don’t come from full years but from different number of weeks within a year. So first, we should get a “per week” count for each disease in each state and then multiply by 52 to get a “per year” count. Then we can divide this by the population of the state in that year and multiply that by 100,000 to get an incidence per 100k people:\n\ndis.sum <- dis %>%\n  group_by(state,disease,year) %>%\n  summarise(peryear = 52*(count/weeks_reporting),\n            per100k = 100000*(peryear/population))\n\nhead(dis.sum)\n\n# A tibble: 6 x 5\n# Groups:   state, disease [1]\n  state   disease      year peryear per100k\n  <chr>   <chr>       <int>   <dbl>   <dbl>\n1 Alabama Hepatitis A  1966    334.    9.98\n2 Alabama Hepatitis A  1967    309.    9.18\n3 Alabama Hepatitis A  1968    314     9.27\n4 Alabama Hepatitis A  1969    403.   11.8 \n5 Alabama Hepatitis A  1970    421.   12.2 \n6 Alabama Hepatitis A  1971    385.   11.1 \n\n\nLet’s focus on Hepatitis A. Before plotting we will do two additional data carpentry steps. We will first reverse the order of the levels of the factor state. The default way to plot these states will be in alphabetical order along the y-axis starting with Alabama closest to the x-axis and Wyoming the furthest away. However, this is annoying to read as we are used to seeing A’s at the top and W’s near the bottom of a list of states. Second, rather than filling the tiles in a continuous gradient, we will create 7 discrete bins of color. These bins are not equivalent in terms of size which does somewhat break the rules of data visualization - i.e. an equal step in color gradient should map to an equal step in value. However, I think it can be justified in this context as we are interested in picking out “very low”, “low”, “medium”, “high”, “very high” number of cases etc. This new variable will be called countfactor.\n\nmeas <- dis.sum %>% filter(disease==\"Measles\") %>%\n        mutate(countfactor=cut(per100k, breaks=c(-1, 0, 1, 10, 100, 500, 1000, max(per100k, na.rm=T)),labels=c(\"0\", \"0-1\", \"1-10\", \"10-100\", \"100-500\", \"500-1000\", \">1000\"))) %>%\n  mutate(countfactor=factor(as.character(countfactor), levels=rev(levels(countfactor))))\n\nmeas$state <- factor(meas$state, levels = rev(unique(meas$state)))\n\nhead(meas)\n\n# A tibble: 6 x 6\n# Groups:   state, disease [1]\n  state   disease  year peryear per100k countfactor\n  <fct>   <chr>   <int>   <dbl>   <dbl> <fct>      \n1 Alabama Measles  1928   8843    341.  100-500    \n2 Alabama Measles  1929   3140.   120.  100-500    \n3 Alabama Measles  1930   4156    157.  100-500    \n4 Alabama Measles  1931   9481.   355.  100-500    \n5 Alabama Measles  1932    342.    12.7 10-100     \n6 Alabama Measles  1933   1769.    65.2 10-100     \n\n\nBelow we plot the data using geom_tile(). We use scale_fill_manual() with 7 colors that we pick ourselves to represent the 7 categories. Inside theme() we control the sizes and colors of text and the background colors. We also use coord_cartesian(), geom_vline() and annotate() to add the black line at 1963 and associate text to indicate when the vaccine was introduced.\n\n# assign text color\ntextcol <- \"grey40\"\n\np <- ggplot(meas, aes(x=year, y=state, fill=countfactor))+\n  geom_tile(color=\"white\", linewidth=0.2)+\n  guides(fill=guide_legend(title=\"Cases per\\n100,000 people\"))+\n  labs(x=\"\", y=\"\", title=\"Incidence of Measles in the US\")+\n  scale_y_discrete(expand=c(0, 0))+\n  scale_x_continuous(expand=c(0, 0), breaks=seq(1930,2000,10))+\n  scale_fill_manual(values=c(\"#d53e4f\", \"#f46d43\", \"#fdae61\", \"#fee08b\", \"#e6f598\", \"#abdda4\", \"#ddf1da\"), na.value = \"grey90\")+\n  coord_cartesian(clip = 'off')+\n  geom_vline(xintercept = 1963, col = \"black\") +\n  theme_grey(base_size=10)+\n  theme(legend.position=\"right\", legend.direction=\"vertical\",\n        legend.title=element_text(colour=textcol),\n        legend.margin=margin(grid::unit(0, \"cm\")),\n        legend.text=element_text(colour=textcol, size=7, face=\"bold\"),\n        legend.key.height=grid::unit(0.8, \"cm\"),\n        legend.key.width=grid::unit(0.2, \"cm\"),\n        axis.text.x=element_text(size=10, color=textcol),\n        axis.text.y=element_text(vjust=0.2, size=rel(0.7), color=textcol),\n        axis.ticks=element_line(size=0.4),\n        plot.background=element_blank(),\n        panel.border=element_blank(),\n        plot.margin=margin(0.7, 0.4, 0.1, 0.2, \"cm\"),\n        plot.title=element_text(colour=textcol, hjust=0, size=14, face=\"bold\")\n      )+ \n  annotate(geom = \"text\", x = 1963.5, y = 52, label = \"Vaccine introduced\", size = 3, hjust = 0)\n\nWarning: The `size` argument of `element_line()` is deprecated as of ggplot2 3.4.0.\ni Please use the `linewidth` argument instead.\n\np\n\n\n\n\n\nRather than manually writing in the colors we want to represent each discrete group, we could also use a palette of 7 colors by using the RColorBrewer package.\n\nlibrary(RColorBrewer)\np + scale_fill_manual(values=rev(brewer.pal(7, \"YlGnBu\")), na.value=\"grey90\")"
  },
  {
    "objectID": "intro.html#introduction-to-ggplot2",
    "href": "intro.html#introduction-to-ggplot2",
    "title": "1  Introduction",
    "section": "1.1 Introduction to ggplot2",
    "text": "1.1 Introduction to ggplot2\nThe first thing to do when we want to make a visualization with ggplot2 is to load the tidyverse:\n\nlibrary(tidyverse)\n\nNext, let’s load in some data. We’ll pick the BlueJays.csv data:\n\ndf <- read_csv(\"data_raw/BlueJays.csv\")\nhead(df)\n\n# A tibble: 6 x 9\n  BirdID     KnownSex BillDepth BillWidth BillLength  Head  Mass Skull   Sex\n  <chr>      <chr>        <dbl>     <dbl>      <dbl> <dbl> <dbl> <dbl> <dbl>\n1 0000-00000 M             8.26      9.21       25.9  56.6  73.3  30.7     1\n2 1142-05901 M             8.54      8.76       25.0  56.4  75.1  31.4     1\n3 1142-05905 M             8.39      8.78       26.1  57.3  70.2  31.2     1\n4 1142-05907 F             7.78      9.3        23.5  53.8  65.5  30.3     0\n5 1142-05909 M             8.71      9.84       25.5  57.3  74.9  31.8     1\n6 1142-05911 F             7.28      9.3        22.2  52.2  63.9  30       0\n\n\nIn the next few steps, we’ll slowly build up a plot using ggplot2. This is not how you would typically write the code. However, it is worth going step by step, just to show you the logic behind the code.\nIf we just run the function ggplot() notice that all we get is a blank gray canvas. R knows that we want to make a plot, but it has no idea what type of plot or with what data - so it just throws up the canvas:\n\nggplot()  \n\n\n\n\nNow, if we add the dataset to ggplot(), it still only gives us the blank canvas. It now knows we want to make a graph from the dataset called df but doesn’t plot anything yet as we didn’t tell it what to plot:\n\nggplot(df)   \n\n\n\n\nFor R to ‘know’ what you are trying to plot, you need to use aes(). You put that most of the time inside ggplot() after your dataframe name. (There are exceptions to this, but let’s not worry about that yet). Inside the aes() we’ll put what columns contain our data for the x and y axes. We may also refer to other columns inside aes() if we wish to modify the color or shape or something else about our data based on the values in some column.\nFor our first example, let’s make a scatterplot of body mass against head size of these Blue Jays. If you look at the original dataset, you’ll notice that both the Mass and Head columns contain continuous numeric data (i.e. they are numbers).\nIn the code below, we are telling aes() to plot the Mass data on the x-axis and to plot the Head data on the y-axis.\n\nggplot(df, aes(x=Mass, y=Head) )   \n\n\n\n\nSomething did change this time. We get a plot with labels on the x- and y-axes. It recognizes that we wish to plot Mass and Head data. It even knows the range of our data on each axis. For instance, it knows that the Mass data lies somewhere between 55 and 85. However, we haven’t yet told it precisely what type of plot we want to make (it doesn’t just assume that we wanted to make a scatterplot - it can’t read our minds).\nSo our next step is to tell it to make a scatterplot by adding points to the graph. We tell ggplot() what we are adding to the chart by using different geoms. For a scatterplot, the geom we require is geom_point() - that means add datapoints. It is hard to remember all the different geoms, but you can just look them up.\nHere is how we add datapoints to our graph with + geom_point().\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point()\n\n\n\n\nThat is our first ggplot graph! It looks pretty good. The amazing thing about ggplot is almost everything you are looking at on that graph can be customized to your preferred design choice. We’ll discuss several of these customizations throughout this chapter. First, let’s talk about changing the color of the datapoints. Inside of geom_point() we can change the color of all the points like this:\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point(color=\"red\")\n\n\n\n\nThis made the points red. Just make sure you put a recognized color name (you can look them up here) or a recognized hex code. Notice though that color name must be put inside of quotes.\nWhat if we want to color the points based on another variable? For example, instead of having all of our data points be red, say we want them to be colored based on whether the birds or male or female? The column that has the information about whether the birds are male or female is KnownSex. Because we are basing the color on a column, we put that information inside of aes() with color = KnownSex. We don’t put that inside geom_point(). This code looks like this:\n\nggplot(df, aes(x=Mass, y=Head, color = KnownSex) ) + geom_point() \n\n\n\n\n\n\n1.1.1 Assigning plots\nWhen we make plots, our code can start to get quite long as we make more and more additions or changes to the plot. One very useful thing to know is that we can assign our plot to be an object, just as we would with a vector or a dataframe. For instance, let’s remake the plot above, but this time we’ll assign it the name p. We do that using p <-.\n\np <- ggplot(df, aes(x=Mass, y=Head, color = KnownSex) ) + geom_point() \n\nNow, whenever we type and run p we will get our plot. e.g.\n\np\n\n\n\n\n\n\n\n1.1.2 Titles and Axes Titles\nThe advantage of assigning our plots to a short name, is that we can add things with less code. In R, if we wish to add a title to a plot, we do this with + ggtitle(). So, here is how we add a title to our above plot:\n\np + ggtitle(\"Our first scatterplot\")\n\n\n\n\nThe above plot is basically the same as writing:\n\nggplot(df, aes(x=Mass, y=Head, color = KnownSex) ) + \n  geom_point() +\n  ggtitle(\"Our First Scatterplot\")\n\n\n\n\nYou’ll notice that we are chaining together commands with the +. This is similar to how we chain together commands with the %>% when doing data carpentry. ggplot() instead chains with the +. Again, be careful not to start a row with a +, and you must end a row with a + unless it’s the very last row.\nTo change the title of the x-axis or the y-axis, we use xlab and ylab respectively. We can do it like this:\n\np + xlab(\"Body Mass (g)\") + ylab(\"Head Size (mm)\")\n\n\n\n\n\n\n\n1.1.3 Colors, Shapes and Sizes\nR recognizes many default color names. These can be found at either of these places:\n Color names 1  Color names 2  Or, you can use a hex code \nHere we use the color dodgerblue to change all the points to that color:\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point(color=\"dodgerblue\")\n\n\n\n\nHere we change the points to the color #ababcc using a hexcode - note that hexcodes need to have # in front of them:\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point(color=\"#ababcc\")\n\n\n\n\nYou can also change the shape of the points you plot with geom_point(pch = ). You need to insert the appropriate number according to this guide:\n\nFor example, to have dodgerblue asterisks, we add pch = 8, separating the color and shape commands by a comma:\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point(color=\"dodgerblue\", pch = 8)\n\n\n\n\nFinally, we can change the size of our datapoints (or other shape we choose), using size =:\n\nggplot(df, aes(x=Mass, y=Head) ) + geom_point(color=\"purple\", size=2)\n\n\n\n\n\n\n\n1.1.4 Themes\nDefault Themes\nYou may have noticed that every plot we have made so far has the same gray background with faint white gridlines. This is the default setting for the look of ggplot() graphs. There are several other themes that are available to us that change the overall appearance of our plots. Some of these are listed below:\ntheme_bw() a variation on theme_grey() that uses a white background and thin grey grid lines.\ntheme_linedraw() A theme with only black lines of various widths on white backgrounds, reminiscent of a line drawing.\ntheme_light() similar to theme_linedraw() but with light grey lines and axes, to direct more attention towards the data.\ntheme_dark() the dark cousin of theme_light(), with similar line sizes but a dark background. Useful to make thin colored lines pop out.\ntheme_minimal() A minimalistic theme with no background annotations.\ntheme_classic() A classic-looking theme, with x and y axis lines and no gridlines.\ntheme_void() A completely empty theme\nLet’s shows a couple of these different themes. The theme that we use the most in this course is theme_classic(). This is how you would apply this theme to your plot:\n\nggplot(df, aes(x=Mass, y=Head) ) + \n  geom_point() +\n  theme_classic()\n\n\n\n\nIt creates a very sleek simple graph. The downside to this type of graph is that it does get rid of the gridlines which can be helpful sometimes.\nAnother theme that we use often is theme_minimal(). Here is how we would add this:\n\nggplot(df, aes(x=Mass, y=Head) ) + \n  geom_point() +\n  theme_minimal()\n\n\n\n\nThis theme is also simplistic, but has gridlines too.\n\nCustom themes\nRather than changing many different aspects of the graph at once, we can change individual things one by one with theme(). We don’t propose to cover this in more detail in this book - for more information about themes look here - however, here is one quick example.\nLet’s say we wanted to make the panel background light blue instead of gray. We could do it like this:\n\nggplot(df, aes(x=Mass, y=Head) ) + \n  geom_point() +\n  theme(panel.background = element_rect(fill = \"lightblue\"))\n\n\n\n\nAgain, this can get quite complicated - so stick with the default themes if you want to change your plots up a bit, or go to other help guides or later chapters in this book for more fine detail on customization."
  },
  {
    "objectID": "scatterplots.html",
    "href": "scatterplots.html",
    "title": "2  Scatterplots",
    "section": "",
    "text": "In the introduction to ggplot2, we already demonstrated how to make a scatterplot. Here we will show a few extra features of these plots. Scatterplots plot continuous variables on the x- and y-axes, and can be very useful to examine the association between the two continuous variables. We use them a lot when plotting data related to correlation.\nAs we showed earlier, geom_point is used to add datapoints to scatter plots. We’ll do this for the cheese.csv dataset, that contains nutritional information about various cheeses:\n\nlibrary(tidyverse)\ncheese <- read_csv(\"data_raw/cheese.csv\")\nhead(cheese)\n\n# A tibble: 6 x 9\n  type      sat_fat polysat_fat monosat_fat protein  carb  chol fiber  kcal\n  <chr>       <dbl>       <dbl>       <dbl>   <dbl> <dbl> <dbl> <dbl> <dbl>\n1 blue         18.7       0.8          7.78    21.4  2.34    75     0   353\n2 brick        18.8       0.784        8.60    23.2  2.79    94     0   371\n3 brie         17.4       0.826        8.01    20.8  0.45   100     0   334\n4 camembert    15.3       0.724        7.02    19.8  0.46    72     0   300\n5 caraway      18.6       0.83         8.28    25.2  3.06    93     0   376\n6 cheddar      21.1       0.942        9.39    24.9  1.28   105     0   403\n\n\nWe’ll start with a simple scatterplot looking at the association between saturated fat on the x-axis and cholesterol on the y-axis intake.\n\nggplot(cheese, aes(x=sat_fat, y=chol) ) + \n  geom_point()\n\n\n\n\nWe can change the color of the points by adding a color inside of geom_point - making sure that the color name is in quotes:\n\nggplot(cheese, aes(x=sat_fat, y=chol) ) + \n  geom_point(color = \"purple\")\n\n\n\n\nTo add a straight trendline through the data we use + stat_smooth(method = \"lm\"). The stat_smooth bit tells it to add a trendline, and the method=\"lm\" bit in the middle is telling it to make the straight line:\n\nggplot(cheese, aes(x=sat_fat, y=chol) ) + \n  geom_point(color = \"purple\") +\n stat_smooth(method = \"lm\")\n\n\n\n\nHere you can see it automatically puts a shaded area around your trendline, which represents a confidence interval around the trendline. There is a way to remove it by adding se = FALSE or se = F inside of stat_smooth():\n\nggplot(cheese, aes(x=sat_fat, y=chol) ) + \n  geom_point(color = \"purple\") +\n stat_smooth(method = \"lm\", se = FALSE)\n\n\n\n\nYou can also change the color of the trendline, by adding to stat_smooth\n\nggplot(cheese, aes(x=sat_fat, y=chol) ) + \n  geom_point(color = \"purple\") +\n  stat_smooth(method = \"lm\", se= F, color = \"black\")\n\n\n\n\nAs with all ggplot2 graphs, you can customize the plot. For example changing the theme, adding a title and axes titles:\n\nggplot(cheese, aes(x=sat_fat, y=chol) ) + \n  geom_point(color = \"purple\") +\n  stat_smooth(method = \"lm\", se= F, color = \"black\") +\n  xlab(\" Saturated Fat\") +\n  ylab(\"Cholesterol\") +\n  ggtitle(\"Saturated Fat vs Cholesterol\") +\n  theme_minimal()\n\n\n\n\nIf you wish to change the color of the points based on a grouping variable, then we need to put our color= into the aes(). You then need to provide the column that has the color grouping variable. For example, to change the color of points in our plot of body mass against head size in Blue Jays based on the sex of birds:\n\ndf <- read_csv(\"data_raw/BlueJays.csv\")\n\nRows: 123 Columns: 9\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr (2): BirdID, KnownSex\ndbl (7): BillDepth, BillWidth, BillLength, Head, Mass, Skull, Sex\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nhead(df)\n\n# A tibble: 6 x 9\n  BirdID     KnownSex BillDepth BillWidth BillLength  Head  Mass Skull   Sex\n  <chr>      <chr>        <dbl>     <dbl>      <dbl> <dbl> <dbl> <dbl> <dbl>\n1 0000-00000 M             8.26      9.21       25.9  56.6  73.3  30.7     1\n2 1142-05901 M             8.54      8.76       25.0  56.4  75.1  31.4     1\n3 1142-05905 M             8.39      8.78       26.1  57.3  70.2  31.2     1\n4 1142-05907 F             7.78      9.3        23.5  53.8  65.5  30.3     0\n5 1142-05909 M             8.71      9.84       25.5  57.3  74.9  31.8     1\n6 1142-05911 F             7.28      9.3        22.2  52.2  63.9  30       0\n\nggplot(df, aes(x=Mass, y=Head, color = KnownSex) ) + \n  geom_point() \n\n\n\n\nIf you wish to customize the colors of your datapoints, then you need to add scale_color_manual() like this:\n\nggplot(df, aes(x=Mass, y=Head, color = KnownSex) ) + \n  geom_point() +\n  scale_color_manual(values = c(\"darkorange\", \"steelblue2\")) +\n  theme_classic()\n\n\n\n\nIf you have a lot of points on your scatterplot, it can get quite hard to see all the datapoints. One way to deal with this is to change the transparency of the points. You can do this by adjusting the alpha level inside of geom_point(). alpha= ranges from 0 to 1, with 0 being fully transparent and 1 being fully solid.\n\nggplot(df, aes(x=Mass, y=Head, color = KnownSex) ) + \n  geom_point(alpha=.4) +\n  scale_color_manual(values = c(\"darkorange\", \"steelblue2\")) +\n  theme_classic()\n\n\n\n\n\n\n2.0.0.1 Multiple Groups on a Scatterplot\nWe can add multiple trendlines to each group of datapoints plotted on a scatterplot. Let’s look at the following data of the chemical components of different olive oils produced in Italy. This is what the data look like:\n\nolives <- read_csv(\"data_raw/olives.csv\")\nhead(olives)\n\n# A tibble: 6 x 10\n  macro.a~1 region palmi~2 palmi~3 stearic oleic linol~4 linol~5 arach~6 eicos~7\n  <chr>     <chr>    <dbl>   <dbl>   <dbl> <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1 South     Apuli~    1075      75     226  7823     672      36      60      29\n2 South     Apuli~    1088      73     224  7709     781      31      61      29\n3 South     Apuli~     911      54     246  8113     549      31      63      29\n4 South     Apuli~     966      57     240  7952     619      50      78      35\n5 South     Apuli~    1051      67     259  7771     672      50      80      46\n6 South     Apuli~     911      49     268  7924     678      51      70      44\n# ... with abbreviated variable names 1: macro.area, 2: palmitic,\n#   3: palmitoleic, 4: linoleic, 5: linolenic, 6: arachidic, 7: eicosenoic\n\n\nIf we use table(), we can see how many different regions are represented in the data. There are three unique Italian areas where the olives come from:\n\ntable(olives$macro.area)\n\n\nCentre.North     Sardinia        South \n         151           98          323 \n\n\nSay we are interested in looking at how oleic and linoleic acid contents are related to each other by macro.area:\n\nggplot(olives, aes(x=oleic, y=linoleic, color=macro.area)) +\n  geom_point() +\n  theme_classic()\n\n\n\n\n\nIf we wanted to add a trendline for each area, all we need to do is add our stat_smooth(method=\"lm) line to the code. It already knows to plot these as separate trendlines for each group because inside aes() we have color=macro.area. As long as there is a group= or color= inside aes() then it knows to do things like adding trendlines separately for each group:\n\nggplot(olives, aes(x=oleic, y=linoleic, color=macro.area)) +\n  geom_point() +\n  stat_smooth(method=\"lm\", se=F) +\n  theme_classic() \n\n\n\n\n\n\n\n\n2.0.1 Bubble Charts\nBubble Charts are an extension to scatterplots. In scatterplots we plot two continuous variables against each other. With a bubble chart we add a third continuous variable and vary the size of our datapoints according to this variable. For example, say we wish to also plot skull size on our Blue Jay scatterplot. We could increase the size of the points for individuals with larger skull sizes. We do this by adding size=Skull into our aes() part:\n\nggplot(df, aes(x=Mass, y=Head, color = KnownSex, size = Skull) ) + \n  geom_point(alpha=.4) +\n  scale_color_manual(values = c(\"darkorange\", \"steelblue2\")) +\n  theme_classic()\n\n\n\n\nThe issue with bubble charts is that they can start to look very cluttered, making it hard to actually see any patterns. They should probably be used sparingly. One trick you can employ to make them a little easier to see is to add scale_size() to the plot. Here, you enter two numbers to tell it what size points to scale to. In our example below, we used scale_size(range = c(.1, 4)) which makes our points range between sizes 0.1 and 4. This makes the plot a little less busy:\n\nggplot(df, aes(x=Mass, y=Head, color = KnownSex, size = Skull) ) + \n  geom_point(alpha=.4) +\n  scale_color_manual(values = c(\"darkorange\", \"steelblue2\")) +\n  theme_classic() +\n  scale_size(range = c(.1, 4))"
  },
  {
    "objectID": "scatterplots.html#multiple-groups-on-a-scatterplot",
    "href": "scatterplots.html#multiple-groups-on-a-scatterplot",
    "title": "2  Scatterplots",
    "section": "2.2 Multiple Groups on a Scatterplot",
    "text": "2.2 Multiple Groups on a Scatterplot\nWe can add multiple trendlines to each group of datapoints plotted on a scatterplot. Let’s look at the following data of the chemical components of different olive oils produced in Italy. This is what the data look like:\n\nolives <- read_csv(\"data_raw/olives.csv\")\nhead(olives)\n\n# A tibble: 6 x 10\n  macro.a~1 region palmi~2 palmi~3 stearic oleic linol~4 linol~5 arach~6 eicos~7\n  <chr>     <chr>    <dbl>   <dbl>   <dbl> <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1 South     Apuli~    1075      75     226  7823     672      36      60      29\n2 South     Apuli~    1088      73     224  7709     781      31      61      29\n3 South     Apuli~     911      54     246  8113     549      31      63      29\n4 South     Apuli~     966      57     240  7952     619      50      78      35\n5 South     Apuli~    1051      67     259  7771     672      50      80      46\n6 South     Apuli~     911      49     268  7924     678      51      70      44\n# ... with abbreviated variable names 1: macro.area, 2: palmitic,\n#   3: palmitoleic, 4: linoleic, 5: linolenic, 6: arachidic, 7: eicosenoic\n\n\nIf we use table(), we can see how many different regions are represented in the data. There are three unique Italian areas where the olives come from:\n\ntable(olives$macro.area)\n\n\nCentre.North     Sardinia        South \n         151           98          323 \n\n\nSay we are interested in looking at how oleic and linoleic acid contents are related to each other by macro.area:\n\nggplot(olives, aes(x=oleic, y=linoleic, color=macro.area)) +\n  geom_point() +\n  theme_classic()\n\n\n\n\n\nIf we wanted to add a trendline for each area, all we need to do is add our stat_smooth(method=\"lm) line to the code. It already knows to plot these as separate trendlines for each group because inside aes() we have color=macro.area. As long as there is a group= or color= inside aes() then it knows to do things like adding trendlines separately for each group:\n\nggplot(olives, aes(x=oleic, y=linoleic, color=macro.area)) +\n  geom_point() +\n  stat_smooth(method=\"lm\", se=F) +\n  theme_classic()"
  },
  {
    "objectID": "scatterplots.html#bubble-charts",
    "href": "scatterplots.html#bubble-charts",
    "title": "2  Scatterplots",
    "section": "2.3 Bubble Charts",
    "text": "2.3 Bubble Charts\nBubble Charts are an extension to scatterplots. In scatterplots we plot two continuous variables against each other. With a bubble chart we add a third continuous variable and vary the size of our datapoints according to this variable. For example, say we wish to also plot skull size on our Blue Jay scatterplot. We could increase the size of the points for individuals with larger skull sizes. We do this by adding size=Skull into our aes() part:\n\nggplot(df, aes(x=Mass, y=Head, color = KnownSex, size = Skull) ) + \n  geom_point(alpha=.4) +\n  scale_color_manual(values = c(\"darkorange\", \"steelblue2\")) +\n  theme_classic()\n\n\n\n\nThe issue with bubble charts is that they can start to look very cluttered, making it hard to actually see any patterns. They should probably be used sparingly. One trick you can employ to make them a little easier to see is to add scale_size() to the plot. Here, you enter two numbers to tell it what size points to scale to. In our example below, we used scale_size(range = c(.1, 4)) which makes our points range between sizes 0.1 and 4. This makes the plot a little less busy:\n\nggplot(df, aes(x=Mass, y=Head, color = KnownSex, size = Skull) ) + \n  geom_point(alpha=.4) +\n  scale_color_manual(values = c(\"darkorange\", \"steelblue2\")) +\n  theme_classic() +\n  scale_size(range = c(.1, 4))"
  },
  {
    "objectID": "lines.html#multiple-line-graphs",
    "href": "lines.html#multiple-line-graphs",
    "title": "3  Line Graphs",
    "section": "3.2 Multiple Line Graphs",
    "text": "3.2 Multiple Line Graphs\nOften we wish to compare the patterns over time of different groups. We can do that by plotting multiple lines on the same graph.\nLet’s look at this example dataset.\n\njenlinda <- read_csv(\"data_raw/jenlinda.csv\")\ntail(jenlinda)\n\n# A tibble: 6 x 5\n   year sex    name         n     prop\n  <dbl> <chr>  <chr>    <dbl>    <dbl>\n1  2015 Female Jennifer  1283 0.000660\n2  2015 Female Linda      425 0.000218\n3  2016 Female Jennifer  1159 0.000601\n4  2016 Female Linda      436 0.000226\n5  2017 Female Jennifer  1042 0.000556\n6  2017 Female Linda      404 0.000215\n\n\nHere, we have data in long format. We still have our continuous outcome variable of n in one column. We also have year in another column. So we can plot these two against each other. Importantly, we can split our lines based on our grouping variable, which is the name column. In that column we have two different groups - Jennifer and Linda.\nTo plot separate lines based on the name column, we need to add group=name to our aes(). We’ve also added some custom labels, titles and a theme.\n\nggplot(jenlinda, aes(x=year, y=n, group=name)) + \n  geom_line()+\n  xlab(\"Year\") +\n  ylab(\"Number of Children Born\") +\n  ggtitle(\"Popularity of Names Jennifer & Linda in USA\") +\n  theme_minimal()\n\n\n\n\nYou may notice that both lines are the same color! To make the lines have different colors, we insert color=name into the aes() instead of group=name:\n\nggplot(jenlinda, aes(x=year, y=n, color=name)) + \n  geom_line()+\n  xlab(\"Year\") +\n  ylab(\"Number of Children Born\") +\n  ggtitle(\"Popularity of Names Jennifer & Linda in USA\") +\n  theme_minimal()\n\n\n\n\nAgain, we could customize these colors if we did not like them with scale_color_manual() like this:\n\nggplot(jenlinda, aes(x=year, y=n, color=name)) + \n  geom_line()+\n  xlab(\"Year\") +\n  ylab(\"Number of Children Born\") +\n  ggtitle(\"Popularity of Names Jennifer & Linda in USA\") +\n  theme_classic() +\n  scale_color_manual(values=c(\"#ffadf3\", \"#800f4f\"))\n\n\n\n\nJust insert your favorite colors, and make sure you provide the same number of colors as you have separate groups/lines."
  },
  {
    "objectID": "lines.html#basic-line-graphs",
    "href": "lines.html#basic-line-graphs",
    "title": "3  Line Graphs",
    "section": "3.1 Basic Line Graphs",
    "text": "3.1 Basic Line Graphs\nLet’s look at the jennifer.csv dataset:\n\nlibrary(tidyverse)\njennifer <- read_csv(\"data_raw/jennifer.csv\")\nhead(jennifer)\n\n# A tibble: 6 x 5\n   year sex    name         n       prop\n  <dbl> <chr>  <chr>    <dbl>      <dbl>\n1  1916 Female Jennifer     5 0.00000461\n2  1919 Female Jennifer     6 0.00000511\n3  1920 Female Jennifer     7 0.00000563\n4  1921 Female Jennifer     5 0.00000391\n5  1922 Female Jennifer     7 0.00000561\n6  1923 Female Jennifer     9 0.00000719\n\n\nThis dataset shows the number n of children born each year (year) in the United States with the name Jennifer. In 1916 there were five children born with the name Jennifer. In 1917 there were 0. In 1923 there were 9.\nThis dataset goes up to 2017 where there were 1052 children born with the name Jennifer:\n\ntail(jennifer)\n\n# A tibble: 6 x 5\n   year sex    name         n     prop\n  <dbl> <chr>  <chr>    <dbl>    <dbl>\n1  2012 Female Jennifer  1923 0.000993\n2  2013 Female Jennifer  1689 0.000878\n3  2014 Female Jennifer  1521 0.000779\n4  2015 Female Jennifer  1283 0.000660\n5  2016 Female Jennifer  1159 0.000601\n6  2017 Female Jennifer  1042 0.000556\n\n\nTherefore, we have a continuous variable (n) and a time variable (year). We can plot these as we would plot a scatterplot by supplying year to our x-axis and n to our y-axis. We could then add datapoints with geom_point() essentially making a scatterplot:\n\nggplot(jennifer, aes(x=year, y=n) ) + geom_point() \n\n\n\n\nBut, we aren’t dealing with just a scatterplot. These datapoints can be connected to each other as they are ordered in time. Instead of using geom_point() we can use geom_line() to draw a line instead:\n\nggplot(jennifer, aes(x=year, y=n) ) + geom_line()\n\n\n\n\nIf you so desired, you could plot both the points and lines together:\n\nggplot(jennifer, aes(x=year, y=n) ) + \n  geom_point() +  \n  geom_line() \n\n\n\n\nYou can adjust the colors of the lines and the points independently by supplying color= inside of each geom:\ne.g. Changing the color of the line, but not the points:\n\nggplot(jennifer, aes(x=year, y=n) ) + \n  geom_point() +\n  geom_line(color = \"purple\") \n\n\n\n\nChanging the color of both the points and the line:\n\nggplot(jennifer, aes(x=year, y=n) ) + \n  geom_point(color = \"violet\") +\n  geom_line(color = \"purple\") \n\n\n\n\nYou can also change the width of lines by adding lwd= to geom_line():\n\nggplot(jennifer, aes(x=year, y=n) ) + \n  geom_line(color = \"purple\", lwd=2)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\ni Please use `linewidth` instead.\n\n\n\n\n\nThere are also several different styles of lines. You can change these by adjusting the number you provide to lty= inside of geom_line(). Here are a few examples:\n\nggplot(jennifer, aes(x=year, y=n) ) + geom_line(lty=2)\n\n\n\n\n\nggplot(jennifer, aes(x=year, y=n) ) + geom_line(lty=3)\n\n\n\n\nThis illustration shows some of the linetype options:\n\nJust a quick reminder: Please only connect datapoints into a line if it is meaningful to do so! This is almost always when your x-axis is some measure of time."
  },
  {
    "objectID": "scatterplots.html#basic-scatterplots",
    "href": "scatterplots.html#basic-scatterplots",
    "title": "2  Scatterplots",
    "section": "2.1 Basic Scatterplots",
    "text": "2.1 Basic Scatterplots\nAs we showed earlier, geom_point is used to add datapoints to scatter plots. We’ll do this for the cheese.csv dataset, that contains nutritional information about various cheeses:\n\nlibrary(tidyverse)\ncheese <- read_csv(\"data_raw/cheese.csv\")\nhead(cheese)\n\n# A tibble: 6 x 9\n  type      sat_fat polysat_fat monosat_fat protein  carb  chol fiber  kcal\n  <chr>       <dbl>       <dbl>       <dbl>   <dbl> <dbl> <dbl> <dbl> <dbl>\n1 blue         18.7       0.8          7.78    21.4  2.34    75     0   353\n2 brick        18.8       0.784        8.60    23.2  2.79    94     0   371\n3 brie         17.4       0.826        8.01    20.8  0.45   100     0   334\n4 camembert    15.3       0.724        7.02    19.8  0.46    72     0   300\n5 caraway      18.6       0.83         8.28    25.2  3.06    93     0   376\n6 cheddar      21.1       0.942        9.39    24.9  1.28   105     0   403\n\n\nWe’ll start with a simple scatterplot looking at the association between saturated fat on the x-axis and cholesterol on the y-axis intake.\n\nggplot(cheese, aes(x=sat_fat, y=chol) ) + \n  geom_point()\n\n\n\n\nWe can change the color of the points by adding a color inside of geom_point - making sure that the color name is in quotes:\n\nggplot(cheese, aes(x=sat_fat, y=chol) ) + \n  geom_point(color = \"purple\")\n\n\n\n\nTo add a straight trendline through the data we use + stat_smooth(method = \"lm\"). The stat_smooth bit tells it to add a trendline, and the method=\"lm\" bit in the middle is telling it to make the straight line:\n\nggplot(cheese, aes(x=sat_fat, y=chol) ) + \n  geom_point(color = \"purple\") +\n stat_smooth(method = \"lm\")\n\n\n\n\nHere you can see it automatically puts a shaded area around your trendline, which represents a confidence interval around the trendline. There is a way to remove it by adding se = FALSE or se = F inside of stat_smooth():\n\nggplot(cheese, aes(x=sat_fat, y=chol) ) + \n  geom_point(color = \"purple\") +\n stat_smooth(method = \"lm\", se = FALSE)\n\n\n\n\nYou can also change the color of the trendline, by adding to stat_smooth\n\nggplot(cheese, aes(x=sat_fat, y=chol) ) + \n  geom_point(color = \"purple\") +\n  stat_smooth(method = \"lm\", se= F, color = \"black\")\n\n\n\n\nAs with all ggplot2 graphs, you can customize the plot. For example changing the theme, adding a title and axes titles:\n\nggplot(cheese, aes(x=sat_fat, y=chol) ) + \n  geom_point(color = \"purple\") +\n  stat_smooth(method = \"lm\", se= F, color = \"black\") +\n  xlab(\" Saturated Fat\") +\n  ylab(\"Cholesterol\") +\n  ggtitle(\"Saturated Fat vs Cholesterol\") +\n  theme_minimal()\n\n\n\n\nIf you wish to change the color of the points based on a grouping variable, then we need to put our color= into the aes(). You then need to provide the column that has the color grouping variable. For example, to change the color of points in our plot of body mass against head size in Blue Jays based on the sex of birds:\n\ndf <- read_csv(\"data_raw/BlueJays.csv\")\n\nRows: 123 Columns: 9\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr (2): BirdID, KnownSex\ndbl (7): BillDepth, BillWidth, BillLength, Head, Mass, Skull, Sex\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nhead(df)\n\n# A tibble: 6 x 9\n  BirdID     KnownSex BillDepth BillWidth BillLength  Head  Mass Skull   Sex\n  <chr>      <chr>        <dbl>     <dbl>      <dbl> <dbl> <dbl> <dbl> <dbl>\n1 0000-00000 M             8.26      9.21       25.9  56.6  73.3  30.7     1\n2 1142-05901 M             8.54      8.76       25.0  56.4  75.1  31.4     1\n3 1142-05905 M             8.39      8.78       26.1  57.3  70.2  31.2     1\n4 1142-05907 F             7.78      9.3        23.5  53.8  65.5  30.3     0\n5 1142-05909 M             8.71      9.84       25.5  57.3  74.9  31.8     1\n6 1142-05911 F             7.28      9.3        22.2  52.2  63.9  30       0\n\nggplot(df, aes(x=Mass, y=Head, color = KnownSex) ) + \n  geom_point() \n\n\n\n\nIf you wish to customize the colors of your datapoints, then you need to add scale_color_manual() like this:\n\nggplot(df, aes(x=Mass, y=Head, color = KnownSex) ) + \n  geom_point() +\n  scale_color_manual(values = c(\"darkorange\", \"steelblue2\")) +\n  theme_classic()\n\n\n\n\nIf you have a lot of points on your scatterplot, it can get quite hard to see all the datapoints. One way to deal with this is to change the transparency of the points. You can do this by adjusting the alpha level inside of geom_point(). alpha= ranges from 0 to 1, with 0 being fully transparent and 1 being fully solid.\n\nggplot(df, aes(x=Mass, y=Head, color = KnownSex) ) + \n  geom_point(alpha=.4) +\n  scale_color_manual(values = c(\"darkorange\", \"steelblue2\")) +\n  theme_classic()"
  },
  {
    "objectID": "distributionsgroups.html#strip-plots",
    "href": "distributionsgroups.html#strip-plots",
    "title": "5  Distributions Across Groups",
    "section": "5.1 Strip Plots",
    "text": "5.1 Strip Plots\nStrip plots essentially just plot the raw data. It’s like plotting a scatterplot, except we plot a categorical variable on the x-axis.\nSo in our example, inside aes() we’ll put strain on the x-axis with x=strain, and on the y-axis we put our outcome variable with y=day4. We’ll add datapoints with + geom_point():\n\nggplot(wheels1, aes(x = strain, y = day4)) + \n  geom_point()  +\n  theme_classic()\n\n\n\n\nThe major issue with this plot is that all the points are in a very straight line, and it can be difficult to distinguish between different points. To change this, instead of using geom_point() we use geom_jitter() which bounces the points around a bit:\n\nggplot(wheels1, aes(x = strain, y = day4)) + \n  geom_jitter()  +\n  theme_classic()\n\n\n\n\nWhoops! The points exploded. Now it’s not possible to know which points belong to which group. To constrain this, we can set width= inside of geom_jitter() which tells the points how far they are allowed to bounce around:\n\nggplot(wheels1, aes(x = strain, y = day4)) + \n  geom_jitter(width = .15)  +\n  theme_classic()\n\n\n\n\nThis looks a lot better!."
  },
  {
    "objectID": "distributionsgroups.html#boxplots",
    "href": "distributionsgroups.html#boxplots",
    "title": "5  Distributions Across Groups",
    "section": "5.2 Boxplots",
    "text": "5.2 Boxplots\nBoxplots are a very useful way of summarizing the distribution of data. The image below summarizes what each line in the boxplot represents.\n\nThe middle horizontal line is at 6. This represents the median of the distribution which is the middle value. 50% of the distribution lies above this value and 50% below it. The higher horizontal line at the top of the box represents the upper quartile. This is approximately the median of the upper 50% of the data, so is approximately the 75% percentile. The lower horizontal line at the bottom of the box represents the lower quartile. This is approximately the median of the lower 50% of the data, so is approximately the 25% percentile of the data. Therefore, the middle 50% of the data (from the 25% percentile to the 75% percentile) lies inside the box. The long vertical lines represent the range of the data. The top of that line is the maximum value in the data, and the bottom of that line is the minimum value in the distribution.\nThe above is a basic boxplot. However, ggplot2 does things a little bit differently. It turns out there is more than one way to calculate the lower and upper quartiles (see section @ref(interquartile-range)). Also, R doesn’t necessarily extend the vertical lines (whiskers) all the way to the minimum and maximum values. If there are datapoints that are too far away from the upper or lower quartile, then it truncates the whisker and shows datapoints outside of this range as dots. Here is an illustration of a ggplot boxplot:\n\nOK, let’s have a look at some boxplots using ggplot(). We provide the same x=strain and y=day4 values as we do with strip plots. Instead of geom_jitter() we use geom_boxplot():\n\nggplot(wheels1, aes(x = strain, y = day4)) + \n  geom_boxplot()  +\n  theme_classic()\n\n\n\n\nYou can see in this example, that the strain “F1-129B6” and the strain “S129” both have two datapoints that are shown as outliers beyond the whiskers.\nTo change the colors of the boxplots, you can change color= and fill= inside geom_boxplot(). Remember that color refers to the color of the lines, and fill refers to the filled in color of the shape:\n\nggplot(wheels1, aes(x = strain, y = day4)) + \n  geom_boxplot(color=\"navy\", fill=\"lightsteelblue1\") +\n  theme_classic()\n\n\n\n\nYou can change the size, color and shape of the outliers. For instance, to remove them completely, we do outlier.shape=NA inside geom_boxplot()\n\nggplot(wheels1, aes(x = strain, y = day4)) + \n  geom_boxplot(color=\"navy\", fill=\"lightsteelblue1\", outlier.shape = NA) +\n  theme_classic()\n\n\n\n\nTo change the size and color, you can use outlier.size and outlier.color respectively inside geom_boxplot()\n\nggplot(wheels1, aes(x = strain, y = day4)) + \n  geom_boxplot(color=\"navy\", fill=\"lightsteelblue1\", outlier.size = .5, outlier.color = \"gray66\") +\n  theme_classic()\n\n\n\n\n\n\n5.2.1 Overlaying points\nIt can often be helpful to overlay your raw datapoints over the top of boxplots, providing that you don’t have too much data. To do this, just add your points with either geom_point() or preferably geom_jitter(). But one warning - make sure you remove any outliers with outlier.shape=NA otherwise those datapoints will show up twice:\n\nggplot(wheels1, aes(x = strain, y = day4)) + \n  geom_boxplot(color=\"navy\", fill=\"lightsteelblue1\", outlier.shape = NA) +\n  geom_jitter(width=0.15, color=\"navy\") +\n  theme_classic()\n\n\n\n\nSometimes this can look a bit too busy. One way to contrast things is to set either the points or the boxplots themselves to have some transparency with alpha=.\nHere we make the points a bit transparent:\n\nggplot(wheels1, aes(x = strain, y = day4)) + \n  geom_boxplot(color=\"navy\", fill=\"lightsteelblue1\", outlier.shape = NA) +\n  geom_jitter(width=0.15, color=\"navy\", alpha = .3) +\n  theme_classic()\n\n\n\n\nHere we leave the points solid, but make the boxplot fill transparent:\n\nggplot(wheels1, aes(x = strain, y = day4)) + \n  geom_boxplot(color=\"navy\", fill=\"lightsteelblue1\", outlier.shape = NA, alpha = .3) +\n  geom_jitter(width=0.15, color=\"navy\") +\n  theme_classic()\n\n\n\n\nAnd finally, making both a bit transparent, adding some custom titles and labels. You can just choose what you think looks best!\n\nggplot(wheels1, aes(x = strain, y = day4)) + \n  geom_boxplot(color=\"navy\", fill=\"lightsteelblue1\", outlier.shape = NA, alpha = .3) +\n  geom_jitter(width=0.15, color=\"navy\", alpha=.3) +\n  theme_classic()  +\n  xlab(\"Mouse Strain\") +\n  ylab(\"Total Revolutions\") +\n  ggtitle(\"Mouse Wheel Running\")\n\n\n\n\n\n\n\n5.2.2 Reordering categorical x-axes\nThe boxplot that we made looks ok, but one thing is visually annoying. The boxes are plotted in alphabetical order on the x-axis (B6, F1-129B6….. Swiss). There is no reason why they should be in this order. A more visually appealing way would be to order the boxplots from the group with the highest median to the lowest median.\nTo do this, instead of putting x=strain inside of aes() we put x = reorder(strain, -day4, median) inside instead. This is a bit of a mouthful. To break it down, it’s saying plot strain on the x-axis, but reorder the groups based on the median of the strain column (that’s the ‘-day4’ in the code).\n\nggplot(wheels1, aes(x = reorder(strain, -day4, median), y = day4)) + \n  geom_boxplot(color=\"navy\", fill=\"lightsteelblue1\", alpha = .3) +\n  theme_classic()\n\n\n\n\nThe output looks pretty good - it is now really easy to notice that one of the groups has a much lower distribution than the others. The major issue is that the label of the x-axis is terrible. So let’s fix that:\n\nggplot(wheels1, aes(x = reorder(strain, -day4, median), y = day4)) + \n  geom_boxplot(color=\"navy\", fill=\"lightsteelblue1\", alpha = .3) +\n  theme_classic() +\n  xlab(\"Mouse Strain\") +\n  ylab(\"Total Revolutions\") +\n  ggtitle(\"Mouse Wheel Running\")\n\n\n\n\nMuch nicer!\n\n\n\n5.2.3 Flipping Axes\nOften boxplots look perfectly fine with the categorical grouping variable on the x-axis and the continuous variable on the y-axis. If you start to have many groups, then sometimes the boxplots looks too cluttered when placed on the x-axis. In this situation, it might look better to flip the axes, and have the boxplots stacked vertically. To do this, you write your plot code exactly as you would normally, but you just add + coord_flip() to the end of the code.\nLet’s add this to the reordered boxplots we just made in the previous section:\n\nggplot(wheels1, aes(x = reorder(strain, -day4, median), y = day4)) + \n  geom_boxplot(color=\"navy\", fill=\"lightsteelblue1\", alpha = .3) +\n  theme_classic() +\n  xlab(\"Mouse Strain\") +\n  ylab(\"Total Revolutions\") +\n  ggtitle(\"Mouse Wheel Running\") +\n  coord_flip()\n\n\n\n\nThis is OK, but it would be nicer if the highest values were at the top. There may well be a more straightforward way of doing this, but a quick solution is to wrap reorder(strain, strain, median) with fct_rev, so you now have x = fct_rev(reorder(strain, strain, median)). It’s a whole lot of code, but it does make the graph really pretty, so it’s worth it:\n\nggplot(wheels1, aes(x = fct_rev(reorder(strain, -day4, median)), y = day4)) + \n  geom_boxplot(color=\"navy\", fill=\"lightsteelblue1\", alpha = .3) +\n  theme_classic() +\n  xlab(\"Mouse Strain\") +\n  ylab(\"Total Revolutions\") +\n  ggtitle(\"Mouse Wheel Running\") +\n  coord_flip()"
  },
  {
    "objectID": "distributionsgroups.html#violin-plots",
    "href": "distributionsgroups.html#violin-plots",
    "title": "5  Distributions Across Groups",
    "section": "5.3 Violin Plots",
    "text": "5.3 Violin Plots\nA disadvantage of boxplots, especially when you have large distributions, is that the box does not tell you much about the overall shape of the distribution. An alternative are violin plots, where the width of the shape reflects the shape of the distribution. To make these plots, instead of using geom_boxplot() we use geom_violin().\n\nggplot(wheels1, aes(x = strain, y = day4)) +  \n  geom_violin() + \n  theme_classic()\n\n\n\n\nYou can do all the customizing, reordering, coloring, transparency-ing, etc that you do with boxplots:\n\nggplot(wheels1, aes(x = fct_rev(reorder(strain, strain, median)), y = day4)) + \n  geom_violin(color=\"navy\", fill=\"lightsteelblue1\", alpha = .3) +\n  theme_classic() +\n  xlab(\"Mouse Strain\") +\n  ylab(\"Total Revolutions\") +\n  ggtitle(\"Mouse Wheel Running\") +\n  coord_flip()"
  },
  {
    "objectID": "distributionsgroups.html#stacked-boxplots",
    "href": "distributionsgroups.html#stacked-boxplots",
    "title": "5  Distributions Across Groups",
    "section": "5.4 Stacked Boxplots",
    "text": "5.4 Stacked Boxplots\nSometimes, we want to compare distributions for the same group side by side. For instance, we may not just want to plot the day4 wheel running data, but also plot the day1 data.\nBelow, we have data in wide format. We have ids, strain, day1 running and day4 running.\n\nwheels2 <- wheels %>% select(id, strain, day1, day4)\nhead(wheels2)\n\n# A tibble: 6 x 4\n  id    strain   day1   day4\n  <chr> <chr>   <dbl>  <dbl>\n1 692ao B6     12853  12516.\n2 656aa B6      2644   7404.\n3 675ag B6      4004.  3761 \n4 675ai B6     11754. 11684 \n5 656af B6      6906.  8468.\n6 656al B6      6517   9291 \n\n\nWe need to turn this to long data to be able to make the stacked boxplot graph.\n\nwheels2.long <- wheels2 %>% pivot_longer(cols = 3:4, names_to = \"day\")\nwheels2.long\n\n# A tibble: 160 x 4\n   id    strain day    value\n   <chr> <chr>  <chr>  <dbl>\n 1 692ao B6     day1  12853 \n 2 692ao B6     day4  12516.\n 3 656aa B6     day1   2644 \n 4 656aa B6     day4   7404.\n 5 675ag B6     day1   4004.\n 6 675ag B6     day4   3761 \n 7 675ai B6     day1  11754.\n 8 675ai B6     day4  11684 \n 9 656af B6     day1   6906.\n10 656af B6     day4   8468.\n# ... with 150 more rows\n\n\nNow the wheel running data is in its own column - value. So we use y=value. The grouping variable is in the day column, so we use fill=day to make separate boxplots based on the day. This will also make them different fill colors:\n\nggplot(wheels2.long, aes(x = strain, y = value, fill=day)) + \n  geom_boxplot() +\n  theme_classic()\n\n\n\n\nThis looks ok, but the colors are yucky. Lets add custom titles, labels, and we’ll customize the fill colors using scale_fill_manual. We have two groups (day1 and day4) so we need to provide two colors:\n\nggplot(wheels2.long, aes(x = strain, y = value, fill=day)) + \n  geom_boxplot() +\n  theme_classic() +\n  scale_fill_manual(values = c(\"#9381e3\", \"#faff75\")) +\n  xlab(\"Mouse Strain\") +\n  ylab(\"Total Revolutions\") +\n  ggtitle(\"Mouse Wheel Running\") \n\n\n\n\nIt turns out all the strains increase their overall running in wheels from day 1 to day 4, except the S129 strain who get bored with wheel running - probably similar to how you’re bored of seeing graphs about wheel running."
  },
  {
    "objectID": "distributionsgroups.html#ridgeline-plots",
    "href": "distributionsgroups.html#ridgeline-plots",
    "title": "5  Distributions Across Groups",
    "section": "5.5 Ridgeline Plots",
    "text": "5.5 Ridgeline Plots\nAnother useful way of displaying distributions of data across groups is using ridgeline plots. These are essentially density histogram plots for each categorical group plotted side by side. To do this we need to use a package called ggridges. This can be installed by going to the Packages tab, selecting Install and typing in ggridges in the box.\nLet’s go back to the olives data. Say we are interested in displaying the distribution of oleic acid content by macro.area. We plot the categorical group of interest (here macro.area) on the y-axis, and the continuous variable whose distribution we are interested in (oleic) on the x-axis. We then use stat_density_ridges() to plot the ridgeline plots.\n\nlibrary(ggridges)\nolives <- read_csv(\"data_raw/olives.csv\")\nggplot(olives, aes(x = oleic, y = macro.area)) +\n  stat_density_ridges() +\n  theme_classic()\n\n\n\n\n\nYou can add color by adding in a fill= to the aes().\n\nggplot(olives, aes(x = oleic, y = macro.area, fill = macro.area)) +\n  stat_density_ridges() +\n  theme_classic() \n\n\n\n\n\n… and perhaps we can manually override the default color scheme - here I’m using hex codes to pick a very purply color scheme:\n\nggplot(olives, aes(x = oleic, y = macro.area, fill = macro.area)) +\n  stat_density_ridges() +\n  theme_classic() +\n  scale_fill_manual(values=c(\"#D1B8D0\", \"#F78EF2\", \"#AC33FF\"))\n\n\n\n\n\nA nice thing about these ridgeline plots is that we can easily add on lines that represent the lower quartile, median and upper quartile by adding in the argument quantile_lines = TRUE like this:\n\nggplot(olives, aes(x = oleic, y = macro.area, fill = macro.area)) +\n  stat_density_ridges(quantile_lines = TRUE) +\n  theme_classic() +\n  scale_fill_manual(values=c(\"#D1B8D0\", \"#F78EF2\", \"#AC33FF\"))\n\n\n\n\n\nThe final ridgeline plot below plots the distributions of oleic acid by region. There are 9 regions. It’s best in these plots to try and plot the categories from highest to lowest median, as it looks nicer. The following code is a bit tricky, and if you’re not interested - then you can safely ignore. However, just in case it is of interest to anyone: to do that you need to make sure ggplot recognizes the categorical variable region in this case to be a factor (a grouped variable) and that they are in the right order. It can be done using using this line: fct_reorder(region, -oleic, .fun = median). Essentially this says, make the region variable a factor, and reorder it to be from highest median of oleic acid to lowest. One final thing - you have to do this for both the y axis category, and the fill - otherwise your colors won’t match your y-axis categories.\nIn the below code, I also added quantiles, x-axis and y-axis titles, a title and I removed the legend as it didn’t add any extra information that isn’t already on the plot.\n\nggplot(olives, aes(x = oleic, \n                   y = fct_reorder(region, -oleic, .fun = median), \n                   fill = fct_reorder(region, -oleic, .fun = median)\n                   )) +\n  stat_density_ridges(quantile_lines = TRUE) +\n  theme_classic() +\n  scale_fill_manual(values=c(\"#0000FF\", \"#2000DF\", \"#4000BF\", \"#60009F\", \"#800080\", \"#9F0060\", \"#BF0040\", \"#DF0020\", \"#FF0000\")) +\n  theme(legend.position = \"none\") +\n  ylab(\"Region\") +\n  xlab(\"Oleic Acid Content\") +\n  ggtitle(\"Oleic Acid Content of Italian Olives by Region\")\n\n\n\n\n\nFor more information about these plots, you can look up the help documentation for this package here."
  },
  {
    "objectID": "histograms.html",
    "href": "histograms.html",
    "title": "4  Summary",
    "section": "",
    "text": "There is no summary. I was just scared to delete this file."
  },
  {
    "objectID": "histograms.html#histograms-with-ggplot2",
    "href": "histograms.html#histograms-with-ggplot2",
    "title": "4  Histograms",
    "section": "4.1 Histograms with ggplot2",
    "text": "4.1 Histograms with ggplot2\nTo describe how to make histograms with the ggplot() function, lets look at the films.csv dataset.\n\nlibrary(tidyverse)\nfilm <- read_csv(\"data_raw/films.csv\")\nhead(film)\n\n# A tibble: 6 x 5\n  film                     year rottentomatoes  imdb metacritic\n  <chr>                   <dbl>          <dbl> <dbl>      <dbl>\n1 Avengers: Age of Ultron  2015             74   7.8         66\n2 Cinderella               2015             85   7.1         67\n3 Ant-Man                  2015             80   7.8         64\n4 Do You Believe?          2015             18   5.4         22\n5 Hot Tub Time Machine 2   2015             14   5.1         29\n6 The Water Diviner        2015             63   7.2         50\n\n\nThis dataset contains 146 rows of data. Each row has a unique film, with the final three columns giving three different ratings measures of how good the film was. These are their respective rottentomatoes, imdb and metacritic scores.\nIf we wished to plot the distribution of imdb scores, we need to put x=imdb inside the aes() part of the ggplot code. That is to tell it to plot these scores on the x-axis. We do not need to put a y= inside this, as we are not plotting anything from our dataset on the y-axis. Instead, ggplot2 will count up the frequency of our scores between regular intervals of imdb scores.\nWe then add + geom_histogram() to tell it to make a histogram. All together it looks like this:\n\nggplot(film, aes(x=imdb)) + \n  geom_histogram()  \n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nNow, this doesn’t look great and we have several problems with it. The two major problems that we get with our first histograms are. 1) The binwidth is almost never appropriate. We need to tell ggplot exactly what we want the binwidth on the x-axis to be. That is, what interval do we want our scores to be counted over. Looking at the graph, our scores range from just below 4 to about 8.6. Perhaps a better interval would be 0.2, so we count how many films had scores between 3.6-3.8, 3.8-4.0, 4.0-4.2, 4.2-4.4, …….. 8.4-8.6, 8.6-8.8 etc. 2) Having black bars makes it really hard to distinguish the bars when they are close in heights. We need to fix the color scheme.\nOK, let’s make the bars dodgerblue and border them white. Inside geom_histogram() we use color=\"white\" to represent the outside lines of the bars. We use fill=\"dodgerblue to indicate the color inside the bars should be dodgerblue.\n\nggplot(film, aes(x=imdb)) + \n  geom_histogram(color=\"white\", fill=\"dodgerblue\") \n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nNow let’s fix that binwidth. To resolve this, inside geom_histogram() we write binwidth = 0.2.\n\nggplot(film, aes(x = imdb)) + \n  geom_histogram(binwidth = 0.2, color=\"white\", fill=\"dodgerblue\") \n\n\n\n\nThis looks a lot better. Now we can see that the majority of films have ratings in the 6.2-7.8 range, with relatively few above 8 and below 5. It’s not always easy to know what size interval to choose for the x-axis in histograms. It’s worth just playing around with that number and seeing how it looks.\nWhen we set the interval to be some value - here, we chose 0.2 - R doesn’t automatically make that between easy to interpret numbers such as 4.0-4.2, 4.2-4.4 etc. It could just as easily have chosen 3.874-4.074, 4.074-4.274. Obviously, the latter is hard for us to interpret when looking at the axes. You can see in the above plot, that the vertical lines of the histogram bars don’t neatly fall on top of whole numbers. To fix, this you can adjust the boundaries by picking a value to center your interval on. So, if we pick boundary=4, then that will be a boundary marker, and the interval will go 4.0-4.2, 4.2-4.4 etc.\n\nggplot(film, aes(x = imdb)) + \n  geom_histogram(binwidth = 0.2, color=\"white\", fill=\"dodgerblue\",boundary=4) \n\n\n\n\nJust be careful with using the boundaries that it does not crop your histogram incorrectly. Changing histograms too much can lead to misrepresenting the data. We would recommend that you don’t use the boundary feature unless you have a real need to do so - just be careful!\nLike with all ggplot figures, you can add as much customization as you wish. Here, we add a new theme, title and x- and y-axis labels:\n\nggplot(film, aes(x = imdb)) + \n  geom_histogram(binwidth = 0.2, color=\"white\", fill=\"dodgerblue\") +\n  theme_classic() +\n  ggtitle(\"Histogram of IMDB Ratings\") +\n  xlab(\"Rating\") +\n  ylab(\"Frequency\")\n\n\n\n\nThis looks really nice !"
  },
  {
    "objectID": "histograms.html#density-curves",
    "href": "histograms.html#density-curves",
    "title": "4  Histograms",
    "section": "4.2 Density Curves",
    "text": "4.2 Density Curves\nInstead of plotting the frequency or counts of values on the y-axis, we can instead plot density. Here, we essentially convert the histogram to a solid line that estimates the overall shape of the distribution. We call this line a density curve. You can make this plot using ggplot() using + geom_density() instead of + geom_histogram().\nIn the code below we do this for the imdb ratings, and we make the line color navy, and the fill of the density curve dodgerblue:\n\nggplot(film, aes(x = imdb)) + \n  geom_density(color = \"navy\", fill = \"dodgerblue\") \n\n\n\n\nUsually the fill of these plots is too much, so it’s nice to add some transparency. You can do that by picking a number between 0 and 1 to provide to the alpha argument. Here we choose alpha = .4:\n\nggplot(film, aes(x = imdb)) +  \n  geom_density(color = \"navy\", fill = \"dodgerblue\", alpha=.4)\n\n\n\n\nThe useful thing about density plots is that they give you a quick visual aid as to the overall shape of the distribution. You can easily see where the bulk of the data lie (here between 6 and 8 ratings score), and whether the data is symmetrical or not."
  },
  {
    "objectID": "histograms.html#comparing-distributions",
    "href": "histograms.html#comparing-distributions",
    "title": "4  Histograms",
    "section": "4.3 Comparing Distributions",
    "text": "4.3 Comparing Distributions\nInstead of just plotting one histogram or one density curve, we often are interested in comparing two or more distributions. This means we are interested in comparing two or more histograms or density curves. To do this, we first need to ensure that our data are all measured in the same units.\n\nOverlaid Histograms\nTo illustrate this, let’s use the lifeexp.csv data which contains life expectancy data for many countries.\n\nlife <- read_csv(\"data_raw/lifeexp.csv\")\nhead(life)\n\n# A tibble: 6 x 6\n  country     continent year      lifeExp      pop gdpPercap\n  <chr>       <chr>     <chr>       <dbl>    <dbl>     <dbl>\n1 Afghanistan Asia      year_1952    28.8  8425333      779.\n2 Afghanistan Asia      year_2007    43.8 31889923      975.\n3 Albania     Europe    year_1952    55.2  1282697     1601.\n4 Albania     Europe    year_2007    76.4  3600523     5937.\n5 Algeria     Africa    year_1952    43.1  9279525     2449.\n6 Algeria     Africa    year_2007    72.3 33333216     6223.\n\n\nYou can see that one of the columns is called lifeExp which is the life expectancy of each country in either 1952 or 2007. The year is shown in the year column, and the country is shown in the country column. You’ll notice that these data are in long format.\nPerhaps we are interested in the distribution of life expectancies across all countries in the year 1952 compared to the distribution of life expectancies in the year 2007. We have a few options to do this.\nThe first option does not look good for this example (although it may work in other situations). This is an overlaid histogram. To do this, inside aes() as well as saying which column our distribution data is in x=lifeExp, we also tell it to make separate histograms based on the year column with fill=year. This will ensure it uses different fill colors for the two different years. Although not necessary, putting position=\"identity\" inside geom_histogram() helps make the plot a little nicer. Putting color=\"black\" and alpha=.7 inside geom_histogram() also helps distinguish the two histograms.\n\nggplot(life, aes(x=lifeExp, fill=year)) +  \n  geom_histogram(binwidth=2, position=\"identity\", color=\"black\", alpha=.7) +\n  theme_minimal()\n\n\n\n\nThis plot is still pretty bad though. This method of plotting is better when the histograms are quite distinctive from one another and there isn’t much overlap in the distributions.\nChoosing two colors that contrast more strongly than the default colors can help. Here, we are using hexcodes to pick a gray and a mustard yellow color. We manually define our fill colors using +  scale_fill_manual(values = c(\"#999999\", \"#E69F00\")). To change the colors, just change the hexcodes to different ones or the names of colors you’d like. Just make sure that you have the same number of colors as groups in your data. Here, we have two groups (1952 and 2007) so we need two colors. Also, notice that it says scale_fill_manual and not scale_color_manual. Because we are dealing with the inside color - this is considered to be a fill in ggplot2 terms. We used fill=year inside aes() so we need to match that with fill when manually choosing colors.\n\nggplot(life, aes(x=lifeExp, fill=year)) +  \n  geom_histogram( binwidth=2, position=\"identity\", color=\"black\", alpha=.7) +\n  theme_minimal() +\n  scale_fill_manual(values = c(\"#999999\", \"#E69F00\"))\n\n\n\n\nOverlaid Density Plots\nComparing distributions can also be done with geom_density. This is usually simpler to compare than overlaid histograms.\nThe default plot for this would be to include fill=year inside the aes() code, as the year column contains the data that we wish to make separate plots for.\n\nggplot(life, aes(x=lifeExp, fill=year)) +  \n  geom_density(alpha = 0.4) \n\n\n\n\nWe can add a custom fill colors with + scale_fill_manual(values = c(\"#999999\", \"#E69F00\")) and a custom theme with + theme_classic().\n\nggplot(life, aes(x=lifeExp, fill=year)) +  \n  geom_density(aes(fill = year), alpha = 0.4) +\n  scale_fill_manual(values = c(\"#999999\", \"#E69F00\"))  + \n  theme_classic()\n\n\n\n\nThis plot is now very easy to interpret. It’s clear that in 2007 most countries had life expectancies of over 70, with a tail towards younger life expectancies. In 1952, the opposite pattern is found with most countries having life expectancies around 40 with the tail going towards older countries."
  },
  {
    "objectID": "histograms.html#stem-and-leaf-plots",
    "href": "histograms.html#stem-and-leaf-plots",
    "title": "4  Histograms",
    "section": "4.4 Stem-and-Leaf Plots",
    "text": "4.4 Stem-and-Leaf Plots\nStem-and-leaf plots are a simplistic version of histograms. Before the advent of computers, this kind of plot would sometimes be easier to make than a histogram. Their heyday was quite a few decades ago! In fact, nowadays, these types of plots are almost never made by researchers or data scientists in the real world. They are pretty much exclusive to introductory statistics courses. This is a bit of a shame because we think they are pretty cute.\nHere is an example. Imagine we have the following numbers in a distribution. They may represent temperatures:\n20, 20, 23, 28, 29, 31, 32, 39, 40, 41, 42, 44, 44, 45, 48, 49, 55, 55, 56, 58, 59, 61, 62, 65, 66, 67, 70, 71, 75, 82, 86\nWe can represent these in a stem-and-leaf plot as below. The first column represents the “tens” and the second column represents the “ones”. So the “6” in the last row in the second column represents a temperature of 86. We put the second column data in ascending order. The heights of these bars represent a kind of histogram of sorts.\n\nThe columns do not have to be tens and ones. For instance, if our data had been seconds, and the distribution was 2.0, 2.0, 2.3, 2.8....... 7.5, 8.2, 8.6 we could have done the same stem-and-leaf plot.\nThere isn’t a simple ggplot way of making stem-and-leaf plots, but there is a built-in function called stem() that can make them.\nFor an example, if we return to our imdb ratings:\n\nhead(film)\n\n# A tibble: 6 x 5\n  film                     year rottentomatoes  imdb metacritic\n  <chr>                   <dbl>          <dbl> <dbl>      <dbl>\n1 Avengers: Age of Ultron  2015             74   7.8         66\n2 Cinderella               2015             85   7.1         67\n3 Ant-Man                  2015             80   7.8         64\n4 Do You Believe?          2015             18   5.4         22\n5 Hot Tub Time Machine 2   2015             14   5.1         29\n6 The Water Diviner        2015             63   7.2         50\n\n\nWe can make a stem-and-leaf plot of the imdb column like this. The scale=0.6 parameter dictates how long the stem-and-leaf plot should be. You can adjust it to your liking. Lower numbers make the plot shorter:\n\nstem(film$imdb, scale=0.6)\n\n\n  The decimal point is at the |\n\n  4 | 0234\n  4 | 6699\n  5 | 01224444\n  5 | 555556678999\n  6 | 0011112333333333444444\n  6 | 5555666666666777777789999999\n  7 | 0000111111122222222223333344444444\n  7 | 555555666777788888888899\n  8 | 012222344\n  8 | 6\n\n\nHere, the lowest rating we have is 4.0, and the highest is 8.6."
  }
]